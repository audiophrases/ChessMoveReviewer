<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>AI Chess Reviewer</title>

  <!-- Tailwind Play CDN (ok for prototypes) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css" crossorigin="anonymous">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
    body { font-family: 'Inter', sans-serif; background-color: #0f1115; color: #e5e7eb; }
    .chessboard-container { width: 100%; margin: 0 auto; aspect-ratio: 1 / 1; }
    .move-item { transition: background-color 0.2s ease-in-out; border-radius: 0.5rem; }
    .move-item.highlight { background-color: #243249; }
    .move-item:hover { background-color: #1c273a; }
    .move-item.featured { border: 1px solid rgba(250, 204, 21, 0.35); background-color: rgba(250, 204, 21, 0.06); }
    .move-item.featured:hover { background-color: rgba(250, 204, 21, 0.12); }
    .move-item.featured.highlight { background-color: #243249; }
    #eval-graph { cursor: pointer; transition: opacity 0.2s ease-in-out; }
    #eval-graph.exploration-disabled { opacity: 0.85; }
    #move-analysis-scroll::-webkit-scrollbar { width: 8px; }
    #move-analysis-scroll::-webkit-scrollbar-track { background: #1a1f2a; }
    #move-analysis-scroll::-webkit-scrollbar-thumb { background-color: #4b5563; border-radius: 10px; border: 2px solid #1a1f2a; }
    .btn-primary { background-color: #3b82f6; transition: background-color 0.2s; }
    .btn-primary:hover { background-color: #2563eb; }
    .btn-primary:disabled { background-color: #374151; cursor: not-allowed; }
    .btn-secondary { background-color: #374151; transition: background-color: 0.2s; }
    .btn-secondary:hover { background-color: #4b5563; }
    #toggle-eval-btn { border: 1px solid transparent; transition: background-color 0.2s, border-color 0.2s, color 0.2s; }
    #toggle-eval-btn.best-active { background-color: #0b0e15; border-color: rgba(250, 204, 21, 0.4); color: #facc15; font-family: 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas', 'Liberation Mono', 'Courier New', monospace; }
    #toggle-eval-btn.best-active:hover { background-color: #131a2c; }
    textarea.form-input, input.form-input { background-color: #2d2d2d; border-color: #364152; color: #e5e7eb; }
    textarea.form-input:focus, input.form-input:focus { border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.35); outline: none; }
    input[type=number]::-webkit-outer-spin-button,
    input[type=number]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    input[type=number] { -moz-appearance: textfield; }
    .step-indicator { background-color: #273043; cursor: pointer; }
    .step-indicator.active { background-color: #3b82f6; }
    .step-indicator:focus-visible { outline: 2px solid #60a5fa; outline-offset: 2px; }
    #board .square-55d63.selected { background-color: rgba(251, 191, 36, 0.5); }
    #prev-btn, #next-btn { font-size: 1rem; }
    .status-banner { display: none; border-radius: 0.75rem; padding: 0.75rem 1rem; border: 1px solid transparent; }
    .status-banner.status-visible { display: flex; align-items: flex-start; gap: 0.75rem; }
    .status-banner.status-info { background-color: rgba(59, 130, 246, 0.12); border-color: rgba(59, 130, 246, 0.35); color: #bfdbfe; }
    .status-banner.status-error { background-color: rgba(239, 68, 68, 0.12); border-color: rgba(239, 68, 68, 0.35); color: #fecaca; }
    .status-banner .detail { color: rgba(191, 219, 254, 0.8); font-size: 0.75rem; margin-top: 0.25rem; }
    .status-banner.status-error .detail { color: rgba(254, 202, 202, 0.85); }
    .board-sticky-wrapper { top: 0.5rem; }
    @media (max-width: 1023px) {
      .board-sticky-wrapper { top: 0; }
    }
  </style>
</head>
<body class="min-h-screen flex flex-col p-3 sm:p-4">

  <!-- Header (hidden on final screen) -->
  <header id="app-header" class="text-center mb-6">
    <h1 class="text-2xl sm:text-3xl font-bold text-white">AI Chess Reviewer</h1>
  </header>

  <!-- Step Indicators -->
  <div id="step-indicators" class="flex justify-center items-center space-x-3 mb-6">
    <div id="indicator-1" class="step-indicator active w-8 h-2 rounded-full" data-step="1" role="button" tabindex="0" aria-label="Go to Step 1"></div>
    <div id="indicator-2" class="step-indicator w-8 h-2 rounded-full" data-step="2" role="button" tabindex="0" aria-label="Go to Step 2"></div>
    <div id="indicator-3" class="step-indicator w-8 h-2 rounded-full" data-step="3" role="button" tabindex="0" aria-label="Go to Step 3"></div>
  </div>

  <!-- Step 1: PGN Input -->
  <section id="step1-section" class="max-w-2xl w-full mx-auto flex flex-col gap-4">
    <h2 class="text-xl sm:text-2xl font-bold text-center">Analyze PGN with Stockfish</h2>
    <div id="engine-status-banner" class="status-banner">
      <div class="flex-1">
        <p id="engine-status-message" class="font-medium"></p>
        <p id="engine-status-detail" class="detail hidden"></p>
      </div>
      <button id="retry-engine-btn" type="button" class="hidden self-start py-2 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap">Retry</button>
    </div>
    <div>
      <div class="flex items-center justify-between gap-2 mb-2">
        <label for="player-name-input" class="font-semibold text-gray-300">Who should the AI coach?</label>
      </div>
      <input id="player-name-input" type="text" class="w-full p-3 rounded-lg form-input" placeholder="Username"/>
      <p class="mt-1 text-xs text-gray-400">Your username should appear in the PGN.</p>
    </div>
    <div class="bg-[#101522] border border-[#1f2937] rounded-lg p-4">
      <h3 class="text-sm font-semibold text-gray-200">Need a PGN?</h3>
      <p class="mt-1 text-xs text-gray-400">Load a recent game from Chess.com or Lichess, or paste one manually below.</p>
      <div class="flex flex-wrap items-center gap-2 mt-3">
        <button id="load-chesscom-btn" type="button" class="py-2 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap">
          Browse Chess.com games
        </button>
        <button id="load-lichess-btn" type="button" class="py-2 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap">
          Browse Lichess games
        </button>
        <button type="button" class="py-2 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap open-archive-btn">
          Open Saved Reviews
        </button>
      </div>
      <p id="game-loader-feedback" class="hidden mt-3 text-xs text-gray-300" role="status"></p>
    </div>
    <div>
      <div class="flex items-center justify-between gap-2 mb-2">
        <label for="pgn-input" class="font-semibold text-gray-300">Paste PGN here</label>
        <button id="clear-pgn-btn" type="button" class="py-2 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap">Clear</button>
      </div>
      <textarea id="pgn-input" rows="6" class="w-full p-3 rounded-lg form-input" placeholder="[Event &quot;...&quot;]..."></textarea>
    </div>
    <div class="flex justify-center gap-2 text-sm">
      <div class="flex flex-col items-center">
        <label for="depth-input" class="text-gray-300">Depth</label>
        <input id="depth-input" type="number" min="4" value="20" class="w-16 p-1 rounded form-input text-center"/>
      </div>
      <div class="flex flex-col items-center">
        <label for="threads-input" class="text-gray-300">Threads</label>
        <input id="threads-input" type="number" min="1" value="4" class="w-16 p-1 rounded form-input text-center"/>
      </div>
      <div class="flex flex-col items-center">
        <label for="hash-input" class="text-gray-300">Memory</label>
        <input id="hash-input" type="number" min="256" value="469" class="w-16 p-1 rounded form-input text-center"/>
      </div>
    </div>
    <div class="grid grid-cols-2 gap-2">
      <button id="analyze-pgn-btn" class="w-full py-3 px-6 text-lg font-semibold text-white rounded-lg btn-primary" disabled>
        Loading Engine...
      </button>
      <button id="goto-step2-btn" type="button" class="w-full py-3 px-6 text-lg font-semibold text-white rounded-lg btn-secondary">
        Skip
      </button>
    </div>
  </section>

  <!-- Step 2: Stockfish Output & AI Instructions -->
  <section id="step2-section" class="hidden max-w-2xl w-full mx-auto flex flex-col gap-4">
    <h2 class="text-xl sm:text-2xl font-bold text-center">Get AI Coaching Comments</h2>
    <div id="stockfish-progress" class="text-center p-4 bg-[#101522] rounded-lg">
       <div class="w-full bg-gray-700 rounded-full h-2 mt-2">
        <div id="progress-bar" class="bg-blue-500 h-2 rounded-full" style="width: 0%"></div>
      </div>
    </div>
    <div>
      <label for="stockfish-output" class="block mb-2 font-semibold text-gray-300">Copy the prompt + annotated PGN below</label>
      <textarea id="stockfish-output" rows="7" class="w-full p-3 rounded-lg form-input font-mono text-sm" readonly></textarea>
      <button id="copy-stockfish-btn" class="w-full mt-2 py-2 px-4 font-semibold text-white rounded-lg btn-secondary">Copy to Clipboard</button>
    </div>
    <div class="grid grid-cols-2 gap-2">
      <button id="back-to-step1-btn" type="button" class="w-full py-3 px-6 text-lg font-semibold text-white rounded-lg btn-secondary">
        Back
      </button>
      <button id="goto-step3-btn" type="button" class="w-full py-3 px-6 text-lg font-semibold text-white rounded-lg btn-primary">
        Continue
      </button>
    </div>
  </section>

  <!-- Step 3: Final Analysis Input -->
  <section id="step3-section" class="hidden max-w-2xl w-full mx-auto flex flex-col gap-4">
    <h2 class="text-xl sm:text-2xl font-bold text-center">Paste Your Final AI Review</h2>
    <div>
      <label for="final-analysis-input" class="block font-semibold text-gray-300 mb-2">Paste complete analysis here</label>
      <div class="flex flex-col sm:flex-row sm:items-start gap-2">
        <textarea id="final-analysis-input" rows="6" class="flex-1 w-full p-3 rounded-lg form-input" placeholder="e4 - {3} Good: A classical opening move...\n...\nSummary: Black won after a decisive kingside attack."></textarea>
        <button id="clear-final-analysis-btn" type="button" class="sm:self-start py-2 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap">Clear</button>
      </div>
    </div>
    <div class="grid grid-cols-2 gap-2">
      <button id="back-to-step2-btn" type="button" class="w-full py-3 px-6 text-lg font-semibold text-white rounded-lg btn-secondary">
        Back
      </button>
      <button id="generate-review-btn" class="w-full py-3 px-6 text-lg font-semibold text-white rounded-lg btn-primary">
        Review
      </button>
    </div>
  </section>

  <!-- Final Review Section (mobile-optimized) -->
  <main id="review-section" class="hidden flex-1 max-w-5xl w-full mx-auto">
    <div class="w-full flex justify-start mb-3">
      <button id="back-to-step3-btn" type="button" class="px-4 py-2 text-white font-semibold rounded-lg btn-secondary">Back</button>
    </div>
    <div class="w-full grid grid-cols-1 lg:grid-cols-2 gap-3">
      <!-- Column A: Board + evaluation graph (sticky) -->
      <div class="lg:col-span-1 sticky top-2 board-sticky-wrapper">
        <!-- Evaluation graph -->
        <canvas id="eval-graph" class="w-full mb-2"></canvas>

        <!-- Board -->
        <div class="w-full max-w-xl mx-auto">
          <div id="board" class="chessboard-container"></div>
          <div id="controls" class="mt-3 flex items-center justify-end gap-2 w-full">
            <button id="toggle-eval-btn" type="button" class="px-4 py-2 text-white font-semibold rounded-lg btn-secondary" aria-pressed="false">Analyze</button>
            <button id="flip-btn" class="px-4 py-2 text-white font-semibold rounded-lg btn-secondary">Flip</button>
            <button id="prev-btn" class="px-3 py-2 text-white font-semibold rounded-lg btn-secondary" aria-label="Previous move">Prev</button>
            <button id="next-btn" class="px-3 py-2 text-white font-semibold rounded-lg btn-secondary" aria-label="Next move">Next</button>
          </div>
        </div>
      </div>

      <!-- Column B: Independently scrollable analysis (no titles) -->
      <div class="lg:col-span-1 flex flex-col gap-3">
        <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
          <div class="flex flex-wrap items-center gap-2">
            <button id="save-archive-btn" type="button" class="py-2 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap" disabled>
              Save to Archive
            </button>
            <button type="button" class="py-2 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap open-archive-btn">
              Open Archive
            </button>
          </div>
          <p id="archive-feedback" class="hidden text-xs"></p>
        </div>
        <div id="move-analysis-shell" class="bg-[#101522] p-3 rounded-lg">
          <div id="move-analysis-scroll" class="overflow-y-auto">
            <!-- One-line summary appears here (from "Summary:") -->
            <div id="game-summary" class="hidden mb-3 p-2 rounded bg-[#0b0e15] text-sm text-gray-200"></div>
            <div id="featured-move" class="hidden mb-3"></div>
            <div id="move-analysis-container" class="space-y-1"></div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Game Picker Modal -->
  <div id="game-picker-modal" class="hidden fixed inset-0 z-50 bg-black bg-opacity-70 flex items-center justify-center px-4" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="bg-[#141926] w-full max-w-lg p-6 rounded-xl shadow-2xl border border-[#1f2937]">
      <div class="flex items-start justify-between gap-3">
        <h3 id="game-picker-title" class="text-xl font-semibold text-white">Select a game</h3>
        <button id="close-game-picker-btn" type="button" class="py-1.5 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap">Close</button>
      </div>
      <p id="game-picker-status" class="mt-3 text-sm text-gray-300"></p>
      <div id="game-picker-list" class="mt-4 space-y-2 max-h-96 overflow-y-auto" role="list"></div>
    </div>
  </div>

  <!-- Error Modal -->
  <div id="error-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
    <div class="bg-[#141926] p-8 rounded-lg shadow-xl max-w-sm w-full text-center">
      <h3 class="text-2xl font-bold text-red-400 mb-4">Error</h3>
      <p id="error-message" class="text-gray-300 mb-6">Could not process the input.</p>
      <button id="close-modal-btn" class="py-2 px-6 font-semibold text-white rounded-lg btn-primary">Close</button>
    </div>
  </div>

  <!-- Archive Modal -->
  <div id="archive-modal" class="hidden fixed inset-0 z-50 bg-black bg-opacity-70 flex items-center justify-center px-4" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="bg-[#141926] w-full max-w-lg p-6 rounded-xl shadow-2xl border border-[#1f2937]">
      <div class="flex flex-wrap items-center justify-between gap-2">
        <h3 class="text-xl font-semibold text-white">Saved Reviews</h3>
        <div class="flex items-center gap-2">
          <button id="clear-archive-btn" type="button" class="py-1.5 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap">Clear All</button>
          <button id="close-archive-btn" type="button" class="py-1.5 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap">Close</button>
        </div>
      </div>
      <p id="archive-status" class="mt-3 text-sm text-gray-300"></p>
      <div id="archive-list" class="mt-4 space-y-3 max-h-96 overflow-y-auto"></div>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.5.1.min.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.2/chess.js"></script>

  <script>
    $(function () {
      $('#threads-input').val(4);

      const hardwareThreadCap = (typeof navigator !== 'undefined' && navigator.hardwareConcurrency)
        ? Math.max(1, Math.min(16, navigator.hardwareConcurrency))
        : 8;

      function sanitizeIntegerSetting(value, rules) {
        const normalizedRules = rules || {};
        const fallback = Number.isFinite(normalizedRules.fallback) ? normalizedRules.fallback : 0;
        let numeric = parseInt(value, 10);
        if (!Number.isFinite(numeric)) numeric = fallback;
        if (Number.isFinite(normalizedRules.min) && numeric < normalizedRules.min) numeric = normalizedRules.min;
        if (Number.isFinite(normalizedRules.max) && numeric > normalizedRules.max) numeric = normalizedRules.max;
        if (!Number.isFinite(numeric)) numeric = fallback;
        return numeric;
      }

      const ENGINE_SETTING_LIMITS = {
        depth: { min: 4, max: 30, fallback: sanitizeIntegerSetting($('#depth-input').val(), { fallback: 24 }) },
        threads: { min: 1, max: hardwareThreadCap, fallback: sanitizeIntegerSetting($('#threads-input').val(), { fallback: 4 }) },
        hash: { min: 32, max: 512, fallback: sanitizeIntegerSetting($('#hash-input').val(), { fallback: 384 }) }
      };

      function sanitizeEngineSetting(key, value) {
        const rules = ENGINE_SETTING_LIMITS[key] || {};
        const fallback = Number.isFinite(rules.fallback)
          ? Math.min(Math.max(rules.fallback, rules.min ?? rules.fallback), rules.max ?? rules.fallback)
          : 0;
        let numeric = parseInt(value, 10);
        if (!Number.isFinite(numeric)) numeric = fallback;
        if (Number.isFinite(rules.min) && numeric < rules.min) numeric = rules.min;
        if (Number.isFinite(rules.max) && numeric > rules.max) numeric = rules.max;
        if (!Number.isFinite(numeric)) numeric = fallback;
        return numeric;
      }

      Object.keys(ENGINE_SETTING_LIMITS).forEach(key => {
        const rules = ENGINE_SETTING_LIMITS[key];
        rules.fallback = sanitizeEngineSetting(key, rules.fallback);
      });

      const STEP_HASHES = { 1: '', 2: '#step-2', 3: '#step-3', 4: '#step-4' };
      const DEFAULT_PLAYER_NAME = 'eugenime';
      let formState = loadFormState();
      let currentStep = 1;

      // ====== App state ======
      let board = null;
      let game = new Chess();
      let reviewPlayerColor = null;
      let lastEngineMoveRecords = null;
      let movesWithAnalysis = [];
      let currentMoveIndex = -1;
      let probSeries = []; // WHITE win probability per ply (0..1)
      let evalCanvas = null;
      let evalCtx = null;
      const copyStockfishBtn = $('#copy-stockfish-btn');
      const defaultCopyLabel = copyStockfishBtn.length ? (copyStockfishBtn.text().trim() || 'Copy to Clipboard') : 'Copy to Clipboard';
      const analyzingCopyLabel = 'Analyzing...';
      let featuredMoveData = null;
      let featuredMoveIndex = -1;
      let lastAnnotatedPgn = '';
      let playerGameOutcome = null;
      const engineStatusBanner = $('#engine-status-banner');
      const engineStatusMessage = $('#engine-status-message');
      const engineStatusDetail = $('#engine-status-detail');
      const retryEngineBtn = $('#retry-engine-btn');
      let explorationState = null;
      const loadChessComBtn = $('#load-chesscom-btn');
      const loadLichessBtn = $('#load-lichess-btn');
      const gameLoaderFeedback = $('#game-loader-feedback');
      const gamePickerModal = $('#game-picker-modal');
      const gamePickerTitle = $('#game-picker-title');
      const gamePickerStatus = $('#game-picker-status');
      const gamePickerList = $('#game-picker-list');
      const closeGamePickerBtn = $('#close-game-picker-btn');
      let activeGameRequestToken = 0;
      let gamePickerReturnFocus = null;
      const saveArchiveBtn = $('#save-archive-btn');
      const archiveFeedback = $('#archive-feedback');
      const openArchiveButtons = $('.open-archive-btn');
      const archiveModal = $('#archive-modal');
      const archiveList = $('#archive-list');
      const archiveStatus = $('#archive-status');
      const closeArchiveBtn = $('#close-archive-btn');
      const clearArchiveBtn = $('#clear-archive-btn');
      let archiveReturnFocus = null;
      let archiveFeedbackTimeout = null;
      const ARCHIVE_STORAGE_KEY = 'cmr.reviewArchive.v1';
      const ARCHIVE_MAX_ENTRIES = 25;
      let archiveEntries = [];
      let storageAvailable = isLocalStorageAvailable();
      if (storageAvailable) {
        archiveEntries = loadArchiveEntriesFromStorage();
      }
      let lastFinalAnalysisText = '';
      let currentReviewMetadata = null;
      let pendingArchiveLoadNotice = null;

      applySavedFormState();
      bindPersistentInput('#player-name-input', 'playerName');
      bindPersistentInput('#pgn-input', 'pgnInput');
      bindPersistentInput('#final-analysis-input', 'finalAnalysisInput');
      bindPersistentInput('#depth-input', 'depthInput', { sanitize: value => sanitizeEngineSetting('depth', value) });
      bindPersistentInput('#threads-input', 'threadsInput', { sanitize: value => sanitizeEngineSetting('threads', value) });
      bindPersistentInput('#hash-input', 'hashInput', { sanitize: value => sanitizeEngineSetting('hash', value) });
      $('#player-name-input').on('input change', function () {
        const rawName = getRawPlayerNameInput();
        if (rawName) {
          updateReviewPlayerColorFromGame(game, rawName);
        } else {
          setReviewPlayerColor(null);
        }
        updatePlayerOutcomeFromGame(game);
        if (Array.isArray(lastEngineMoveRecords) && lastEngineMoveRecords.length) {
          automatedMoveInsights = computeAutomatedMoveInsights(lastEngineMoveRecords, reviewPlayerColor, playerGameOutcome);
          automatedReviewText = buildAutomatedReviewText(automatedMoveInsights);
        }
        refreshStockfishOutput();
      });

      if (loadChessComBtn.length) {
        loadChessComBtn.data('defaultLabel', loadChessComBtn.text().trim() || 'Browse Chess.com games');
        loadChessComBtn.on('click', function () { handleGameLoad('chesscom'); });
      }
      if (loadLichessBtn.length) {
        loadLichessBtn.data('defaultLabel', loadLichessBtn.text().trim() || 'Browse Lichess games');
        loadLichessBtn.on('click', function () { handleGameLoad('lichess'); });
      }
      if (closeGamePickerBtn.length) {
        closeGamePickerBtn.on('click', function () { closeGamePickerModal(); });
      }
      if (gamePickerModal.length) {
        gamePickerModal.on('click', function (evt) {
          if (evt.target === this) { closeGamePickerModal(); }
        });
      }
      $(document).on('keydown', function (evt) {
        if (evt.key === 'Escape' || evt.key === 'Esc') {
          if (archiveModal.length && !archiveModal.hasClass('hidden')) {
            evt.preventDefault();
            closeArchiveModal();
            return;
          }
          if (gamePickerModal.length && !gamePickerModal.hasClass('hidden')) {
            evt.preventDefault();
            closeGamePickerModal();
          }
        }
      });

      if (saveArchiveBtn.length) {
        saveArchiveBtn.on('click', function () {
          handleSaveArchiveEntry();
        });
      }
      if (openArchiveButtons.length) {
        openArchiveButtons.on('click', function () {
          if (!storageAvailable) {
            showArchiveFeedback('Saving is unavailable in this browser session.', 'error');
            return;
          }
          openArchiveModal();
        });
      }
      if (archiveModal.length) {
        archiveModal.on('click', function (evt) {
          if (evt.target === this) { closeArchiveModal(); }
        });
      }
      if (closeArchiveBtn.length) {
        closeArchiveBtn.on('click', function () { closeArchiveModal(); });
      }
      if (clearArchiveBtn.length) {
        clearArchiveBtn.on('click', function () {
          handleClearArchive();
        });
      }
      if (archiveList.length) {
        archiveList.on('click', 'button[data-archive-action]', function () {
          const action = $(this).attr('data-archive-action');
          const id = $(this).attr('data-archive-id');
          if (action === 'load') {
            loadArchiveEntryById(id);
          } else if (action === 'delete') {
            handleDeleteArchiveEntry(id);
          }
        });
      }

      function handleGameSelection(game) {
        if (!game || !game.pgn) {
          showGameLoaderFeedback('Unable to load the selected game.', 'error');
          return;
        }
        closeGamePickerModal();
        $('#pgn-input').val(game.pgn).trigger('input');
        $('#pgn-input').focus();
        lastAnnotatedPgn = '';
        updateFormState('annotatedPgn', '');
        $('#stockfish-output').val('');
        updateFormState('stockfishOutput', '');
        const headers = parsePgnHeaders(game.pgn);
        setReviewPlayerColor(game && game.color ? game.color : null);
        if (getRawPlayerNameInput()) {
          updateReviewPlayerColorFromHeaders(headers, getPlayerName());
        }
        updatePlayerOutcomeFromHeaders(headers);
        lastEngineMoveRecords = null;
        automatedMoveInsights = { moves: [], summary: null, moveOfGame: null };
        automatedReviewText = '';
        const detailParts = [];
        if (game.colorLabel && game.colorLabel !== 'Unknown color') detailParts.push(game.colorLabel);
        if (game.resultLabel) detailParts.push(game.resultLabel);
        const detail = detailParts.length ? ` (${detailParts.join(' • ')})` : '';
        const opponent = game.opponent || 'opponent';
        const source = game.sourceLabel || 'Game';
        showGameLoaderFeedback(`Loaded ${source} game vs ${opponent}${detail}.`, 'success');
        lastFinalAnalysisText = '';
        currentReviewMetadata = null;
        updateArchiveControls();
      }

      async function handleGameLoad(source) {
        const button = source === 'chesscom' ? loadChessComBtn : loadLichessBtn;
        const defaultLabel = button && button.length ? (button.data('defaultLabel') || button.text().trim()) : '';
        const sourceLabel = source === 'chesscom' ? 'Chess.com' : 'Lichess';
        const usernameRaw = $('#player-name-input').val();
        const username = usernameRaw == null ? '' : String(usernameRaw).trim();
        if (!username) {
          showGameLoaderFeedback('Enter a username before loading games.', 'error');
          if ($('#player-name-input').length) $('#player-name-input').focus();
          return;
        }
        hideGameLoaderFeedback();
        if (button && button.length) {
          button.prop('disabled', true).text(`Loading ${sourceLabel}…`);
        }
        const requestToken = ++activeGameRequestToken;
        openGamePickerModal(sourceLabel, username);
        setGamePickerStatus(`Fetching recent ${sourceLabel} games for ${username}…`, 'info');
        clearGamePickerList();
        try {
          const loader = source === 'chesscom' ? fetchChessComGames : fetchLichessGames;
          const games = await loader(username);
          if (requestToken !== activeGameRequestToken) return;
          if (!games.length) {
            setGamePickerStatus(`No recent ${sourceLabel} games found for ${username}.`, 'info');
            return;
          }
          renderGamePickerList(games);
          setGamePickerStatus('Choose a game to load into the PGN field.', 'info');
        } catch (err) {
          if (requestToken !== activeGameRequestToken) return;
          console.error('Game fetch failed:', err);
          const message = err && err.message ? err.message : `Unable to load ${sourceLabel} games.`;
          setGamePickerStatus(message, 'error');
        } finally {
          if (button && button.length) {
            button.prop('disabled', false).text(defaultLabel || (source === 'chesscom' ? 'Browse Chess.com games' : 'Browse Lichess games'));
          }
        }
      }

      function showGameLoaderFeedback(message, tone) {
        if (!gameLoaderFeedback.length) return;
        const toneClass = tone === 'error' ? 'text-red-300' : tone === 'success' ? 'text-emerald-300' : 'text-sky-300';
        gameLoaderFeedback
          .removeClass('hidden text-red-300 text-emerald-300 text-sky-300 text-gray-300')
          .addClass(toneClass)
          .text(message);
      }

      function hideGameLoaderFeedback() {
        if (!gameLoaderFeedback.length) return;
        gameLoaderFeedback
          .addClass('hidden')
          .removeClass('text-red-300 text-emerald-300 text-sky-300 text-gray-300')
          .text('');
      }

      function openGamePickerModal(sourceLabel, username) {
        if (!gamePickerModal.length) return;
        gamePickerReturnFocus = document.activeElement;
        const titleParts = ['Select a game'];
        if (sourceLabel) titleParts[0] = `Select a ${sourceLabel} game`;
        if (username) titleParts.push(`for ${username}`);
        if (gamePickerTitle.length) gamePickerTitle.text(titleParts.join(' '));
        gamePickerModal.removeClass('hidden').attr('aria-hidden', 'false');
        if (closeGamePickerBtn.length) {
          setTimeout(() => { closeGamePickerBtn.trigger('focus'); }, 0);
        }
      }

      function closeGamePickerModal() {
        if (!gamePickerModal.length) return;
        activeGameRequestToken++;
        gamePickerModal.addClass('hidden').attr('aria-hidden', 'true');
        clearGamePickerList();
        setGamePickerStatus('', 'info');
        if (gamePickerReturnFocus && typeof gamePickerReturnFocus.focus === 'function') {
          try { gamePickerReturnFocus.focus(); } catch (err) { /* noop */ }
        }
        gamePickerReturnFocus = null;
      }

      function setGamePickerStatus(message, tone) {
        if (!gamePickerStatus.length) return;
        gamePickerStatus
          .removeClass('text-red-300 text-emerald-300 text-sky-300 text-gray-300 hidden')
          .addClass(message ? '' : 'hidden')
          .text(message || '');
        if (!message) return;
        const toneClass = tone === 'error' ? 'text-red-300' : tone === 'success' ? 'text-emerald-300' : tone === 'info' ? 'text-sky-300' : 'text-gray-300';
        gamePickerStatus.addClass(toneClass);
      }

      function clearGamePickerList() {
        if (!gamePickerList.length) return;
        gamePickerList.empty();
      }

      function renderGamePickerList(games) {
        if (!gamePickerList.length) return;
        clearGamePickerList();
        games.forEach((game, index) => {
          const item = $('<button type="button" class="w-full text-left bg-[#0b0e15] border border-[#1f2937] hover:bg-[#172033] rounded-lg p-3 focus:outline-none focus-visible:ring-2 focus-visible:ring-blue-500"></button>');
          item.data('game', game);
          const titleRow = $('<div class="flex items-center justify-between gap-2"></div>');
          const titleText = game.summary || `Game ${index + 1}`;
          $('<span class="font-semibold text-gray-100"></span>').text(titleText).appendTo(titleRow);
          const badgeText = game.resultCode ? game.resultCode : (game.resultLabel || '');
          if (badgeText) {
            $('<span class="text-xs font-semibold px-2 py-0.5 rounded bg-[#1f2937] text-gray-200"></span>').text(badgeText).appendTo(titleRow);
          }
          item.append(titleRow);
          const subtitleParts = [];
          if (game.sourceLabel) subtitleParts.push(game.sourceLabel);
          if (game.colorLabel && game.colorLabel !== 'Unknown color') subtitleParts.push(game.colorLabel);
          if (game.dateLabel) subtitleParts.push(game.dateLabel);
          if (subtitleParts.length) {
            $('<div class="mt-2 text-sm text-gray-300"></div>').text(subtitleParts.join(' • ')).appendTo(item);
          }
          const detailParts = [];
          if (game.eventLabel) detailParts.push(game.eventLabel);
          if (game.timeControlLabel) detailParts.push(game.timeControlLabel);
          if (game.siteLabel) detailParts.push(game.siteLabel);
          if (game.speedLabel) detailParts.push(game.speedLabel);
          if (game.ratingLabel) detailParts.push(game.ratingLabel);
          const detailLine = detailParts.join(' • ');
          if (detailLine) {
            $('<div class="mt-2 text-xs text-gray-400"></div>').text(detailLine).appendTo(item);
          }
          item.on('click', function () {
            const selected = $(this).data('game');
            handleGameSelection(selected);
          });
          gamePickerList.append(item);
        });
      }

      async function fetchChessComGames(username) {
        const normalized = String(username || '').trim();
        if (!normalized) return [];
        const lower = normalized.toLowerCase();
        const archivesUrl = `https://api.chess.com/pub/player/${encodeURIComponent(normalized)}/games/archives`;
        let archiveResponse;
        try {
          archiveResponse = await fetch(archivesUrl, { mode: 'cors' });
        } catch (err) {
          throw new Error('Unable to reach Chess.com. Check your connection and try again.');
        }
        if (!archiveResponse.ok) {
          if (archiveResponse.status === 404) {
            throw new Error(`Chess.com user "${normalized}" was not found.`);
          }
          throw new Error(`Chess.com request failed (status ${archiveResponse.status}).`);
        }
        let archiveJson;
        try {
          archiveJson = await archiveResponse.json();
        } catch (err) {
          throw new Error('Received an unexpected response from Chess.com.');
        }
        const archiveList = Array.isArray(archiveJson.archives) ? archiveJson.archives : [];
        if (!archiveList.length) return [];
        const archiveUrls = archiveList.slice(-3).reverse();
        const collected = [];
        for (const url of archiveUrls) {
          if (!url) continue;
          try {
            const resp = await fetch(url, { mode: 'cors' });
            if (!resp.ok) continue;
            const data = await resp.json();
            if (data && Array.isArray(data.games)) {
              data.games.forEach(game => collected.push(game));
            }
          } catch (err) {
            console.warn('Failed to load Chess.com archive', url, err);
          }
          if (collected.length >= 40) break;
        }
        const mapped = collected
          .map(game => mapChessComGame(game, normalized, lower))
          .filter(Boolean);
        mapped.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
        return mapped.slice(0, 30);
      }

      function mapChessComGame(game, username, usernameLower) {
        if (!game || !game.pgn) return null;
        const headers = parsePgnHeaders(game.pgn);
        const whiteNameRaw = headers.White || (game.white && game.white.username) || '';
        const blackNameRaw = headers.Black || (game.black && game.black.username) || '';
        const whiteName = whiteNameRaw ? String(whiteNameRaw).trim() : '';
        const blackName = blackNameRaw ? String(blackNameRaw).trim() : '';
        const whiteLower = whiteName.toLowerCase();
        const blackLower = blackName.toLowerCase();
        let color = null;
        if (whiteLower === usernameLower) {
          color = 'white';
        } else if (blackLower === usernameLower) {
          color = 'black';
        } else if (game.white && typeof game.white.username === 'string' && game.white.username.toLowerCase() === usernameLower) {
          color = 'white';
        } else if (game.black && typeof game.black.username === 'string' && game.black.username.toLowerCase() === usernameLower) {
          color = 'black';
        }
        const opponent = color === 'white'
          ? (blackName || (game.black && game.black.username) || 'Unknown opponent')
          : color === 'black'
            ? (whiteName || (game.white && game.white.username) || 'Unknown opponent')
            : (whiteName && blackName ? `${whiteName} vs ${blackName}` : 'Unknown opponent');
        const colorLabel = color === 'white' ? 'White' : color === 'black' ? 'Black' : 'Unknown color';
        const resultCodeRaw = headers.Result || '';
        const resultCode = String(resultCodeRaw).trim();
        const resultLabel = describeResult(resultCode);
        const timestamp = timestampFromHeaders(headers)
          || normalizeTimestamp(game.end_time)
          || normalizeTimestamp(game.start_time);
        const dateLabel = formatDateTime(timestamp);
        const timeControlLabel = formatTimeControl(headers.TimeControl);
        const eventLabel = headers.Event || '';
        let siteLabel = headers.Site || '';
        if (!siteLabel) {
          try {
            siteLabel = game.url ? new URL(game.url).hostname.replace(/^www\./, '') : 'Chess.com';
          } catch (err) {
            siteLabel = 'Chess.com';
          }
        }
        const ratingYou = color === 'white' ? getNumeric(game.white && game.white.rating) : color === 'black' ? getNumeric(game.black && game.black.rating) : null;
        const ratingOpp = color === 'white' ? getNumeric(game.black && game.black.rating) : color === 'black' ? getNumeric(game.white && game.white.rating) : null;
        const ratingParts = [];
        if (ratingYou != null) ratingParts.push(`You: ${ratingYou}`);
        if (ratingOpp != null) ratingParts.push(`Opp: ${ratingOpp}`);
        const ratingLabel = ratingParts.join(' • ');
        const summaryOpponent = opponent || 'opponent';
        const summary = color && color !== 'unknown'
          ? `${colorLabel} vs ${summaryOpponent}`
          : `${whiteName || 'White'} vs ${blackName || 'Black'}`;
        const resultCodeDisplay = resultCode && resultCode !== '*' ? resultCode : '';
        const idSource = game.url || game.uuid || `${timestamp || Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
        return {
          id: `chesscom-${idSource}`,
          source: 'chesscom',
          sourceLabel: 'Chess.com',
          pgn: game.pgn,
          color,
          colorLabel,
          opponent: summaryOpponent,
          resultCode: resultCodeDisplay,
          resultLabel,
          timestamp,
          dateLabel,
          eventLabel,
          siteLabel,
          timeControlLabel,
          ratingLabel,
          summary,
          speedLabel: ''
        };
      }

      async function fetchLichessGames(username) {
        const normalized = String(username || '').trim();
        if (!normalized) return [];
        const lower = normalized.toLowerCase();
        const params = new URLSearchParams({
          max: '20',
          pgnInJson: 'true',
          clocks: 'false',
          evals: 'false',
          opening: 'false'
        });
        const url = `https://lichess.org/api/games/user/${encodeURIComponent(normalized)}?${params.toString()}`;
        let response;
        try {
          response = await fetch(url, {
            headers: { 'Accept': 'application/x-ndjson' },
            mode: 'cors'
          });
        } catch (err) {
          throw new Error('Unable to reach Lichess. Check your connection and try again.');
        }
        if (!response.ok) {
          if (response.status === 404) {
            throw new Error(`Lichess user "${normalized}" was not found.`);
          }
          throw new Error(`Lichess request failed (status ${response.status}).`);
        }
        const payload = await response.text();
        if (!payload) return [];
        const lines = payload.split('\n');
        const mapped = [];
        for (const line of lines) {
          const trimmed = line.trim();
          if (!trimmed) continue;
          try {
            const data = JSON.parse(trimmed);
            if (data && data.pgn) {
              const mappedGame = mapLichessGame(data, normalized, lower);
              if (mappedGame) mapped.push(mappedGame);
            }
          } catch (err) {
            console.warn('Failed to parse Lichess game payload', err);
          }
          if (mapped.length >= 40) break;
        }
        mapped.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
        return mapped.slice(0, 30);
      }

      function mapLichessGame(game, username, usernameLower) {
        if (!game || !game.pgn) return null;
        const headers = parsePgnHeaders(game.pgn);
        const whiteNameRaw = headers.White || pickLichessName(game.players && game.players.white);
        const blackNameRaw = headers.Black || pickLichessName(game.players && game.players.black);
        const whiteName = whiteNameRaw ? String(whiteNameRaw).trim() : '';
        const blackName = blackNameRaw ? String(blackNameRaw).trim() : '';
        const whiteLower = whiteName.toLowerCase();
        const blackLower = blackName.toLowerCase();
        let color = null;
        if (whiteLower === usernameLower) {
          color = 'white';
        } else if (blackLower === usernameLower) {
          color = 'black';
        } else {
          const whiteFallback = pickLichessName(game.players && game.players.white).toLowerCase();
          const blackFallback = pickLichessName(game.players && game.players.black).toLowerCase();
          if (whiteFallback === usernameLower) {
            color = 'white';
          } else if (blackFallback === usernameLower) {
            color = 'black';
          }
        }
        const opponent = color === 'white'
          ? (blackName || pickLichessName(game.players && game.players.black) || 'Unknown opponent')
          : color === 'black'
            ? (whiteName || pickLichessName(game.players && game.players.white) || 'Unknown opponent')
            : (whiteName && blackName ? `${whiteName} vs ${blackName}` : 'Unknown opponent');
        const colorLabel = color === 'white' ? 'White' : color === 'black' ? 'Black' : 'Unknown color';
        let resultCode = (headers.Result || '').trim();
        if (!resultCode || resultCode === '*') {
          const winner = game.winner ? String(game.winner).toLowerCase() : '';
          if (winner === 'white') {
            resultCode = '1-0';
          } else if (winner === 'black') {
            resultCode = '0-1';
          } else if ((game.status || '').toLowerCase() === 'draw') {
            resultCode = '1/2-1/2';
          }
        }
        const resultLabel = describeResult(resultCode);
        const timestamp = timestampFromHeaders(headers)
          || normalizeTimestamp(game.lastMoveAt)
          || normalizeTimestamp(game.createdAt);
        const dateLabel = formatDateTime(timestamp);
        const eventLabel = headers.Event || game.event || '';
        const siteLabel = headers.Site || 'Lichess';
        let timeControlLabel = formatTimeControl(headers.TimeControl);
        if (!timeControlLabel && game.clock && Number.isFinite(Number(game.clock.initial)) && Number.isFinite(Number(game.clock.increment))) {
          timeControlLabel = formatTimeControl(`${game.clock.initial}+${game.clock.increment}`);
        }
        const ratingWhite = game.players && game.players.white ? getNumeric(game.players.white.rating) : null;
        const ratingBlack = game.players && game.players.black ? getNumeric(game.players.black.rating) : null;
        const ratingYou = color === 'white' ? ratingWhite : color === 'black' ? ratingBlack : null;
        const ratingOpp = color === 'white' ? ratingBlack : color === 'black' ? ratingWhite : null;
        const ratingParts = [];
        if (ratingYou != null) ratingParts.push(`You: ${ratingYou}`);
        if (ratingOpp != null) ratingParts.push(`Opp: ${ratingOpp}`);
        const ratingLabel = ratingParts.join(' • ');
        const speedLabel = buildSpeedLabel(game.speed, game.perf, game.variant);
        const summaryOpponent = opponent || 'opponent';
        const summary = color && color !== 'unknown'
          ? `${colorLabel} vs ${summaryOpponent}`
          : `${whiteName || 'White'} vs ${blackName || 'Black'}`;
        const resultCodeDisplay = resultCode && resultCode !== '*' ? resultCode : '';
        const idSource = game.id || game.url || `${timestamp || Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
        return {
          id: `lichess-${idSource}`,
          source: 'lichess',
          sourceLabel: 'Lichess',
          pgn: game.pgn,
          color,
          colorLabel,
          opponent: summaryOpponent,
          resultCode: resultCodeDisplay,
          resultLabel,
          timestamp,
          dateLabel,
          eventLabel,
          siteLabel,
          timeControlLabel,
          ratingLabel,
          summary,
          speedLabel
        };
      }

      function parsePgnHeaders(pgn) {
        const headers = {};
        if (!pgn) return headers;
        const headerRegex = /\[(\w+)\s+"([^"]*)"\]/g;
        let match;
        while ((match = headerRegex.exec(pgn)) !== null) {
          headers[match[1]] = match[2];
        }
        return headers;
      }

      function normalizeTimestamp(value) {
        if (value == null) return null;
        const numeric = Number(value);
        if (!Number.isFinite(numeric) || numeric <= 0) return null;
        if (numeric < 1e11) {
          return numeric * 1000;
        }
        return numeric;
      }

      function timestampFromHeaders(headers) {
        if (!headers) return null;
        const dateRaw = headers.UTCDate || headers.Date;
        if (!dateRaw) return null;
        const dateMatch = String(dateRaw).match(/^\s*(\d{4})[.\-](\d{2})[.\-](\d{2})\s*$/);
        if (!dateMatch) return null;
        const sanitizedDate = `${dateMatch[1]}-${dateMatch[2]}-${dateMatch[3]}`;
        const timeRaw = headers.UTCTime || headers.Time;
        const sanitizedTime = normalizeTimeComponent(timeRaw);
        const isoCandidate = `${sanitizedDate}T${sanitizedTime}`;
        const withZone = headers.UTCDate || headers.UTCTime ? `${isoCandidate}Z` : isoCandidate;
        const parsed = Date.parse(withZone);
        return Number.isFinite(parsed) ? parsed : null;
      }

      function normalizeTimeComponent(value) {
        if (!value) return '00:00:00';
        const str = String(value).trim();
        const match = str.match(/^(\d{1,2})(?::(\d{1,2}))?(?::(\d{1,2}))?$/);
        if (!match) return '00:00:00';
        const hours = match[1].padStart(2, '0');
        const minutes = (match[2] || '0').padStart(2, '0');
        const seconds = (match[3] || '0').padStart(2, '0');
        return `${hours}:${minutes}:${seconds}`;
      }

      function formatDateTime(timestamp) {
        if (!timestamp) return '';
        try {
          const date = new Date(timestamp);
          if (Number.isNaN(date.getTime())) return '';
          return new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' }).format(date);
        } catch (err) {
          return '';
        }
      }

      function formatTimeControl(value) {
        if (!value) return '';
        const normalized = String(value).trim();
        if (!normalized || normalized === '-' || normalized === '?') return '';
        if (normalized.includes('+')) {
          const [baseStr, incStr] = normalized.split('+');
          const base = Number(baseStr);
          const increment = Number(incStr);
          if (Number.isFinite(base) && Number.isFinite(increment)) {
            const baseDisplay = base >= 60 && base % 60 === 0
              ? `${base / 60}`
              : `${base}s`;
            return `TC ${baseDisplay}+${increment}`;
          }
        }
        return `TC ${normalized}`;
      }

      function describeResult(resultCode) {
        const normalized = (resultCode || '').trim();
        if (!normalized || normalized === '*') return 'In progress';
        if (normalized === '1-0') return 'White won (1-0)';
        if (normalized === '0-1') return 'Black won (0-1)';
        if (normalized === '1/2-1/2') return 'Draw (½-½)';
        return normalized;
      }

      function getNumeric(value) {
        const numeric = Number(value);
        return Number.isFinite(numeric) ? numeric : null;
      }

      function pickLichessName(player) {
        if (!player) return '';
        if (player.user && player.user.name) return String(player.user.name);
        if (player.userId) return String(player.userId);
        if (player.name) return String(player.name);
        if (player.aiLevel != null) return `Stockfish L${player.aiLevel}`;
        return '';
      }

      function buildSpeedLabel(speed, perf, variant) {
        const parts = [];
        if (speed) parts.push(capitalizeFirst(speed));
        if (variant && variant !== 'standard') parts.push(capitalizeFirst(variant));
        if (perf && perf !== speed && perf !== variant) parts.push(capitalizeFirst(perf));
        return parts.join(' • ');
      }

      function capitalizeFirst(value) {
        const str = String(value || '').trim();
        if (!str) return '';
        return str.charAt(0).toUpperCase() + str.slice(1);
      }


      // ====== Stockfish (same-origin Worker) ======
      const ENGINE_BUNDLE_VERSION = '20240609';
      const LOCAL_ENGINE = `engine/stockfish-nnue-16-single.js?v=${ENGINE_BUNDLE_VERSION}`;
      function resolveWorkerUrl(path) {
        if (!path) return path;
        try {
          const normalized = String(path);
          if (/^(?:[a-z]+:)?\/\//i.test(normalized) || normalized.startsWith('blob:') || normalized.startsWith('data:')) {
            return normalized;
          }
          if (typeof window === 'undefined' || !window.location) {
            return normalized;
          }
          const { origin, pathname } = window.location;
          let base = origin || '';
          if (pathname && typeof pathname === 'string') {
            const dir = pathname.replace(/[^/]*$/, '');
            base = base + dir;
          }
          if (!base) return normalized;
          return new URL(normalized, base).toString();
        } catch (err) {
          console.warn('Falling back to raw worker path due to resolution error:', err);
          return path;
        }
      }
        const ENGINE_GO_OPTIONS = { depth: 24 };
        let engineWorker = null;
        let engineReady = false;
        let engineInitTimeout = null;
        let lastInfoMsg = '';
        let currentScoreResolver = null;
        let showBestMove = false;
        const toggleBestBtn = $('#toggle-eval-btn');
        const defaultBestButtonLabel = toggleBestBtn.length ? (toggleBestBtn.text().trim() || 'Analyze') : 'Analyze';
        let bestMoveSquares = null;
        let arrowCanvas = null;
        let arrowCtx = null;
        let lastBestMove = null;
        let bestMoveAnalysisToken = 0;
        let bestMoveActiveToken = 0;
        let bestMoveUpdateTimeout = null;
        let pendingBestMoveInfo = null;
        let lastBestMoveUpdate = 0;
        let bestMoveFen = null;
        let bestMoveFenNormalized = null;
        let pendingBestMoveVisualData = null;
        let bestMoveVisualRetryHandle = null;
        let bestMoveResponseTimeoutHandle = null;
        let bestMoveStallTimeoutHandle = null;
        const BEST_MOVE_UPDATE_INTERVAL = 250;
        const BEST_MOVE_VISUAL_RETRY_DELAY = 50;
        const BEST_MOVE_VISUAL_RETRY_LIMIT = 20;
        const BEST_MOVE_RESPONSE_TIMEOUT = 2500;
        const BEST_MOVE_STALL_TIMEOUT = 9000;

      function configureEngineOptions() {
        if (!engineWorker) return;
        engineReady = false;
        $('#analyze-pgn-btn').prop('disabled', true);
        const depthVal = sanitizeEngineSetting('depth', $('#depth-input').val());
        const threadVal = sanitizeEngineSetting('threads', $('#threads-input').val());
        const hashVal = sanitizeEngineSetting('hash', $('#hash-input').val());
        $('#depth-input').val(depthVal);
        $('#threads-input').val(threadVal);
        $('#hash-input').val(hashVal);
        ENGINE_GO_OPTIONS.depth = depthVal;
        const options = { Threads: threadVal, Hash: hashVal };
        Object.entries(options).forEach(([name, value]) => {
          engineWorker.postMessage(`setoption name ${name} value ${value}`);
        });
        engineWorker.postMessage('isready');
      }

      function showEngineStatus(opts) {
        if (!engineStatusBanner.length) return;
        const tone = opts && opts.tone ? String(opts.tone) : 'info';
        const message = opts && opts.message ? String(opts.message) : '';
        const detail = opts && opts.detail ? String(opts.detail) : '';
        const showRetry = !!(opts && opts.showRetry);
        engineStatusBanner
          .removeClass('status-info status-error status-visible')
          .addClass('status-visible')
          .addClass(tone === 'error' ? 'status-error' : 'status-info');
        if (engineStatusMessage.length) engineStatusMessage.text(message);
        if (engineStatusDetail.length) {
          if (detail) {
            engineStatusDetail.text(detail).removeClass('hidden');
          } else {
            engineStatusDetail.text('').addClass('hidden');
          }
        }
        if (retryEngineBtn.length) {
          if (showRetry) {
            retryEngineBtn.removeClass('hidden').prop('disabled', false);
          } else {
            retryEngineBtn.addClass('hidden');
          }
        }
      }

      function hideEngineStatus() {
        if (!engineStatusBanner.length) return;
        engineStatusBanner.removeClass('status-visible status-info status-error');
        if (engineStatusMessage.length) engineStatusMessage.text('');
        if (engineStatusDetail.length) engineStatusDetail.text('').addClass('hidden');
        if (retryEngineBtn.length) retryEngineBtn.addClass('hidden');
      }

      function handleEngineLoadFailure(detailMessage) {
        engineReady = false;
        $('#analyze-pgn-btn').prop('disabled', true).text('Engine Load Error');
        showEngineStatus({
          tone: 'error',
          message: 'Stockfish engine failed to load.',
          detail: detailMessage || 'Please retry or continue without engine analysis.',
          showRetry: true
        });
      }

      function initEngine(initial = false) {
        if (engineWorker) engineWorker.terminate();
        engineReady = false;
        if (initial) {
          $('#analyze-pgn-btn').prop('disabled', true).text('Loading Engine...');
        } else {
          $('#analyze-pgn-btn').prop('disabled', true);
        }
        showEngineStatus({
          tone: 'info',
          message: 'Loading Stockfish engine…',
          detail: 'This can take a few seconds on mobile devices.'
        });
        try {
          engineWorker = new Worker(resolveWorkerUrl(LOCAL_ENGINE));
        } catch (err) {
          console.error('Engine load error', err);
          handleEngineLoadFailure(err && err.message ? err.message : 'Worker could not be created.');
          return;
        }
        engineWorker.onerror = function (err) {
          console.error('Engine load error', err);
          handleEngineLoadFailure('Worker reported an error during initialization.');
        };
        engineWorker.onmessage = function (e) {
          const rawMsg = String(e.data || '');
          const msg = rawMsg.trim();
          if (msg === 'uciok') {
            configureEngineOptions();
          } else if (msg === 'readyok') {
            engineReady = true;
            clearTimeout(engineInitTimeout);
            $('#analyze-pgn-btn').prop('disabled', false).text('Analyze');
            hideEngineStatus();
          } else if (msg.startsWith('info')) {
            handleEngineInfoMessage(rawMsg);
          } else if (msg.startsWith('bestmove')) {
            const cp = /score cp (-?\d+)/.exec(lastInfoMsg);
            const mt = /score mate (-?\d+)/.exec(lastInfoMsg);
            const bmMatch = /bestmove\s(\S+)/.exec(msg);
            const bm = bmMatch ? bmMatch[1] : null;
            if (currentScoreResolver) {
              if (mt) {
                currentScoreResolver({ type: 'mate', value: parseInt(mt[1], 10), bestmove: bm });
              } else if (cp) {
                currentScoreResolver({ type: 'cp', value: parseInt(cp[1], 10), bestmove: bm });
              } else {
                currentScoreResolver({ type: 'cp', value: 0, bestmove: bm });
              }
              currentScoreResolver = null;
            }
          }
        };
        engineWorker.postMessage('uci');
        engineInitTimeout = setTimeout(() => {
          if (!engineReady) {
            engineWorker.terminate();
            handleEngineLoadFailure('Initialization timed out.');
          }
        }, 20000);
      }

      if (retryEngineBtn.length) {
        retryEngineBtn.on('click', function(){
          $(this).prop('disabled', true);
          initEngine(true);
        });
      }

      $('#depth-input, #threads-input, #hash-input').on('change', function(){ initEngine(); });

      initEngine(true);

      // Prompt (adds one-line Summary at the end)
      const ANALYSIS_PROMPT_TEMPLATE = `You are given:
The player being coached is eugenime.
1) A PGN with SAN moves and mover-centric deltas {…}.
2) An “Automated Insights” block listing each half-move with its FINAL classification (Book, Good, Forced, Inaccuracy, Mistake, Blunder, Misclick??, Great, Brilliant).
3) Precomputed Summary counts, Accuracy, Move of the game.
Do NOT change any classification or counts.

TASK
- Output exactly ONE line per half-move in this format:
  <move> - {<eval>} <classification>: <comment>
- Show ALL moves with their provided classification.
- At the end, output:
  Summary: Brilliant = X | Great = Y | Mistakes = Z | Blunders = W | Misclicks = V
  Accuracy: <Accuracy percentage>
  Narrative Summary: One-sentence overview of the game of the player being coached.
  Move of the game: <move> - {<eval>} <classification>: <one-sentence why it’s most impactful>

COMMENTING RULES
- You are addressing the player being coached.
- Comment every move.
- Keep comments SHORT (1–2 sentences), purely from SAN and obvious consequences:
  • checks (+/#), captures (what piece is taken if SAN makes it clear), promotions (=Q/R/B/N), castling.
  • immediate positional effects: “opens the e-file,” “weakens king safety,” “creates/advances a passed pawn,” “wins a rook/queen,” “keeps the attack,” “drives the king,” “loses coordination,” “concedes dark squares.”
- Do NOT include numeric evaluations or hidden engine lines.
- Do NOT re-evaluate or contradict any mate token in the eval:
  • {#N} = White has mate in N; {#-N} = Black has mate in N. You may say “starts/continues a forced mate” when such tokens appear or are flagged by the input’s insights.
- Do NOT change the provided classification. If the input marks a move as Great/Brilliant, explain why in positional terms (e.g., wins a rook/queen; keeps the mating attack; visible sacrifice that maintains the attack). If marked Mistake/Blunder/Misclick??, explain how it worsens the position (e.g., walks into checks; drops a piece; opens king; loses a passer).

DISCIPLINE
- Toggle movers correctly and use SAN exactly as given.
- Use the provided {eval} token exactly as given.
- No extra prose before or after the required sections.
- Be consistent and terse to minimize compute.

INPUT FORMAT (example)
<PGN headers and moves with deltas>
=== Automated Insights ===
<one line per half-move with FINAL classification>
Summary: Brilliant = X | Great = Y | Mistakes = Z | Blunders = W | Misclicks = V
Accuracy: <Accuracy percentage>
Move of the game: <move> - {<eval>} <classification>: <reason>

OUTPUT FORMAT (strict)
<move> - {<eval>} <classification>: <comment>
...
Summary: Brilliant = X | Great = Y | Mistakes = Z | Blunders = W | Misclicks = V
Accuracy: <Accuracy percentage>
Narrative Summary: <one sentence>
Move of the game: <move> - {<eval>} <classification>: <one sentence why>`;

      function getPlayerName() {
        const raw = $('#player-name-input').val();
        const trimmed = raw == null ? '' : String(raw).trim();
        return trimmed || DEFAULT_PLAYER_NAME;
      }

      function getRawPlayerNameInput() {
        const el = $('#player-name-input');
        if (!el.length) return '';
        const raw = el.val();
        return raw == null ? '' : String(raw).trim();
      }

      function normalizePlayerHandle(value) {
        if (value == null) return '';
        let normalized = String(value).trim();
        if (!normalized) return '';
        normalized = normalized.replace(/^@+/, '');
        normalized = normalized.replace(/\s*\([^)]*\)\s*$/, '');
        normalized = normalized.replace(/\s+/g, ' ');
        return normalized.toLowerCase();
      }

      function setReviewPlayerColor(color) {
        if (color === 'w' || color === 'b') {
          reviewPlayerColor = color;
          return reviewPlayerColor;
        }
        if (color === 'white') {
          reviewPlayerColor = 'w';
          return reviewPlayerColor;
        }
        if (color === 'black') {
          reviewPlayerColor = 'b';
          return reviewPlayerColor;
        }
        reviewPlayerColor = null;
        return reviewPlayerColor;
      }

      function determinePlayerColorFromHeaders(headers, playerName) {
        if (!headers) return null;
        const target = normalizePlayerHandle(playerName);
        if (!target) return null;
        const white = normalizePlayerHandle(headers.White);
        const black = normalizePlayerHandle(headers.Black);
        if (white && white === target) return 'w';
        if (black && black === target) return 'b';
        return null;
      }

      function updateReviewPlayerColorFromHeaders(headers, playerName) {
        const detected = determinePlayerColorFromHeaders(headers, playerName);
        if (detected) return setReviewPlayerColor(detected);
        return setReviewPlayerColor(null);
      }

      function updateReviewPlayerColorFromGame(chess, playerName) {
        if (!chess || typeof chess.header !== 'function') {
          return setReviewPlayerColor(null);
        }
        const headers = chess.header();
        return updateReviewPlayerColorFromHeaders(headers, playerName);
      }

      function normalizeResultCodeForOutcome(code) {
        if (code == null) return '';
        let normalized = String(code).trim();
        if (!normalized) return '';
        normalized = normalized.replace(/½/g, '1/2');
        normalized = normalized.replace(/\s+/g, '');
        return normalized.toLowerCase();
      }

      function derivePlayerOutcome(resultCode, playerColor) {
        if (playerColor !== 'w' && playerColor !== 'b') return null;
        const normalized = normalizeResultCodeForOutcome(resultCode);
        if (!normalized || normalized === '*') return null;
        if (normalized.startsWith('1-0')) {
          return playerColor === 'w' ? 'win' : 'loss';
        }
        if (normalized.startsWith('0-1')) {
          return playerColor === 'b' ? 'win' : 'loss';
        }
        if (normalized.startsWith('1/2-1/2') || normalized.startsWith('0.5-0.5')) {
          return 'draw';
        }
        return null;
      }

      function updatePlayerOutcomeFromHeaders(headers) {
        const resultCode = headers && headers.Result ? headers.Result : '';
        playerGameOutcome = derivePlayerOutcome(resultCode, reviewPlayerColor);
        return playerGameOutcome;
      }

      function updatePlayerOutcomeFromGame(chess) {
        if (!chess || typeof chess.header !== 'function') {
          playerGameOutcome = null;
          return playerGameOutcome;
        }
        const headers = chess.header();
        return updatePlayerOutcomeFromHeaders(headers);
      }

      function buildAnalysisPrompt(playerName) {
        const target = (playerName == null ? '' : String(playerName)).trim() || DEFAULT_PLAYER_NAME;
        return ANALYSIS_PROMPT_TEMPLATE.replace(/eugenime/gi, target);
      }

      function waitForEngineReady() {
        return new Promise(resolve => {
          if (engineReady) { resolve(); return; }
          const interval = setInterval(() => {
            if (engineReady) {
              clearInterval(interval);
              resolve();
            }
          }, 50);
        });
      }

      const classificationStyles = {
        brilliant: 'text-cyan-300',
        great: 'text-teal-300',
        good: 'text-green-400',
        book: 'text-blue-400',
        forced: 'text-gray-400',
        inaccuracy: 'text-yellow-400',
        mistake: 'text-orange-400',
        blunder: 'text-red-500',
        misclick: 'text-fuchsia-500',
        default: ''
      };
      const classificationMarkerColors = {
        brilliant: '#67e8f9',
        great: '#5eead4',
        blunder: '#ef4444',
        misclick: '#d946ef'
      };
      const highlightedGraphClassifications = new Set(['brilliant', 'great', 'blunder', 'misclick']);
      function normalizeClassificationKey(c) {
        return (c || '')
          .toLowerCase()
          .replace(/[\s!?]/g, '');
      }
      function getStyleForClassification(c) {
        return classificationStyles[normalizeClassificationKey(c)] || classificationStyles['default'];
      }
      const CLASSIFICATION_CANONICAL = {
        brilliant: 'Brilliant',
        great: 'Great',
        good: 'Good',
        book: 'Book',
        forced: 'Forced',
        inaccuracy: 'Inaccuracy',
        mistake: 'Mistake',
        blunder: 'Blunder',
        misclick: 'Misclick??'
      };
      const CLASSIFICATION_SEVERITY = {
        misclick: 5,
        blunder: 4,
        mistake: 3,
        inaccuracy: 2,
        forced: 1,
        good: 1,
        book: 1,
        great: 0,
        brilliant: 0
      };
      const SACRIFICE_PIECE_VALUES = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };
      const PREVIOUS_ERROR_KEYS = new Set(['mistake', 'blunder', 'misclick']);
      const MOVE_OF_GAME_TARGET_KEYS = new Set(['brilliant', 'great', 'blunder', 'misclick']);
      let automatedMoveInsights = { moves: [], summary: null, moveOfGame: null };
      let automatedReviewText = '';

      function canonicalizeClassification(value) {
        const key = normalizeClassificationKey(value);
        return CLASSIFICATION_CANONICAL[key] || (value || '');
      }

      function simplifyMoveObject(moveObj) {
        if (!moveObj) return null;
        return {
          san: moveObj.san,
          from: moveObj.from,
          to: moveObj.to,
          piece: moveObj.piece,
          captured: moveObj.captured || null,
          promotion: moveObj.promotion || null,
          color: moveObj.color,
          flags: moveObj.flags || ''
        };
      }

      function chooseMoreSevereClassification(current, target) {
        const currentKey = normalizeClassificationKey(current);
        const targetKey = normalizeClassificationKey(target);
        const currentRank = CLASSIFICATION_SEVERITY[currentKey] ?? -Infinity;
        const targetRank = CLASSIFICATION_SEVERITY[targetKey] ?? -Infinity;
        if (targetRank > currentRank) {
          return CLASSIFICATION_CANONICAL[targetKey] || canonicalizeClassification(target);
        }
        return canonicalizeClassification(current);
      }

      function computeBaseClassification(delta, plyIndex) {
        if (!Number.isFinite(delta)) return plyIndex < 7 ? 'Book' : 'Good';
        if (delta >= -2) return plyIndex < 7 ? 'Book' : 'Good';
        if (delta >= -9) return 'Inaccuracy';
        if (delta >= -20) return 'Mistake';
        if (delta >= -49) return 'Blunder';
        return 'Misclick??';
      }

      function isLikelySacrificeMove(moveRecord) {
        if (!moveRecord || !moveRecord.move) return false;
        const move = moveRecord.move;
        const piece = move.piece;
        if (!piece || piece === 'p' || piece === 'k') return false;
        const captured = move.captured;
        if (!captured) return false;
        const moverValue = SACRIFICE_PIECE_VALUES[piece] || 0;
        const capturedValue = SACRIFICE_PIECE_VALUES[captured] || 0;
        return moverValue >= capturedValue + 3;
      }

      function hadMateForMoverBefore(moveRecord) {
        if (!moveRecord) return false;
        const mateBefore = moveRecord.mateBefore;
        if (!Number.isFinite(mateBefore)) return false;
        if (moveRecord.color === 'w') return mateBefore > 0;
        return mateBefore < 0;
      }

      function retainsMateForMover(moveRecord) {
        if (!moveRecord) return false;
        const mateAfter = moveRecord.mateAfter;
        if (!Number.isFinite(mateAfter)) return false;
        if (moveRecord.color === 'w') return mateAfter > 0;
        return mateAfter < 0;
      }

      function opponentHasForcedMateAfter(moveRecord) {
        if (!moveRecord) return false;
        const mateAfter = moveRecord.mateAfter;
        if (!Number.isFinite(mateAfter)) return false;
        if (moveRecord.color === 'w') return mateAfter < 0;
        return mateAfter > 0;
      }

      function computeImpactScore(moveRecord) {
        if (!moveRecord) return -Infinity;
        let score = Math.abs(Number(moveRecord.moverDelta || 0));
        if (!Number.isFinite(score)) score = 0;
        if (opponentHasForcedMateAfter(moveRecord)) {
          score = Math.max(score, 950 - Math.min(100, Math.abs(moveRecord.mateAfter || 0)));
        }
        if (hadMateForMoverBefore(moveRecord) && !retainsMateForMover(moveRecord)) {
          score = Math.max(score, 940);
        }
        if (retainsMateForMover(moveRecord)) {
          score = Math.max(score, 960 - Math.min(100, Math.abs(moveRecord.mateAfter || 0)));
        }
        return score;
      }

      function computeAutomatedMoveInsights(rawMoves, playerColor, playerOutcome) {
        if (!Array.isArray(rawMoves) || !rawMoves.length) {
          return { moves: [], summary: null, moveOfGame: null };
        }

        const moves = rawMoves.map((mv, idx) => ({
          ...mv,
          index: idx,
          classification: computeBaseClassification(mv.moverDelta, idx)
        }));

        moves.forEach((mv, idx) => {
          const needsSevere = opponentHasForcedMateAfter(mv) || (hadMateForMoverBefore(mv) && !retainsMateForMover(mv));
          if (needsSevere) {
            const severeTarget = Number.isFinite(mv.moverDelta) && mv.moverDelta <= -50 ? 'Misclick??' : 'Blunder';
            mv.classification = chooseMoreSevereClassification(mv.classification, severeTarget);
          }
        });

        moves.forEach((mv, idx) => {
          if (!Number.isFinite(mv.moverDelta) || mv.moverDelta < 0) return;
          const prev = moves[idx - 1];
          if (!prev) return;
          const prevKey = normalizeClassificationKey(prev.classification);
          if (!PREVIOUS_ERROR_KEYS.has(prevKey)) return;
          mv.classification = isLikelySacrificeMove(mv) ? 'Brilliant' : 'Great';
        });

        const summaryCounts = {};
        Object.values(CLASSIFICATION_CANONICAL).forEach(name => { summaryCounts[name] = 0; });
        moves.forEach(mv => {
          const name = canonicalizeClassification(mv.classification);
          mv.classification = name;
          if (summaryCounts[name] == null) summaryCounts[name] = 0;
        });

        const normalizedColor = playerColor === 'w' || playerColor === 'b'
          ? playerColor
          : playerColor === 'white'
            ? 'w'
            : playerColor === 'black'
              ? 'b'
              : null;
        const normalizedOutcome = playerOutcome === 'win' || playerOutcome === 'loss' || playerOutcome === 'draw'
          ? playerOutcome
          : null;
        const relevantMoves = normalizedColor ? moves.filter(mv => mv.color === normalizedColor) : moves;
        relevantMoves.forEach(mv => {
          if (summaryCounts[mv.classification] == null) summaryCounts[mv.classification] = 0;
          summaryCounts[mv.classification] += 1;
        });

        const totalMoves = relevantMoves.length;
        const totalGood = (summaryCounts['Brilliant'] || 0) + (summaryCounts['Great'] || 0) + (summaryCounts['Good'] || 0) + (summaryCounts['Book'] || 0) + (summaryCounts['Forced'] || 0);
        const totalBad = (summaryCounts['Mistake'] || 0) + (summaryCounts['Blunder'] || 0) + (summaryCounts['Misclick??'] || 0);
        const accuracy = totalMoves ? (totalGood / totalMoves) * 100 : 0;

        let largestDrop = null;
        let bestNonNegative = null;
        relevantMoves.forEach(mv => {
          const delta = Number(mv.moverDelta);
          if (!Number.isFinite(delta)) return;
          if (delta < 0) {
            if (!largestDrop || delta < Number(largestDrop.moverDelta) || (delta === Number(largestDrop.moverDelta) && mv.index < largestDrop.index)) {
              largestDrop = mv;
            }
          } else {
            if (!bestNonNegative || delta > Number(bestNonNegative.moverDelta) || (delta === Number(bestNonNegative.moverDelta) && mv.index < bestNonNegative.index)) {
              bestNonNegative = mv;
            }
          }
        });

        let moveOfGame = null;
        const opponentColor = normalizedColor === 'w' ? 'b' : normalizedColor === 'b' ? 'w' : null;
        const strongReplyClasses = new Set(['Good', 'Great', 'Brilliant']);
        const highlightFollowupClasses = new Set(['Brilliant', 'Great', 'Good']);
        const opponentErrorClasses = new Set(['Blunder', 'Misclick??', 'Inaccuracy']);

        if (normalizedColor && normalizedOutcome === 'loss' && opponentColor) {
          let targetedLossMove = null;
          moves.forEach((mv, idx) => {
            if (mv.color !== normalizedColor) return;
            const delta = Number(mv.moverDelta);
            if (!Number.isFinite(delta) || delta >= 0) return;
            const reply = moves[idx + 1];
            if (!reply || reply.color !== opponentColor) return;
            if (!strongReplyClasses.has(reply.classification)) return;
            if (!targetedLossMove || delta < Number(targetedLossMove.moverDelta) || (delta === Number(targetedLossMove.moverDelta) && idx < targetedLossMove.index)) {
              targetedLossMove = mv;
            }
          });
          if (targetedLossMove) {
            targetedLossMove.moveOfGameContext = 'loss-critical';
            moveOfGame = targetedLossMove;
          }
        } else if (normalizedColor && normalizedOutcome === 'win' && opponentColor) {
          let bestPunishingFollow = null;
          let bestRelatedMistake = null;
          moves.forEach((mv, idx) => {
            if (mv.color !== opponentColor) return;
            if (!opponentErrorClasses.has(mv.classification)) return;
            const delta = Number(mv.moverDelta);
            if (!Number.isFinite(delta)) return;
            const follow = moves[idx + 1];
            if (!follow || follow.color !== normalizedColor) return;
            if (!highlightFollowupClasses.has(follow.classification)) return;
            const currentBestDelta = bestRelatedMistake ? Number(bestRelatedMistake.moverDelta) : null;
            if (
              !bestPunishingFollow
              || currentBestDelta == null
              || delta < currentBestDelta
              || (delta === currentBestDelta && idx < bestRelatedMistake.index)
            ) {
              bestPunishingFollow = follow;
              bestRelatedMistake = mv;
            }
          });
          if (bestPunishingFollow && bestRelatedMistake) {
            bestPunishingFollow.moveOfGameContext = 'win-conversion';
            bestPunishingFollow.relatedMistakeIndex = bestRelatedMistake.index;
            moveOfGame = bestPunishingFollow;
          }
        }

        if (!moveOfGame) {
          if (largestDrop) moveOfGame = largestDrop;
          else if (bestNonNegative) moveOfGame = bestNonNegative;
        }

        return {
          moves,
          summary: {
            counts: summaryCounts,
            totalMoves,
            totalGood,
            totalBad,
            accuracy,
            playerColor: normalizedColor
          },
          moveOfGame
        };
      }

      function describeAutomatedImpact(delta) {
        const swing = Math.abs(Number(delta || 0));
        if (!Number.isFinite(swing)) return 'severe';
        if (swing >= 60) return 'devastating';
        if (swing >= 40) return 'huge';
        if (swing >= 25) return 'major';
        return 'costly';
      }

      function buildAutomatedComment(move) {
        if (!move) return '';
        const key = normalizeClassificationKey(move.classification);
        if (key === 'brilliant') {
          if (retainsMateForMover(move)) {
            return 'Auto insight: keeps the forced mate alive.';
          }
          if (isLikelySacrificeMove(move)) {
            return 'Auto insight: engine-backed sacrifice keeps the initiative.';
          }
          return 'Auto insight: Stockfish approves this tactic to extend the attack.';
        }
        if (key === 'great') {
          if (retainsMateForMover(move)) {
            return 'Auto insight: preserves the forced mate the engine spotted.';
          }
          if (Number.isFinite(move.moverDelta) && move.moverDelta > 0) {
            return 'Auto insight: extends the advantage according to Stockfish.';
          }
          return 'Auto insight: flagged as the only move that keeps control.';
        }
        if (key === 'blunder') {
          if (opponentHasForcedMateAfter(move)) {
            return 'Auto insight: allows a forced mate per Stockfish.';
          }
          return `Auto insight: ${describeAutomatedImpact(move.moverDelta)} drop flagged by Stockfish.`;
        }
        if (key === 'misclick') {
          if (opponentHasForcedMateAfter(move)) {
            return 'Auto insight: hands the opponent a forced mate.';
          }
          return `Auto insight: ${describeAutomatedImpact(move.moverDelta)} collapse detected by Stockfish.`;
        }
        return '';
      }

      function buildAutomatedMoveOfGameComment(move) {
        if (!move) return '';
        const key = normalizeClassificationKey(move.classification);
        const context = move.moveOfGameContext || '';
        if (context === 'win-conversion' && (key === 'brilliant' || key === 'great' || key === 'good')) {
          return 'Auto insight: capitalizes on the opponent\'s slip to convert the game.';
        }
        if (context === 'loss-critical' && (key === 'mistake' || key === 'blunder' || key === 'misclick' || key === 'inaccuracy')) {
          return 'Auto insight: decisive error that the opponent punished with precise play.';
        }
        if (key === 'brilliant' || key === 'great') {
          if (retainsMateForMover(move)) {
            return 'Auto insight: decisive tactic that keeps the mate on the board.';
          }
          return 'Auto insight: engine-marked turning point that secured the advantage.';
        }
        if (key === 'mistake') {
          if (opponentHasForcedMateAfter(move)) {
            return 'Auto insight: error that hands the opponent a forcing sequence.';
          }
          return `Auto insight: ${describeAutomatedImpact(move.moverDelta)} mistake that swung the evaluation.`;
        }
        if (key === 'inaccuracy') {
          return `Auto insight: ${describeAutomatedImpact(move.moverDelta)} slip highlighted by Stockfish.`;
        }
        if (key === 'blunder' || key === 'misclick') {
          if (opponentHasForcedMateAfter(move)) {
            return 'Auto insight: pivotal mistake that yields a forced mate.';
          }
          return 'Auto insight: largest collapse in evaluation during the game.';
        }
        if (key === 'good' || key === 'book' || key === 'forced') {
          if (Number.isFinite(move.moverDelta) && move.moverDelta > 0) {
            return 'Auto insight: precise move that kept or grew the initiative.';
          }
          return 'Auto insight: steady choice that held the evaluation in balance.';
        }
        return 'Auto insight: most impactful swing detected by Stockfish.';
      }

      function formatAutomatedMoveLabel(move, idx) {
        if (!move) return '';
        const moveNumber = move.moveNumber || Math.floor(idx / 2) + 1;
        const prefix = move.color === 'b' ? `${moveNumber}...` : `${moveNumber}.`;
        return `${prefix} ${move.san}`;
      }

      function formatAutomatedEvaluation(move) {
        if (!move) return '{0}';
        if (move.evaluation) return move.evaluation;
        if (Number.isFinite(move.mateAfter)) return `{#${move.mateAfter}}`;
        if (Number.isFinite(move.mateBefore)) return `{#${move.mateBefore}}`;
        const deltaToken = formatDeltaBraced(move.moverDelta);
        if (deltaToken) return deltaToken;
        const whiteDeltaToken = formatDeltaBraced(move.whiteDelta);
        return whiteDeltaToken || '{0}';
      }

      function buildAutomatedReviewText(insights) {
        if (!insights || !Array.isArray(insights.moves) || !insights.moves.length) return '';
        const lines = [];
        insights.moves.forEach((move, idx) => {
          const label = formatAutomatedMoveLabel(move, idx);
          if (!label) return;
          const evaluation = formatAutomatedEvaluation(move);
          const classification = move.classification || 'Good';
          const comment = buildAutomatedComment(move);
          const commentSuffix = comment ? ` ${comment}` : '';
          lines.push(`${label} - ${evaluation} ${classification}:${commentSuffix}`);
        });

        const summaryLine = buildAutomatedSummaryLine(insights.summary);
        if (summaryLine) {
          lines.push('', summaryLine);
        }

        if (insights.moveOfGame) {
          const featured = insights.moveOfGame;
          const label = formatAutomatedMoveLabel(featured, featured.index || 0);
          const evaluation = formatAutomatedEvaluation(featured);
          const classification = featured.classification || 'Great';
          const justification = buildAutomatedMoveOfGameComment(featured);
          lines.push(`Move of the game: ${label} - ${evaluation} ${classification}: ${justification}`);
        }

        return lines.join('\n');
      }

      function buildAutomatedSummaryLine(summaryData) {
        if (!summaryData) return '';
        const counts = summaryData.counts || {};
        const brilliant = counts['Brilliant'] || 0;
        const great = counts['Great'] || 0;
        const mistakes = counts['Mistake'] || 0;
        const blunders = counts['Blunder'] || 0;
        const misclicks = counts['Misclick??'] || 0;
        const totalGood = summaryData.totalGood || 0;
        const totalBad = summaryData.totalBad || 0;
        const accuracy = summaryData.totalMoves ? (summaryData.totalGood / summaryData.totalMoves) * 100 : 0;
        return `Summary: Brilliant = ${brilliant} | Great = ${great} | Mistakes = ${mistakes} | Blunders = ${blunders} | Misclicks = ${misclicks}. ${totalGood} Total Good = (Brilliant + Great + Good + Book + Forced); ${totalBad} Total Bad = (Inaccuracies + Mistakes + Blunders + Misclicks). Accuracy: ${accuracy.toFixed(2)}%. Narrative Summary: Automated engine insights summary generated from Stockfish evaluations.`;
      }

      function convertAutomatedMoveToFeatured(autoMove) {
        if (!autoMove) return null;
        return {
          san: autoMove.san,
          displaySan: null,
          evaluation: autoMove.evaluation || null,
          classification: autoMove.classification || null,
          text: '',
          index: autoMove.index
        };
      }
      function normalizeSanToken(value) {
        if (!value) return '';
        let san = String(value).trim();
        san = san.replace(/^[0-9]+\.(?:\.\.)?\s*/, '');
        san = san.replace(/^\.{3}/, '');
        san = san.replace(/[!?]+$/, '');
        san = san.replace(/0-0-0/gi, 'O-O-O').replace(/0-0/gi, 'O-O');
        return san;
      }
      let selectedSquare = null;
      function clearSelected() {
        $('#board .square-55d63').removeClass('selected');
        selectedSquare = null;
      }

      function isExploring() {
        return !!(explorationState && explorationState.active);
      }

      function startExploration(baseFen, baseIndex) {
        explorationState = {
          active: true,
          baseFen: baseFen || null,
          baseIndex: Number.isFinite(baseIndex) ? baseIndex : -1,
          moves: [],
          cursor: 0
        };
      }

      function clearExploration(forceUpdate) {
        const wasExploring = isExploring();
        explorationState = null;
        if (wasExploring || forceUpdate) {
          syncNavigationControls();
        }
        updateEvalGraphInteractivity();
      }

      function applyExplorationCursor(targetCursor) {
        if (!isExploring()) return;
        const maxMoves = explorationState.moves.length;
        const safeTarget = Math.max(0, Math.min(targetCursor, maxMoves));
        const baseFen = explorationState.baseFen;
        let loaded = false;
        if (baseFen) {
          loaded = game.load(baseFen);
        }
        if (!loaded) {
          game.reset();
        }
        explorationState.cursor = 0;
        for (let i = 0; i < safeTarget; i++) {
          const mv = explorationState.moves[i];
          if (!mv) break;
          let applied = null;
          if (mv.san) applied = game.move(mv.san);
          if (!applied && mv.from && mv.to) {
            const moveSpec = { from: mv.from, to: mv.to };
            if (mv.promotion) moveSpec.promotion = mv.promotion;
            applied = game.move(moveSpec);
          }
          if (!applied) break;
          explorationState.cursor = i + 1;
        }
        if (board) board.position(game.fen());
      }

      function stepExploration(delta) {
        if (!isExploring()) return false;
        const target = explorationState.cursor + delta;
        if (target < 0 || target > explorationState.moves.length) return false;
        applyExplorationCursor(target);
        handleExplorationPositionChanged();
        return true;
      }
      function handleSquareClick(square) {
        if (selectedSquare) {
          if (selectedSquare === square) {
            clearSelected();
            return;
          }
          const fenBeforeMove = game.fen();
          const move = game.move({ from: selectedSquare, to: square, promotion: 'q' });
          if (move) {
            if (!isExploring()) {
              startExploration(fenBeforeMove, currentMoveIndex);
            } else if (explorationState.cursor < explorationState.moves.length) {
              explorationState.moves = explorationState.moves.slice(0, explorationState.cursor);
            }
            explorationState.moves.push({ san: move.san, from: move.from, to: move.to, promotion: move.promotion });
            explorationState.cursor = explorationState.moves.length;
            if (board) board.position(game.fen());
            clearSelected();
            handleExplorationPositionChanged();
          } else {
            clearSelected();
            if (game.get(square)) {
              selectedSquare = square;
              $('#board .square-' + square).addClass('selected');
            }
          }
        } else {
          if (!game.get(square)) return;
          selectedSquare = square;
          $('#board .square-' + square).addClass('selected');
        }
      }
      function formatText(t) {
        return t ? String(t).replace(/\*\*(.*?)\*\*/g,'<strong>$1</strong>') : '';
      }
      function formatSummaryLine(s) {
        if (!s) return '';

        // Split into the portion to format and the portion to leave untouched.
        const pctIdx = s.lastIndexOf('%');
        let before = s;
        let after = '';
        if (pctIdx !== -1) {
          before = s.slice(0, pctIdx + 1);
          after = s.slice(pctIdx + 1);
        }

        let html = formatText(before);

        // Temporarily replace totals so 'Good'/'Bad' aren't recolored inside them.
        let totalGood = null;
        let totalBad = null;
        html = html.replace(/(\d+\s+Total\s+Good)/i, m => { totalGood = m; return '@@TOTAL_GOOD@@'; });
        html = html.replace(/(\d+\s+Total\s+Bad)/i, m => { totalBad = m; return '@@TOTAL_BAD@@'; });

        Object.keys(classificationStyles).forEach(k => {
          if (k === 'default') return;
          let pattern = k;
          if (k === 'inaccuracy') pattern = 'inaccurac(?:y|ies)';
          else if (k !== 'forced' && k !== 'good') pattern += 's?';
          const regex = new RegExp('(?:\\b(\\d+)\\s+)?\\b' + pattern + '\\b', 'gi');
          html = html.replace(regex, (match, num) => {
            if (num && parseInt(num, 10) === 0) return match;
            return '<span class="' + getStyleForClassification(k) + '">' + match + '</span>';
          });
        });

        // Highlight any percentages (e.g., "Accuracy: 65%" or "65% accuracy")
        html = html.replace(/(\d+(?:\.\d+)?)%/g,
          m => '<strong class="text-yellow-400">' + m + '</strong>');

        if (totalGood) {
          html = html.replace('@@TOTAL_GOOD@@', '<strong class="text-yellow-400">' + totalGood + '</strong>');
        }
        if (totalBad) {
          html = html.replace('@@TOTAL_BAD@@', '<strong class="text-yellow-400">' + totalBad + '</strong>');
        }

        // Append untouched portion after the percentage sign.
        return html + after;
      }
      function showError(m) { $('#error-message').text(m); $('#error-modal').removeClass('hidden'); }
      $('#close-modal-btn').on('click', function(){ $('#error-modal').addClass('hidden'); });

      // ---------- Score helpers ----------
      function cpToProb(cp){ return 1 / (1 + Math.exp(-cp / 173)); }

      function clampProb(p) {
        if (p == null || Number.isNaN(p)) return null;
        if (p < 0) return 0;
        if (p > 1) return 1;
        return p;
      }

      function formatDeltaNumber(delta) {
        if (delta == null || !isFinite(delta)) return null;
        let rounded = Math.round(delta);
        if (Object.is(rounded, -0)) rounded = 0;
        return String(rounded);
      }

      function formatDeltaBraced(delta) {
        const formatted = formatDeltaNumber(delta);
        if (!formatted) return '';
        return `{${formatted}}`;
      }

      function formatProbBraced(prob) {
        const clamped = clampProb(prob);
        if (clamped == null) return '';
        const percent = Math.round(clamped * 100);
        return `{${percent}%}`;
      }

      function formatWhiteWinProbDisplay(prob) {
        const clamped = clampProb(prob);
        if (clamped == null) return '';
        const percent = Math.round(clamped * 100);
        return '<span class="font-mono text-xs text-yellow-400">{' + percent + '%}</span>';
      }

      function formatMoverDeltaIndicator(delta) {
        if (delta == null) return '';
        const numeric = Number(delta);
        if (!Number.isFinite(numeric)) return '';
        let rounded = Math.round(numeric);
        if (Object.is(rounded, -0)) rounded = 0;
        if (rounded >= 0) {
          return '<span class="font-mono text-sm font-bold text-green-400">&uarr;' + rounded + '</span>';
        }
        return '<span class="font-mono text-sm font-bold text-red-400">&darr;' + Math.abs(rounded) + '</span>';
      }

      // ---------- PGN normalization ----------
      function normalizePgn(raw, opts) {
        opts = opts || {}; const keepComments = !!opts.keepComments;
        let s = String(raw || '').replace(/\r\n?/g, '\n').replace(/^\uFEFF/, '').trim(); if (!s) return '';
        const lines = s.split('\n'); const headerLines = []; let i = 0;
        while (i < lines.length && /^\s*\[.*\]\s*$/.test(lines[i])) { headerLines.push(lines[i].trim()); i++; }
        let movePart = lines.slice(i).join('\n');
        if (headerLines.length === 0) {
          const all = s.split('\n'); let lastHeaderIdx = -1;
          for (let j=0;j<all.length;j++) if (/^\s*\[.*\]\s*$/.test(all[j])) lastHeaderIdx = j;
          if (lastHeaderIdx >= 0) { headerLines.push(...all.slice(0,lastHeaderIdx+1).map(x=>x.trim())); movePart = all.slice(lastHeaderIdx+1).join('\n'); }
        }
        if (!keepComments) {
          movePart = movePart.replace(/\{[^}]*\}/g,' ');
          movePart = movePart.replace(/\([^()]*\)/g,' ');
          movePart = movePart.replace(/\$\d+/g,' ');
          movePart = movePart.replace(/([a-hRNBQKO0-9=:+#-])([!?]{1,2})/g,'$1');
          movePart = movePart.replace(/\u2026/g,'...');
        }
        movePart = movePart.replace(/\s+/g,' ').replace(/\s*\.(\.\.)?\s*/g, m=>m.trim()+' ').trim();
        const headerBlock = headerLines.length ? headerLines.join('\n') : '';
        return headerBlock ? (headerBlock+'\n\n'+movePart) : movePart;
      }

      function buildHeaderTagBlock(chess) {
        const hdr = chess.header();
        const order = ['Event','Site','Date','Round','White','Black','Result','TimeControl','WhiteElo','BlackElo','Termination','ECO','EndTime','Link','UTCDate','UTCTime','GameId','Variant','Opening','Annotator'];
        const seen = new Set(); const lines = [];
        order.forEach(k => { if (hdr[k]) { lines.push(`[${k} "${hdr[k]}"]`); seen.add(k); } });
        Object.keys(hdr).sort().forEach(k => { if (!seen.has(k)) lines.push(`[${k} "${hdr[k]}"]`); });
        return lines.join('\n');
      }

      function normalizeStep(step) {
        const n = parseInt(step, 10);
        if (!Number.isFinite(n) || Number.isNaN(n)) return 1;
        if (n < 1) return 1;
        if (n > 4) return 4;
        return n;
      }

      function getStepFromHash(hash) {
        if (!hash) return 1;
        if (hash === '#step-1') return 1;
        const match = Object.entries(STEP_HASHES).find(([, value]) => value === hash);
        if (!match) return 1;
        return normalizeStep(parseInt(match[0], 10));
      }

      function loadFormState() {
        return {};
      }

      function persistFormState() {
        // Disabled: Avoid persisting PGN or analysis data to storage.
      }

      function isLocalStorageAvailable() {
        try {
          if (typeof window === 'undefined' || !window.localStorage) return false;
          const testKey = '__cmr_storage_test__';
          window.localStorage.setItem(testKey, '1');
          window.localStorage.removeItem(testKey);
          return true;
        } catch (err) {
          return false;
        }
      }

      function loadArchiveEntriesFromStorage() {
        if (typeof window === 'undefined' || !window.localStorage) return [];
        try {
          const raw = window.localStorage.getItem(ARCHIVE_STORAGE_KEY);
          if (!raw) return [];
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return [];
          const normalized = parsed.map(normalizeArchiveEntry).filter(Boolean);
          normalized.sort((a, b) => (b.updatedAt || b.createdAt || 0) - (a.updatedAt || a.createdAt || 0));
          return normalized;
        } catch (err) {
          console.warn('Failed to load saved reviews:', err);
          return [];
        }
      }

      function normalizeArchiveEntry(entry) {
        if (!entry || typeof entry !== 'object') return null;
        if (!entry.finalAnalysis) return null;
        const createdAt = Number(entry.createdAt) || Date.now();
        const updatedAt = Number(entry.updatedAt) || createdAt;
        return {
          id: entry.id || `archive-${createdAt}-${Math.random().toString(36).slice(2, 8)}`,
          version: entry.version || 1,
          title: entry.title || '',
          finalAnalysis: String(entry.finalAnalysis),
          pgn: entry.pgn || '',
          annotatedPgn: entry.annotatedPgn || '',
          stockfishOutput: entry.stockfishOutput || '',
          summary: entry.summary || '',
          playerColor: entry.playerColor || null,
          playerName: entry.playerName || '',
          opponent: entry.opponent || '',
          resultCode: entry.resultCode || '',
          resultLabel: entry.resultLabel || '',
          headers: entry.headers && typeof entry.headers === 'object' ? entry.headers : {},
          movesCount: Number.isFinite(Number(entry.movesCount)) ? Number(entry.movesCount) : null,
          featuredMove: entry.featuredMove && typeof entry.featuredMove === 'object' ? entry.featuredMove : null,
          createdAt,
          updatedAt
        };
      }

      function persistArchiveEntries(entries) {
        if (!storageAvailable || typeof window === 'undefined' || !window.localStorage) return false;
        try {
          const payload = Array.isArray(entries) ? entries.map(entry => ({
            id: entry.id,
            version: entry.version || 1,
            title: entry.title || '',
            finalAnalysis: entry.finalAnalysis || '',
            pgn: entry.pgn || '',
            annotatedPgn: entry.annotatedPgn || '',
            stockfishOutput: entry.stockfishOutput || '',
            summary: entry.summary || '',
            playerColor: entry.playerColor || null,
            playerName: entry.playerName || '',
            opponent: entry.opponent || '',
            resultCode: entry.resultCode || '',
            resultLabel: entry.resultLabel || '',
            headers: entry.headers || {},
            movesCount: entry.movesCount != null ? entry.movesCount : null,
            featuredMove: entry.featuredMove || null,
            createdAt: entry.createdAt || Date.now(),
            updatedAt: entry.updatedAt || entry.createdAt || Date.now()
          })) : [];
          window.localStorage.setItem(ARCHIVE_STORAGE_KEY, JSON.stringify(payload));
          return true;
        } catch (err) {
          console.warn('Failed to persist saved reviews:', err);
          return false;
        }
      }

      function openArchiveModal() {
        if (!archiveModal.length) return;
        archiveReturnFocus = document.activeElement;
        renderArchiveList();
        showArchiveStatus('', 'info');
        archiveModal.removeClass('hidden').attr('aria-hidden', 'false');
        if (closeArchiveBtn.length) {
          setTimeout(() => { closeArchiveBtn.trigger('focus'); }, 0);
        }
      }

      function closeArchiveModal() {
        if (!archiveModal.length) return;
        archiveModal.addClass('hidden').attr('aria-hidden', 'true');
        showArchiveStatus('', 'info');
        if (archiveReturnFocus && typeof archiveReturnFocus.focus === 'function') {
          try { archiveReturnFocus.focus(); } catch (err) { /* ignore */ }
        }
        archiveReturnFocus = null;
      }

      function showArchiveStatus(message, tone) {
        if (!archiveStatus.length) return;
        archiveStatus
          .removeClass('hidden text-red-300 text-emerald-300 text-sky-300 text-gray-300')
          .addClass(message ? '' : 'hidden')
          .text(message || '');
        if (!message) return;
        const toneClass = tone === 'error' ? 'text-red-300'
          : tone === 'success' ? 'text-emerald-300'
            : tone === 'info' ? 'text-sky-300'
              : 'text-gray-300';
        archiveStatus.addClass(toneClass);
      }

      function showArchiveFeedback(message, tone) {
        if (!archiveFeedback.length) return;
        if (archiveFeedbackTimeout) {
          clearTimeout(archiveFeedbackTimeout);
          archiveFeedbackTimeout = null;
        }
        if (!message) {
          archiveFeedback.addClass('hidden').text('');
          return;
        }
        const toneClass = tone === 'error' ? 'text-red-300'
          : tone === 'success' ? 'text-emerald-300'
            : 'text-sky-300';
        archiveFeedback
          .removeClass('hidden text-red-300 text-emerald-300 text-sky-300')
          .addClass(toneClass)
          .text(message);
        archiveFeedbackTimeout = setTimeout(() => {
          archiveFeedback.addClass('hidden');
        }, 4500);
      }

      function syncArchiveModalControls() {
        if (clearArchiveBtn.length) {
          clearArchiveBtn.prop('disabled', !storageAvailable || archiveEntries.length === 0);
        }
      }

      function renderArchiveList() {
        if (!archiveList.length) return;
        archiveList.empty();
        if (!storageAvailable) {
          showArchiveStatus('Saving is unavailable in this browser session.', 'error');
          syncArchiveModalControls();
          return;
        }
        if (!archiveEntries.length) {
          showArchiveStatus('No saved reviews yet. Analyze a game and save it to build your archive.', 'info');
          syncArchiveModalControls();
          return;
        }
        showArchiveStatus('', 'info');
        const ordered = archiveEntries.slice().sort((a, b) => (b.updatedAt || b.createdAt || 0) - (a.updatedAt || a.createdAt || 0));
        ordered.forEach(entry => {
          const item = $('<div class="bg-[#0b0e15] border border-[#1f2937] rounded-lg p-4"></div>');
          const header = $('<div class="flex items-center justify-between gap-3"></div>').appendTo(item);
          const textWrap = $('<div class="min-w-0 flex-1"></div>').appendTo(header);
          const title = entry.title || buildArchiveTitle(entry);
          $('<h4 class="text-lg font-semibold text-white truncate"></h4>').text(title).appendTo(textWrap);
          const timestamp = entry.updatedAt || entry.createdAt || Date.now();
          $('<p class="text-xs text-gray-400"></p>').text(formatDateTime(timestamp)).appendTo(textWrap);
          const infoParts = [];
          if (entry.opponent) infoParts.push('vs ' + entry.opponent);
          if (entry.resultLabel) infoParts.push(entry.resultLabel);
          else if (entry.resultCode) infoParts.push(entry.resultCode);
          if (entry.playerColor === 'white') infoParts.push('You were White');
          else if (entry.playerColor === 'black') infoParts.push('You were Black');
          if (infoParts.length) {
            $('<p class="text-xs text-gray-400"></p>').text(infoParts.join(' • ')).appendTo(textWrap);
          }
          const actions = $('<div class="flex items-center gap-2 shrink-0"></div>').appendTo(header);
          $('<button type="button" class="py-1 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap" data-archive-action="load"></button>')
            .attr('data-archive-id', entry.id)
            .text('Load')
            .appendTo(actions);
          $('<button type="button" class="py-1 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap" data-archive-action="delete"></button>')
            .attr('data-archive-id', entry.id)
            .text('Delete')
            .appendTo(actions);
          if (entry.summary) {
            $('<p class="text-sm text-gray-300 mt-2 whitespace-pre-wrap break-words"></p>').text(entry.summary).appendTo(item);
          }
          if (entry.featuredMove && entry.featuredMove.displaySan) {
            $('<p class="text-xs text-yellow-300 mt-1"></p>').text('Move of the Game: ' + entry.featuredMove.displaySan).appendTo(item);
          }
          if (entry.movesCount) {
            $('<p class="text-xs text-gray-500 mt-1"></p>').text(entry.movesCount + ' moves').appendTo(item);
          }
          archiveList.append(item);
        });
        syncArchiveModalControls();
      }

      function deriveOpponentFromHeaders(headers, color, playerNameInput) {
        if (!headers || typeof headers !== 'object') return '';
        const white = headers.White || '';
        const black = headers.Black || '';
        if (color === 'white') return black;
        if (color === 'black') return white;
        const normalized = playerNameInput ? String(playerNameInput).trim().toLowerCase() : '';
        if (normalized && white && white.toLowerCase() === normalized) return black;
        if (normalized && black && black.toLowerCase() === normalized) return white;
        return white && black ? `${white} vs ${black}` : (white || black || '');
      }

      function buildArchiveTitle(meta) {
        if (meta && meta.summary) {
          const summaryText = String(meta.summary).trim();
          if (summaryText) return summaryText;
        }
        const headers = meta && meta.headers ? meta.headers : (game && typeof game.header === 'function' ? game.header() : {});
        const white = headers.White || 'White';
        const black = headers.Black || 'Black';
        const base = `${white} vs ${black}`;
        const resultLabel = meta && meta.resultLabel ? meta.resultLabel : (headers.Result ? describeResult(headers.Result) : '');
        if (resultLabel) return `${base} (${resultLabel})`;
        if (headers.Result && headers.Result !== '*') return `${base} (${headers.Result})`;
        return base;
      }

      function buildArchiveEntry(customTitle) {
        if (!lastFinalAnalysisText) return null;
        const now = Date.now();
        const meta = currentReviewMetadata || {};
        const headers = meta.headers && typeof meta.headers === 'object'
          ? { ...meta.headers }
          : (game && typeof game.header === 'function' ? { ...game.header() } : {});
        const title = customTitle && customTitle.trim() ? customTitle.trim() : buildArchiveTitle({ ...meta, headers });
        const pgnSnapshot = meta.pgn || (game && typeof game.pgn === 'function' ? game.pgn({ max_width: 0, newline_char: '\n' }) : '');
        const opponent = meta.opponent || deriveOpponentFromHeaders(headers, meta.playerColor || reviewPlayerColor, meta.playerName || getPlayerName());
        const resultCode = meta.resultCode || headers.Result || '';
        const resultLabel = meta.resultLabel || describeResult(resultCode);
        return {
          id: '',
          version: 1,
          title,
          finalAnalysis: lastFinalAnalysisText,
          pgn: pgnSnapshot || '',
          annotatedPgn: meta.annotatedPgn || lastAnnotatedPgn || '',
          stockfishOutput: meta.stockfishOutput || ($('#stockfish-output').val() || ''),
          summary: meta.summary || '',
          playerColor: meta.playerColor || reviewPlayerColor,
          playerName: meta.playerName || getPlayerName(),
          opponent,
          resultCode,
          resultLabel,
          headers,
          movesCount: meta.movesCount != null ? meta.movesCount : (Array.isArray(movesWithAnalysis) ? movesWithAnalysis.length : null),
          featuredMove: meta.featuredMove || null,
          createdAt: now,
          updatedAt: now
        };
      }

      function updateArchiveControls() {
        const reviewVisible = $('#review-section').is(':visible');
        if (saveArchiveBtn.length) {
          if (!storageAvailable) {
            saveArchiveBtn.prop('disabled', true);
            saveArchiveBtn.attr('title', 'Browser storage is unavailable in this session.');
          } else if (!reviewVisible || !lastFinalAnalysisText) {
            saveArchiveBtn.prop('disabled', true);
            saveArchiveBtn.attr('title', 'Generate a review before saving it to your archive.');
          } else {
            saveArchiveBtn.prop('disabled', false);
            saveArchiveBtn.attr('title', 'Save this review to your archive.');
          }
        }
        if (openArchiveButtons.length) {
          openArchiveButtons.each(function () {
            if (!storageAvailable) {
              $(this).prop('disabled', true);
              $(this).attr('title', 'Browser storage is unavailable in this session.');
            } else {
              $(this).prop('disabled', false);
              $(this).attr('title', 'Open your saved reviews.');
            }
          });
        }
        if (!reviewVisible) {
          showArchiveFeedback('', 'info');
        }
        syncArchiveModalControls();
      }

      function handleSaveArchiveEntry() {
        if (!storageAvailable) {
          showArchiveFeedback('Saving is unavailable in this browser session.', 'error');
          return;
        }
        if (!$('#review-section').is(':visible') || !lastFinalAnalysisText) {
          showArchiveFeedback('Generate a review before saving.', 'error');
          return;
        }
        const defaultTitle = buildArchiveTitle(currentReviewMetadata || {});
        const response = window.prompt('Name this saved review:', defaultTitle);
        if (response == null) return;
        const entry = buildArchiveEntry(response);
        if (!entry) {
          showArchiveFeedback('Nothing to save yet.', 'error');
          return;
        }
        const timestamp = Date.now();
        entry.updatedAt = timestamp;
        const existing = archiveEntries.find(e => e.finalAnalysis === entry.finalAnalysis);
        if (existing) {
          entry.id = existing.id;
          entry.createdAt = existing.createdAt || timestamp;
        } else {
          entry.id = `archive-${timestamp}-${Math.random().toString(36).slice(2, 10)}`;
          entry.createdAt = timestamp;
        }
        const previous = archiveEntries.slice();
        archiveEntries = [entry, ...archiveEntries.filter(e => e.id !== entry.id)];
        if (archiveEntries.length > ARCHIVE_MAX_ENTRIES) {
          archiveEntries = archiveEntries.slice(0, ARCHIVE_MAX_ENTRIES);
        }
        if (!persistArchiveEntries(archiveEntries)) {
          archiveEntries = previous;
          showArchiveFeedback('Unable to save review. Storage may be full.', 'error');
          return;
        }
        showArchiveFeedback(`Saved "${entry.title}".`, 'success');
        if (archiveModal.length && !archiveModal.hasClass('hidden')) {
          renderArchiveList();
        }
        updateArchiveControls();
      }

      function handleDeleteArchiveEntry(id) {
        if (!storageAvailable || !id) return;
        if (!window.confirm('Delete this saved review?')) return;
        const previous = archiveEntries.slice();
        archiveEntries = archiveEntries.filter(entry => entry.id !== id);
        if (!persistArchiveEntries(archiveEntries)) {
          archiveEntries = previous;
          showArchiveStatus('Unable to delete the saved review.', 'error');
          return;
        }
        showArchiveStatus('Saved review deleted.', 'success');
        renderArchiveList();
        updateArchiveControls();
      }

      function handleClearArchive() {
        if (!storageAvailable || !archiveEntries.length) {
          showArchiveStatus(archiveEntries.length ? 'Saving is unavailable in this session.' : 'No saved reviews to clear.', archiveEntries.length ? 'error' : 'info');
          return;
        }
        if (!window.confirm('Remove all saved reviews? This cannot be undone.')) return;
        archiveEntries = [];
        if (!persistArchiveEntries(archiveEntries)) {
          showArchiveStatus('Unable to clear saved reviews.', 'error');
          archiveEntries = loadArchiveEntriesFromStorage();
          renderArchiveList();
          updateArchiveControls();
          return;
        }
        showArchiveStatus('Archive cleared.', 'success');
        renderArchiveList();
        updateArchiveControls();
      }

      function loadArchiveEntryById(id) {
        if (!id) return false;
        const entry = archiveEntries.find(e => e.id === id);
        if (!entry) {
          showArchiveStatus('Could not find the selected review.', 'error');
          return false;
        }
        const analysisText = entry.finalAnalysis || '';
        if (!analysisText.trim()) {
          showArchiveStatus('This saved review is missing its analysis text.', 'error');
          return false;
        }
        if ($('#player-name-input').length) {
          $('#player-name-input').val(entry.playerName || '');
          updateFormState('playerName', entry.playerName || '');
          $('#player-name-input').trigger('input');
        }
        if ($('#pgn-input').length) {
          $('#pgn-input').val(entry.pgn || '');
          updateFormState('pgnInput', entry.pgn || '');
        }
        if ($('#final-analysis-input').length) {
          $('#final-analysis-input').val(analysisText);
          updateFormState('finalAnalysisInput', analysisText);
        }
        if (entry.annotatedPgn) {
          lastAnnotatedPgn = entry.annotatedPgn;
          updateFormState('annotatedPgn', lastAnnotatedPgn);
        }
        if (entry.stockfishOutput) {
          $('#stockfish-output').val(entry.stockfishOutput);
          updateFormState('stockfishOutput', entry.stockfishOutput);
        }
        if (entry.playerColor) {
          const assignedColor = setReviewPlayerColor(entry.playerColor);
          playerGameOutcome = derivePlayerOutcome(entry.resultCode || '', assignedColor);
        } else {
          setReviewPlayerColor(null);
          playerGameOutcome = null;
        }
        lastFinalAnalysisText = analysisText;
        currentReviewMetadata = {
          headers: entry.headers || {},
          summary: entry.summary || '',
          playerColor: entry.playerColor || null,
          playerName: entry.playerName || '',
          opponent: entry.opponent || '',
          annotatedPgn: entry.annotatedPgn || '',
          stockfishOutput: entry.stockfishOutput || '',
          pgn: entry.pgn || '',
          resultCode: entry.resultCode || '',
          resultLabel: entry.resultLabel || '',
          movesCount: entry.movesCount || null,
          featuredMove: entry.featuredMove || null
        };
        closeArchiveModal();
        pendingArchiveLoadNotice = entry.title || 'Review';
        switchStep(3);
        setTimeout(() => {
          $('#generate-review-btn').trigger('click');
        }, 0);
        return true;
      }

      const TRANSIENT_FORM_KEYS = new Set(['pgnInput', 'finalAnalysisInput', 'stockfishOutput']);

      function updateFormState(key, value) {
        if (!key || TRANSIENT_FORM_KEYS.has(String(key))) return;
        if (!formState || typeof formState !== 'object') formState = {};
        formState[key] = value;
        persistFormState();
      }

      function buildCombinedStockfishOutput(playerName, annotatedPgn, automatedText) {
        const prompt = buildAnalysisPrompt(playerName);
        let combined = prompt;
        if (annotatedPgn) {
          combined += '\n\n' + annotatedPgn;
        }
        if (automatedText) {
          combined += '\n\n=== Automated Stockfish Insights ===\n' + automatedText;
        }
        return combined;
      }

      function refreshStockfishOutput() {
        if (!lastAnnotatedPgn) return;
        const combined = buildCombinedStockfishOutput(getPlayerName(), lastAnnotatedPgn, automatedReviewText);
        $('#stockfish-output').val(combined);
        updateFormState('stockfishOutput', combined);
      }

      function bindPersistentInput(selector, key, opts) {
        const el = $(selector);
        if (!el.length) return;
        const sanitizer = opts && typeof opts.sanitize === 'function' ? opts.sanitize : (value => value);
        el.on('input change', function () {
          const raw = $(this).val();
          const sanitized = sanitizer(raw);
          const sanitizedStr = sanitized == null ? '' : String(sanitized);
          if (raw !== sanitizedStr) {
            $(this).val(sanitizedStr);
          }
          updateFormState(key, sanitized);
        });
      }

      function applySavedFormState() {
        if (!formState) return;
        if (formState.playerName != null) $('#player-name-input').val(formState.playerName);
        if (formState.pgnInput != null) $('#pgn-input').val(formState.pgnInput);
        if (formState.finalAnalysisInput != null) $('#final-analysis-input').val(formState.finalAnalysisInput);
        if (formState.depthInput != null) {
          const sanitizedDepth = sanitizeEngineSetting('depth', formState.depthInput);
          $('#depth-input').val(sanitizedDepth);
          if (sanitizedDepth !== formState.depthInput) updateFormState('depthInput', sanitizedDepth);
        }
        if (formState.threadsInput != null) {
          const sanitizedThreads = sanitizeEngineSetting('threads', formState.threadsInput);
          $('#threads-input').val(sanitizedThreads);
          if (sanitizedThreads !== formState.threadsInput) updateFormState('threadsInput', sanitizedThreads);
        }
        if (formState.hashInput != null) {
          const sanitizedHash = sanitizeEngineSetting('hash', formState.hashInput);
          $('#hash-input').val(sanitizedHash);
          if (sanitizedHash !== formState.hashInput) updateFormState('hashInput', sanitizedHash);
        }
        if (formState.stockfishOutput != null) $('#stockfish-output').val(formState.stockfishOutput);
        if (formState.annotatedPgn != null) lastAnnotatedPgn = formState.annotatedPgn;
        if (lastAnnotatedPgn) refreshStockfishOutput();
      }

      function switchStep(step, opts) {
        opts = opts || {};
        const normalized = normalizeStep(step);
        const previous = currentStep;
        currentStep = normalized;

        const sections = ['#step1-section', '#step2-section', '#step3-section', '#review-section'];
        sections.forEach((selector, index) => {
          if (index === normalized - 1) {
            $(selector).removeClass('hidden');
          } else {
            $(selector).addClass('hidden');
          }
        });

        if (normalized === 3) {
          const finalInput = $('#final-analysis-input');
          if (finalInput.length) {
            const currentVal = finalInput.val();
            if ((!currentVal || !String(currentVal).trim()) && automatedReviewText) {
              finalInput.val(automatedReviewText);
            }
          }
        }

        $('.step-indicator').removeClass('active').removeAttr('aria-current');
        const indicatorIndex = Math.min(normalized, 3);
        const indicatorEl = $('#indicator-' + indicatorIndex);
        if (indicatorEl.length) {
          indicatorEl.addClass('active').attr('aria-current', 'step');
        }

        if (normalized === 4) {
          $('#app-header, #step-indicators').addClass('hidden');
        } else {
          $('#app-header, #step-indicators').removeClass('hidden');
        }

        if (normalized !== 4) {
          currentReviewMetadata = null;
        }

        updateArchiveControls();

        if (!opts.skipHistory && window.history && window.history.pushState) {
          try {
            const targetHash = STEP_HASHES[normalized] != null ? STEP_HASHES[normalized] : STEP_HASHES[1];
            const basePath = window.location.pathname + window.location.search;
            const targetUrl = targetHash ? (basePath + targetHash) : basePath;
            const state = { step: normalized };
            if (opts.replace) {
              window.history.replaceState(state, '', targetUrl);
            } else if (previous === normalized) {
              window.history.replaceState(state, '', targetUrl);
            } else {
              window.history.pushState(state, '', targetUrl);
            }
          } catch (err) {
            console.warn('Unable to update history state:', err);
          }
        }
      }

      $('.step-indicator').each(function () {
        const step = parseInt($(this).data('step'), 10);
        if (!step) return;
        $(this).on('click', function () { switchStep(step); });
        $(this).on('keydown', function (evt) {
          if (evt.key === 'Enter' || evt.key === ' ' || evt.key === 'Spacebar' || evt.key === 'Space') {
            evt.preventDefault();
            switchStep(step);
          }
        });
      });

      const initialStep = (window.history && window.history.state && typeof window.history.state.step === 'number')
        ? normalizeStep(window.history.state.step)
        : getStepFromHash(window.location.hash);
      switchStep(initialStep, { skipHistory: true });
      if (window.history && window.history.replaceState) {
        const initialHash = STEP_HASHES[initialStep] != null ? STEP_HASHES[initialStep] : STEP_HASHES[1];
        const basePath = window.location.pathname + window.location.search;
        const initialUrl = initialHash ? (basePath + initialHash) : basePath;
        window.history.replaceState({ step: initialStep }, '', initialUrl);
      }

      updateArchiveControls();

      window.addEventListener('popstate', function (event) {
        const stateStep = event.state && typeof event.state.step === 'number'
          ? normalizeStep(event.state.step)
          : getStepFromHash(window.location.hash);
        switchStep(stateStep, { skipHistory: true });
      });

      $('#goto-step2-btn').on('click', function(){ switchStep(2); });
      $('#back-to-step1-btn').on('click', function(){ switchStep(1); });
      $('#back-to-step2-btn').on('click', function(){ switchStep(2); });
      $('#back-to-step3-btn').on('click', function(){ switchStep(3); });
      $('#clear-pgn-btn').on('click', function(){
        const pgnInput = $('#pgn-input');
        pgnInput.val('').focus();
        updateFormState('pgnInput', '');
        lastAnnotatedPgn = '';
        updateFormState('annotatedPgn', '');
        $('#stockfish-output').val('');
        updateFormState('stockfishOutput', '');
        setReviewPlayerColor(null);
        playerGameOutcome = null;
        lastEngineMoveRecords = null;
        automatedMoveInsights = { moves: [], summary: null, moveOfGame: null };
        automatedReviewText = '';
        lastFinalAnalysisText = '';
        currentReviewMetadata = null;
        updateArchiveControls();
      });
      $('#clear-final-analysis-btn').on('click', function(){
        const finalAnalysisInput = $('#final-analysis-input');
        finalAnalysisInput.val('').focus();
        updateFormState('finalAnalysisInput', '');
        lastFinalAnalysisText = '';
        currentReviewMetadata = null;
        updateArchiveControls();
      });

      $('#analyze-pgn-btn').on('click', async function () {
        const pgnRaw = $('#pgn-input').val().trim(); if (!pgnRaw) { showError('Please paste a PGN.'); return; }
        const pgn = normalizePgn(pgnRaw);
        if (!game.load_pgn(pgn)) {
          const justMoves = normalizePgn(pgnRaw.replace(/^(\s*\[.*\]\s*$)+/gm,''));
          if (!game.load_pgn(justMoves)) { showError('Invalid PGN format. Try removing engine/clock comments or share the PGN example with me.'); return; }
        }
        const rawNameForAnalysis = getRawPlayerNameInput();
        if (rawNameForAnalysis) {
          updateReviewPlayerColorFromGame(game, rawNameForAnalysis);
        }
        updatePlayerOutcomeFromGame(game);
        await waitForEngineReady();
        if (!engineReady) { handleEngineLoadFailure('Stockfish failed to initialize.'); return; }
        switchStep(2);
        await runStockfishAnalysis();
      });

      function setCopyButtonAnalyzing(active) {
        if (!copyStockfishBtn.length) return;
        if (active) {
          copyStockfishBtn.text(analyzingCopyLabel).prop('disabled', true);
        } else {
          copyStockfishBtn.text(defaultCopyLabel).prop('disabled', false);
        }
      }

      async function runStockfishAnalysis() {
        setCopyButtonAnalyzing(true);
        try {
          configureEngineOptions();
          await waitForEngineReady();
          if (!engineReady) {
            handleEngineLoadFailure('Stockfish failed to initialize.');
            return;
          }
          const rawNameDuringAnalysis = getRawPlayerNameInput();
          if (rawNameDuringAnalysis) {
            updateReviewPlayerColorFromGame(game, rawNameDuringAnalysis);
          }
          const sanMoves = game.history(); let annotatedPgn = '';
          const headerBlock = buildHeaderTagBlock(game); if (headerBlock) annotatedPgn = headerBlock + '\n\n';
          const temp = new Chess();
          probSeries = [];
          let prevProb = 0.5;
          let lastMateScore = null;
          const engineMoveRecords = [];
          automatedMoveInsights = { moves: [], summary: null, moveOfGame: null };
          automatedReviewText = '';
          for (let i = 0; i < sanMoves.length; i++) {
            const moveNumber = Math.floor(i / 2) + 1; const prefix = (i % 2 === 0) ? (moveNumber + '. ') : '';
            const move = sanMoves[i];
            $('#progress-text').text('Analyzing move ' + (i + 1) + '/' + sanMoves.length + ': ' + move);
            $('#progress-bar').css('width', (((i + 1) / sanMoves.length) * 100) + '%');

            // * FIX STARTS HERE *
            // The order of operations is changed.
            // 1. Make the move on the temporary board.
            const moveObj = temp.move(move);
            const lastMoveColor = moveObj.color; // 'w' or 'b'
            const probBeforeMove = prevProb;

            // 2. Get the score for the new position *after* the move has been made.
            const score = await getScore(temp.fen(), ENGINE_GO_OPTIONS);
            // * FIX ENDS HERE *

            let evalStr = '';
            let prob = null;
            let mateScore = null;
            if (score.type === 'mate') {
              mateScore = score.value; // mate in N from side to move
              if (temp.turn() === 'b') mateScore = -mateScore; // convert to WHITE-relative
              prob = (mateScore === 0) ? (lastMoveColor === 'w' ? 1 : 0) : (mateScore > 0 ? 1 : 0);
            } else {
              let cp = score.value; // centipawns from side to move
              if (temp.turn() === 'b') cp = -cp; // convert to WHITE-relative
              prob = cpToProb(cp);
            }
            prob = clampProb(prob);
            let moverDelta = null;
            let whiteDelta = null;
            if (prob != null && prevProb != null) {
              const diff = (prob - prevProb) * 100;
              const moverSign = lastMoveColor === 'w' ? 1 : -1;
              moverDelta = diff * moverSign;
              whiteDelta = diff;
              prevProb = prob;
            } else if (prob != null) {
              prevProb = prob;
            }
            const deltaStr = formatDeltaBraced(moverDelta);
            if (mateScore != null) {
              evalStr = `{#${mateScore}}`;
            } else {
              evalStr = deltaStr || '{0}';
            }
            probSeries.push(prob);
            engineMoveRecords.push({
              index: i,
              ply: i,
              moveNumber,
              color: lastMoveColor,
              san: move,
              moverDelta,
              whiteDelta,
              whiteProbBefore: probBeforeMove,
              whiteProbAfter: prob,
              mateBefore: lastMateScore,
              mateAfter: mateScore,
              evaluation: evalStr,
              move: simplifyMoveObject(moveObj)
            });
            lastMateScore = mateScore;
            annotatedPgn += (i % 2 === 0 ? prefix : '') + move + ' ' + evalStr + ' ';
          }
          lastEngineMoveRecords = engineMoveRecords.map(mv => ({
            ...mv,
            move: mv.move ? { ...mv.move } : null
          }));
          const outcome = updatePlayerOutcomeFromGame(game);
          automatedMoveInsights = computeAutomatedMoveInsights(engineMoveRecords, reviewPlayerColor, outcome);
          automatedReviewText = buildAutomatedReviewText(automatedMoveInsights);
          lastAnnotatedPgn = annotatedPgn.trim();
          const combined = buildCombinedStockfishOutput(getPlayerName(), lastAnnotatedPgn, automatedReviewText);
          $('#progress-text').text('Analysis Complete!');
          $('#stockfish-output').val(combined);
          updateFormState('stockfishOutput', combined);
          updateFormState('annotatedPgn', lastAnnotatedPgn);
          $('#goto-step3-btn').prop('disabled', false);
        } catch (err) {
          console.error('Stockfish analysis failed', err);
          handleEngineLoadFailure('Stockfish analysis failed. Please retry.');
        } finally {
          setCopyButtonAnalyzing(false);
        }
      }

        function getScore(fen, opts) {
          return new Promise(resolve => {
            currentScoreResolver = resolve; lastInfoMsg = '';
            engineWorker.postMessage('position fen ' + fen);
            const o = opts || ENGINE_GO_OPTIONS || {};
            const parts = ['go'];
            if (o.depth != null) parts.push('depth ' + o.depth);
            if (o.movetime != null) parts.push('movetime ' + o.movetime);
            if (parts.length === 1) parts.push('depth 15');
            engineWorker.postMessage(parts.join(' '));
          });
        }

        function handleEngineInfoMessage(msg) {
          if (msg.startsWith('info depth')) {
            lastInfoMsg = msg;
          }
          processBestMoveInfo(msg);
        }

        function normalizeFenForComparison(fen) {
          if (!fen) return '';
          const parts = String(fen).trim().split(/\s+/);
          if (parts.length < 4) return String(fen).trim();
          return parts.slice(0, 4).join(' ');
        }

        function processBestMoveInfo(msg) {
          if (!showBestMove || !bestMoveActiveToken) return;
          if (!bestMoveFen || !bestMoveFenNormalized) return;
          if (!game) return;
          const currentFen = game.fen();
          if (!currentFen) return;
          if (normalizeFenForComparison(currentFen) !== bestMoveFenNormalized) return;
          if (!msg.includes(' pv ')) return;
          const pvMatch = msg.match(/\spv\s+([^\s]+)/);
          if (!pvMatch) return;
          const move = pvMatch[1];
          if (!/^[a-h][1-8][a-h][1-8][nbrq]?$/i.test(move)) return;
          scheduleBestMoveResponseTimer(bestMoveActiveToken);
          scheduleBestMoveStallTimer(bestMoveActiveToken);
          const mateMatch = msg.match(/\bscore mate (-?\d+)/);
          const cpMatch = msg.match(/\bscore cp (-?\d+)/);
          let evalType = null;
          let evalValue = null;
          if (mateMatch) {
            evalType = 'mate';
            evalValue = parseInt(mateMatch[1], 10);
          } else if (cpMatch) {
            evalType = 'cp';
            evalValue = parseInt(cpMatch[1], 10);
          } else {
            return;
          }
          const depthMatch = msg.match(/\bdepth\s+(\d+)/);
          const depth = depthMatch ? parseInt(depthMatch[1], 10) : null;
          queueBestMoveUpdate({
            move,
            evalType,
            evalValue,
            depth,
            token: bestMoveActiveToken
          });
        }

        function queueBestMoveUpdate(info) {
          pendingBestMoveInfo = info;
          if (bestMoveUpdateTimeout) return;
          const now = Date.now();
          const elapsed = now - lastBestMoveUpdate;
          const delay = elapsed >= BEST_MOVE_UPDATE_INTERVAL ? 0 : BEST_MOVE_UPDATE_INTERVAL - elapsed;
          bestMoveUpdateTimeout = setTimeout(flushPendingBestMoveInfo, delay);
        }

        function flushPendingBestMoveInfo() {
          bestMoveUpdateTimeout = null;
          if (!pendingBestMoveInfo) return;
          const info = pendingBestMoveInfo;
          pendingBestMoveInfo = null;
          if (!showBestMove || !bestMoveActiveToken || info.token !== bestMoveActiveToken) return;
          updateBestMoveVisual(info);
          lastBestMoveUpdate = Date.now();
        }

        function cancelPendingBestMoveUpdates() {
          if (bestMoveUpdateTimeout) {
            clearTimeout(bestMoveUpdateTimeout);
            bestMoveUpdateTimeout = null;
          }
          pendingBestMoveInfo = null;
        }

        function cancelBestMoveResponseTimer() {
          if (bestMoveResponseTimeoutHandle) {
            clearTimeout(bestMoveResponseTimeoutHandle);
            bestMoveResponseTimeoutHandle = null;
          }
        }

        function cancelBestMoveStallTimer() {
          if (bestMoveStallTimeoutHandle) {
            clearTimeout(bestMoveStallTimeoutHandle);
            bestMoveStallTimeoutHandle = null;
          }
        }

        function cancelBestMoveWatchdog() {
          cancelBestMoveResponseTimer();
          cancelBestMoveStallTimer();
        }

        function scheduleBestMoveResponseTimer(token) {
          cancelBestMoveResponseTimer();
          if (!showBestMove || !token) return;
          bestMoveResponseTimeoutHandle = setTimeout(() => {
            handleBestMoveResponseTimeout(token);
          }, BEST_MOVE_RESPONSE_TIMEOUT);
        }

        function scheduleBestMoveStallTimer(token) {
          cancelBestMoveStallTimer();
          if (!showBestMove || !token) return;
          bestMoveStallTimeoutHandle = setTimeout(() => {
            handleBestMoveStallTimeout(token);
          }, BEST_MOVE_STALL_TIMEOUT);
        }

        function handleBestMoveResponseTimeout(token) {
          bestMoveResponseTimeoutHandle = null;
          if (!showBestMove || !bestMoveActiveToken || token !== bestMoveActiveToken) return;
          if (!engineReady || !engineWorker) return;
          if (!bestMoveFen || !bestMoveFenNormalized) return;
          if (!game) return;
          const currentFen = game.fen();
          if (!currentFen) return;
          const currentNormalized = normalizeFenForComparison(currentFen);
          if (currentNormalized !== bestMoveFenNormalized) return;
          engineWorker.postMessage('stop');
          engineWorker.postMessage('position fen ' + currentFen);
          engineWorker.postMessage('go infinite');
          scheduleBestMoveResponseTimer(token);
        }

        function handleBestMoveStallTimeout(token) {
          bestMoveStallTimeoutHandle = null;
          if (!showBestMove || !bestMoveActiveToken || token !== bestMoveActiveToken) return;
          if (!bestMoveFen || !bestMoveFenNormalized) return;
          if (!game) return;
          const currentFen = game.fen();
          if (!currentFen) return;
          const currentNormalized = normalizeFenForComparison(currentFen);
          if (currentNormalized !== bestMoveFenNormalized) return;
          restartEngineAndRetryBestMove(token, currentFen, currentNormalized);
        }

        async function restartEngineAndRetryBestMove(token, fenSnapshot, normalizedSnapshot) {
          if (!fenSnapshot || !normalizedSnapshot) return;
          cancelBestMoveResponseTimer();
          cancelBestMoveStallTimer();
          initEngine();
          try {
            await waitForEngineReady();
          } catch (err) {
            return;
          }
          if (!showBestMove || !bestMoveActiveToken || token !== bestMoveActiveToken) return;
          if (!engineReady || !engineWorker) return;
          if (!game) return;
          const currentFen = game.fen();
          if (!currentFen) return;
          const currentNormalized = normalizeFenForComparison(currentFen);
          if (currentNormalized !== normalizedSnapshot) return;
          bestMoveFen = currentFen;
          bestMoveFenNormalized = currentNormalized;
          showBestMoveAnalyzingDisplay();
          cancelPendingBestMoveUpdates();
          engineWorker.postMessage('position fen ' + currentFen);
          engineWorker.postMessage('go infinite');
          scheduleBestMoveResponseTimer(token);
          scheduleBestMoveStallTimer(token);
        }

        function setBestButtonState(text, isActive) {
          if (!toggleBestBtn.length) return;
          const label = text || defaultBestButtonLabel;
          toggleBestBtn.text(label);
          toggleBestBtn.attr('title', label);
          toggleBestBtn.attr('aria-pressed', isActive ? 'true' : 'false');
          toggleBestBtn.toggleClass('best-active', !!isActive);
        }

        function showBestMoveAnalyzingDisplay() {
          setBestButtonState('Analyzing…', true);
        }

        function hideBestMoveEvalDisplay() {
          setBestButtonState(defaultBestButtonLabel, false);
        }

        function cancelBestMoveVisualRetryTimer() {
          if (bestMoveVisualRetryHandle) {
            clearTimeout(bestMoveVisualRetryHandle);
            bestMoveVisualRetryHandle = null;
          }
        }

        function resetBestMoveVisualState() {
          cancelBestMoveVisualRetryTimer();
          pendingBestMoveVisualData = null;
        }

        function scheduleBestMoveVisualRetry() {
          if (bestMoveVisualRetryHandle) return;
          bestMoveVisualRetryHandle = setTimeout(() => {
            bestMoveVisualRetryHandle = null;
            attemptApplyBestMoveVisual();
          }, BEST_MOVE_VISUAL_RETRY_DELAY);
        }

        function attemptApplyBestMoveVisual() {
          if (!pendingBestMoveVisualData) return;
          const data = pendingBestMoveVisualData;
          if (!showBestMove || !bestMoveActiveToken || data.token !== bestMoveActiveToken) {
            pendingBestMoveVisualData = null;
            return;
          }
          const fromSquareEl = $('#board .square-' + data.from);
          let pieceReady = false;
          if (fromSquareEl.length) {
            pieceReady = fromSquareEl.find('[data-piece]').length > 0;
          }
          if (!pieceReady && data.attempts < BEST_MOVE_VISUAL_RETRY_LIMIT) {
            data.attempts += 1;
            scheduleBestMoveVisualRetry();
            return;
          }
          pendingBestMoveVisualData = null;
          cancelBestMoveVisualRetryTimer();
          if (bestMoveSquares) {
            bestMoveSquares.forEach(sq => {
              $('#board .square-' + sq).css('box-shadow', '');
            });
          }
          if (arrowCtx && arrowCanvas) arrowCtx.clearRect(0, 0, arrowCanvas.width, arrowCanvas.height);
          drawBestMoveArrow(data.from, data.to);
          highlightBestMoveSquares(data.from, data.to);
          lastBestMove = data.move;
        }

        function updateBestMoveVisual(info) {
          if (!info || !info.move) return;
          const moveStr = String(info.move).trim();
          const from = moveStr.substring(0, 2);
          const to = moveStr.substring(2, 4);
          if (!from || !to) return;
          const sanMove = uciToSan(moveStr, bestMoveFen);
          if (!sanMove) return;
          updateBestEvalDisplay(info, sanMove);
          cancelBestMoveVisualRetryTimer();
          pendingBestMoveVisualData = {
            move: moveStr,
            from,
            to,
            token: info.token,
            attempts: 0
          };
          attemptApplyBestMoveVisual();
        }

        function updateBestEvalDisplay(info, sanMove) {
          if (!toggleBestBtn.length) return;
          const evalText = formatBestEval(info);
          const moveText = sanMove ? ' ' + sanMove : '';
          const combined = evalText ? `${evalText}${moveText}` : 'Analyzing…';
          setBestButtonState(combined.trim(), true);
        }

        function formatBestEval(info) {
          if (!info) return '';
          if (info.evalType === 'mate') {
            const mate = parseInt(info.evalValue, 10);
            if (!mate) return '#0';
            const prefix = mate > 0 ? '#' : '#-';
            return prefix + Math.abs(mate);
          }
          const cp = parseInt(info.evalValue, 10) || 0;
          const pawns = cp / 100;
          return (pawns >= 0 ? '+' : '') + pawns.toFixed(2);
        }

        function uciToSan(uciMove, fenOverride) {
          if (!uciMove) return null;
          try {
            const baseFen = fenOverride || (game ? game.fen() : null);
            if (!baseFen) return null;
            const temp = new Chess(baseFen);
            const moveObj = { from: uciMove.substring(0, 2), to: uciMove.substring(2, 4) };
            if (uciMove.length > 4) moveObj.promotion = uciMove[4];
            const result = temp.move(moveObj);
            return result ? result.san : null;
          } catch (err) {
            return null;
          }
        }

        function clearBestMoveHighlight() {
          bestMoveAnalysisToken++;
          bestMoveActiveToken = 0;
          cancelBestMoveWatchdog();
          cancelPendingBestMoveUpdates();
          resetBestMoveVisualState();
          lastBestMoveUpdate = 0;
          bestMoveFen = null;
          bestMoveFenNormalized = null;
          if (engineWorker) engineWorker.postMessage('stop');
          if (bestMoveSquares) {
            bestMoveSquares.forEach(sq => {
              $('#board .square-' + sq).css('box-shadow', '');
            });
            bestMoveSquares = null;
          }
          if (arrowCtx && arrowCanvas) arrowCtx.clearRect(0, 0, arrowCanvas.width, arrowCanvas.height);
          lastBestMove = null;
          hideBestMoveEvalDisplay();
        }

        function ensureArrowCanvas() {
          const boardEl = document.getElementById('board');
          if (!boardEl) return;
          if (!arrowCanvas) {
            arrowCanvas = document.createElement('canvas');
            arrowCanvas.id = 'best-move-arrow';
            arrowCanvas.style.position = 'absolute';
            arrowCanvas.style.top = '0';
            arrowCanvas.style.left = '0';
            arrowCanvas.style.pointerEvents = 'none';
            boardEl.style.position = 'relative';
            boardEl.appendChild(arrowCanvas);
            arrowCtx = arrowCanvas.getContext('2d');
          }
          arrowCanvas.width = boardEl.clientWidth;
          arrowCanvas.height = boardEl.clientHeight;
        }

        function drawBestMoveArrow(from, to) {
          ensureArrowCanvas();
          if (!arrowCtx) return;
          arrowCtx.clearRect(0, 0, arrowCanvas.width, arrowCanvas.height);
          const boardEl = document.getElementById('board');
          const boardRect = boardEl.getBoundingClientRect();
          const fromEl = document.querySelector('#board .square-' + from);
          const toEl = document.querySelector('#board .square-' + to);
          if (!fromEl || !toEl) return;
          const fromRect = fromEl.getBoundingClientRect();
            const toRect = toEl.getBoundingClientRect();
            const fx = fromRect.left + fromRect.width / 2 - boardRect.left;
            const fy = fromRect.top + fromRect.height / 2 - boardRect.top;
            const tx = toRect.left + toRect.width / 2 - boardRect.left;
            const ty = toRect.top + toRect.height / 2 - boardRect.top;
            const baseLineWidth = arrowCanvas.width / 35;
            const lineWidth = Math.max(2, baseLineWidth * (2 / 3));
            const baseHeadlen = arrowCanvas.width / 10;
            const headlen = Math.max(8, baseHeadlen * (2 / 3));
            arrowCtx.strokeStyle = 'rgb(255, 255, 0)';
            arrowCtx.fillStyle = 'rgb(255, 255, 0)';
            arrowCtx.lineWidth = lineWidth;
            arrowCtx.lineCap = 'butt';
            arrowCtx.lineJoin = 'miter';
            const angle = Math.atan2(ty - fy, tx - fx);
            arrowCtx.beginPath();
            arrowCtx.moveTo(fx, fy);
            arrowCtx.lineTo(
                tx - headlen * Math.cos(angle),
                ty - headlen * Math.sin(angle)
            );
            arrowCtx.stroke();
            arrowCtx.beginPath();
            arrowCtx.moveTo(tx, ty);
            arrowCtx.lineTo(tx - headlen * Math.cos(angle - Math.PI / 6), ty - headlen * Math.sin(angle - Math.PI / 6));
            arrowCtx.lineTo(tx - headlen * Math.cos(angle + Math.PI / 6), ty - headlen * Math.sin(angle + Math.PI / 6));
            arrowCtx.closePath();
            arrowCtx.fill();
        }

        function highlightBestMoveSquares(from, to) {
          ensureArrowCanvas();
          if (!arrowCanvas) return;
          const baseBorder = arrowCanvas.width / 35;
          const borderWidth = Math.max(2, baseBorder * (2 / 3));
          const color = 'rgb(255, 255, 0)';
          [from, to].forEach(sq => {
            $('#board .square-' + sq).css('box-shadow', `inset 0 0 0 ${borderWidth}px ${color}`);
          });
          bestMoveSquares = [from, to];
        }

        function showBestMoveForCurrentPosition() {
          cancelBestMoveWatchdog();
          if (!showBestMove || !engineReady) return;
          if (!game) return;
          resetBestMoveVisualState();
          const legalMoves = game.moves();
          if (!Array.isArray(legalMoves) || legalMoves.length === 0) {
            resetBestMoveVisualState();
            hideBestMoveEvalDisplay();
            return;
          }
          const fen = game.fen();
          if (!fen) return;
          bestMoveActiveToken = 0;
          cancelPendingBestMoveUpdates();
          lastBestMoveUpdate = 0;
          bestMoveFen = null;
          bestMoveFenNormalized = null;
          if (engineWorker) engineWorker.postMessage('stop');
          const token = ++bestMoveAnalysisToken;
          const targetNormalizedFen = normalizeFenForComparison(fen);
          setTimeout(() => {
            if (!showBestMove) return;
            if (!game) return;
            const currentFen = game.fen();
            if (!currentFen) return;
            const currentNormalized = normalizeFenForComparison(currentFen);
            if (currentNormalized !== targetNormalizedFen) return;
            bestMoveActiveToken = token;
            bestMoveFen = currentFen;
            bestMoveFenNormalized = currentNormalized;
            showBestMoveAnalyzingDisplay();
            if (engineWorker) {
              engineWorker.postMessage('position fen ' + currentFen);
              engineWorker.postMessage('go infinite');
            }
            scheduleBestMoveResponseTimer(token);
            scheduleBestMoveStallTimer(token);
          }, 0);
        }

        function handleExplorationPositionChanged() {
          updateEvalGraphInteractivity();
          if (!isExploring()) {
            syncNavigationControls();
            return;
          }
          $('.move-item').removeClass('highlight');
          renderEvalGraph(-1);
          clearBestMoveHighlight();
          if (showBestMove) {
            showBestMoveAnalyzingDisplay();
            showBestMoveForCurrentPosition();
          }
          syncNavigationControls();
        }

      $('#copy-stockfish-btn').on('click', function () {
        if (!copyStockfishBtn.length || copyStockfishBtn.prop('disabled')) return;
        navigator.clipboard.writeText($('#stockfish-output').val()).then(function(){
          copyStockfishBtn.text('Copied!');
          setTimeout(function(){ copyStockfishBtn.text(defaultCopyLabel); }, 1600);
        });
      });

      $('#goto-step3-btn').on('click', function(){ switchStep(3); });

      // ====== Step 3: accept PGN or comments-only and build review ======
      $('#generate-review-btn').on('click', function () {
        currentReviewMetadata = null;
        lastFinalAnalysisText = '';
        updateArchiveControls();
        let finalAnalysisRaw = $('#final-analysis-input').val().trim();
        if (!finalAnalysisRaw) {
          if (automatedReviewText) {
            finalAnalysisRaw = automatedReviewText.trim();
            $('#final-analysis-input').val(finalAnalysisRaw);
          } else {
            showError('Please paste the final analysis.');
            return;
          }
        }
        let pgn = normalizePgn(finalAnalysisRaw); let loaded = game.load_pgn(pgn);
        const parsed = parseAnalysis(finalAnalysisRaw);
        let invalidMove = null;
        if (!loaded && parsed.moves.length) {
          const sanList = parsed.moves.map(m => m.san);
          let rebuiltPGN = buildPGNFromSAN(sanList) + ' *';
          game.reset(); loaded = game.load_pgn(rebuiltPGN);
          if (!loaded) {
            invalidMove = findInvalidMove(sanList);
          } else {
            pgn = rebuiltPGN;
          }
        }
        if (!loaded) {
          if (invalidMove) showError('Illegal move "' + invalidMove.san + '" at position ' + invalidMove.index + '.');
          else showError('Could not find or reconstruct a valid PGN from the text you pasted.');
          return;
        }

        updatePlayerOutcomeFromGame(game);
        lastFinalAnalysisText = finalAnalysisRaw;

        const rawNameForReview = getRawPlayerNameInput();
        if (rawNameForReview) {
          updateReviewPlayerColorFromGame(game, rawNameForReview);
        }

        switchStep(4);

        const headersSnapshot = game && typeof game.header === 'function' ? { ...game.header() } : {};
        const pgnSnapshot = game && typeof game.pgn === 'function' ? game.pgn({ max_width: 0, newline_char: '\n' }) : '';
        const playerNameValue = getPlayerName();

        const gameMoves = game.history({ verbose: true }); let cursor = 0;
        const autoMoves = (Array.isArray(automatedMoveInsights.moves) && automatedMoveInsights.moves.length === gameMoves.length)
          ? automatedMoveInsights.moves
          : [];
        const hasAutomatedMoves = autoMoves.length > 0;
        let runningProb = autoMoves.length && autoMoves[0] && autoMoves[0].whiteProbBefore != null
          ? autoMoves[0].whiteProbBefore
          : 0.5;
        movesWithAnalysis = gameMoves.map((m, index) => {
          let analysis = null;
          if (cursor < parsed.moves.length && parsed.moves[cursor].san !== m.san) {
            const found = parsed.moves.findIndex((pm, idx) => idx >= cursor && pm.san === m.san);
            if (found !== -1) cursor = found;
          }
          if (cursor < parsed.moves.length && parsed.moves[cursor].san === m.san) analysis = parsed.moves[cursor++];

          const autoMove = hasAutomatedMoves ? (autoMoves[index] || null) : null;
          const baseProb = (autoMove && autoMove.whiteProbBefore != null)
            ? autoMove.whiteProbBefore
            : (runningProb == null ? 0.5 : runningProb);
          let prob = null;
          let moverDelta = null;
          let whiteDelta = null;

          if (analysis) {
            if (analysis.delta != null) {
              const swing = analysis.delta * (m.color === 'w' ? 1 : -1);
              whiteDelta = swing;
              const newProb = clampProb(baseProb + swing / 100);
              runningProb = newProb;
              prob = newProb;
              moverDelta = analysis.delta;
            } else {
              let targetProb = analysis.prob;
              if (targetProb == null && analysis.mate != null) {
                if (analysis.mate > 0) targetProb = 1;
                else if (analysis.mate < 0) targetProb = 0;
              }
              if (targetProb != null) {
                targetProb = clampProb(targetProb);
                whiteDelta = (targetProb - baseProb) * 100;
                moverDelta = whiteDelta * (m.color === 'w' ? 1 : -1);
                runningProb = targetProb;
                prob = targetProb;
              }
            }
          }

          if (!analysis && autoMove) {
            if (autoMove.whiteProbAfter != null) {
              prob = autoMove.whiteProbAfter;
              runningProb = autoMove.whiteProbAfter;
            }
            if (autoMove.moverDelta != null && moverDelta == null) moverDelta = autoMove.moverDelta;
            if (whiteDelta == null) {
              if (autoMove.whiteDelta != null) {
                whiteDelta = autoMove.whiteDelta;
              } else if (autoMove.whiteProbBefore != null && autoMove.whiteProbAfter != null) {
                whiteDelta = (autoMove.whiteProbAfter - autoMove.whiteProbBefore) * 100;
              }
            }
          }

          if (prob == null) {
            if (autoMove && autoMove.whiteProbAfter != null) {
              prob = autoMove.whiteProbAfter;
            } else {
              prob = runningProb == null ? baseProb : runningProb;
            }
          }
          if (prob != null) runningProb = prob;

          if (moverDelta == null && autoMove && autoMove.moverDelta != null) {
            moverDelta = autoMove.moverDelta;
          }
          if (whiteDelta == null && autoMove) {
            if (autoMove.whiteDelta != null) whiteDelta = autoMove.whiteDelta;
            else if (autoMove.whiteProbBefore != null && autoMove.whiteProbAfter != null) {
              whiteDelta = (autoMove.whiteProbAfter - autoMove.whiteProbBefore) * 100;
            }
          }

          let displayEvaluation = null;
          if (analysis) {
            const evalKind = analysis.kind;
            const originalEval = analysis.evaluation;
            if (evalKind === 'mate') {
              if (originalEval) displayEvaluation = originalEval;
              else if (analysis.mate != null) displayEvaluation = `{#${analysis.mate}}`;
            } else if (analysis.delta != null || evalKind === 'percent' || evalKind === 'cp') {
              const probForDisplay = prob != null ? prob : (analysis.prob != null ? clampProb(analysis.prob) : null);
              if (probForDisplay != null) {
                displayEvaluation = formatProbBraced(probForDisplay);
              }
            }

            if (!displayEvaluation && originalEval) {
              displayEvaluation = originalEval;
            } else if (!displayEvaluation && whiteDelta != null) {
              displayEvaluation = formatDeltaBraced(whiteDelta);
            } else if (!displayEvaluation && analysis.delta != null) {
              displayEvaluation = formatDeltaBraced(analysis.delta);
            }

            analysis.displayEvaluation = displayEvaluation;
          }

          if (!displayEvaluation && autoMove) {
            if (autoMove.evaluation) {
              displayEvaluation = autoMove.evaluation;
            } else if (Number.isFinite(autoMove.mateAfter)) {
              displayEvaluation = `{#${autoMove.mateAfter}}`;
            } else if (autoMove.whiteDelta != null) {
              displayEvaluation = formatDeltaBraced(autoMove.whiteDelta);
            }
          }

          let finalAnalysis = analysis ? { ...analysis } : null;
          if (autoMove) {
            if (!finalAnalysis) finalAnalysis = {};
            if (finalAnalysis.delta == null && autoMove.moverDelta != null) finalAnalysis.delta = autoMove.moverDelta;
            if (finalAnalysis.prob == null && autoMove.whiteProbAfter != null) finalAnalysis.prob = autoMove.whiteProbAfter;
            if (finalAnalysis.mate == null && Number.isFinite(autoMove.mateAfter)) finalAnalysis.mate = autoMove.mateAfter;
            const autoClass = autoMove.classification;
            if (autoClass) {
              if (finalAnalysis.classification && normalizeClassificationKey(finalAnalysis.classification) !== normalizeClassificationKey(autoClass)) {
                finalAnalysis.originalClassification = finalAnalysis.originalClassification || finalAnalysis.classification;
                finalAnalysis.classification = autoClass;
              } else if (!finalAnalysis.classification) {
                finalAnalysis.classification = autoClass;
              }
              finalAnalysis.automatedClassification = autoClass;
            }
            if (!finalAnalysis.displayEvaluation && displayEvaluation) {
              finalAnalysis.displayEvaluation = displayEvaluation;
            }
          } else if (finalAnalysis && displayEvaluation && !finalAnalysis.displayEvaluation) {
            finalAnalysis.displayEvaluation = displayEvaluation;
          }

          if (finalAnalysis && !finalAnalysis.text && !finalAnalysis.classification && finalAnalysis.delta == null && finalAnalysis.mate == null && !finalAnalysis.evaluation && !finalAnalysis.displayEvaluation && finalAnalysis.prob == null) {
            finalAnalysis = null;
          }

          const automated = autoMove ? { ...autoMove } : null;

          const displayEvalValue = displayEvaluation != null ? displayEvaluation : null;
          return { ...m, analysis: finalAnalysis, criticalMoment: parsed.criticalMoments[m.san], prob, delta: moverDelta, displayEvaluation: displayEvalValue, automated };
        });
        probSeries = movesWithAnalysis.map(m => m.prob);

        // Summary text
        const autoSummary = hasAutomatedMoves ? buildAutomatedSummaryLine(automatedMoveInsights.summary) : '';
        const summary = parsed.summary || autoSummary || '';
        if (summary) {
          $('#game-summary').removeClass('hidden').html(formatSummaryLine(summary));
        } else {
          $('#game-summary').addClass('hidden').html('');
        }

        featuredMoveData = parsed.featuredMove || null;
        featuredMoveIndex = -1;
        if (featuredMoveData) {
          const idx = findFeaturedMoveIndex(movesWithAnalysis, featuredMoveData);
          if (idx >= 0) {
            const meta = { ...featuredMoveData, index: idx };
            featuredMoveData = meta;
            featuredMoveIndex = idx;
            movesWithAnalysis[idx].isFeatured = true;
            movesWithAnalysis[idx].featuredMeta = meta;
          }
        }
        if (!featuredMoveData && hasAutomatedMoves && automatedMoveInsights.moveOfGame) {
          const autoFeatured = convertAutomatedMoveToFeatured(automatedMoveInsights.moveOfGame);
          if (autoFeatured) {
            const idx = typeof autoFeatured.index === 'number' ? autoFeatured.index : -1;
            if (idx >= 0 && idx < movesWithAnalysis.length) {
              const meta = { ...autoFeatured, index: idx };
              featuredMoveData = meta;
              featuredMoveIndex = idx;
              movesWithAnalysis[idx].isFeatured = true;
              movesWithAnalysis[idx].featuredMeta = meta;
            }
          }
        }
        renderFeaturedMoveSummary();

        if (!board) {
          board = Chessboard('board', {
            position: 'start',
            draggable: false,
            pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
          });
          $('#board').on('click', '.square-55d63', function(){ handleSquareClick($(this).data('square')); });
          $(window).on('resize', function(){
            board.resize();
            adjustAnalysisHeight();
            resizeEvalGraph();
            if (showBestMove && lastBestMove) {
              const from = lastBestMove.substring(0,2);
              const to = lastBestMove.substring(2,4);
              drawBestMoveArrow(from, to);
              highlightBestMoveSquares(from, to);
            }
          });
          initEvalGraph();
        }

        board.position('start');
        game.reset();
        currentMoveIndex = -1;
        clearExploration(true);
        renderMoveList();
        adjustAnalysisHeight();
        board.resize();
        resizeEvalGraph();
        renderEvalGraph(-1);

        const opponentLabel = deriveOpponentFromHeaders(headersSnapshot, reviewPlayerColor, playerNameValue);
        currentReviewMetadata = {
          headers: headersSnapshot,
          summary,
          playerColor: reviewPlayerColor,
          playerName: playerNameValue,
          opponent: opponentLabel,
          annotatedPgn: lastAnnotatedPgn,
          stockfishOutput: $('#stockfish-output').val() || '',
          pgn: pgnSnapshot,
          resultCode: headersSnapshot.Result || '',
          resultLabel: describeResult(headersSnapshot.Result || ''),
          movesCount: movesWithAnalysis.length,
          featuredMove: featuredMoveData ? { ...featuredMoveData } : null
        };
        updateArchiveControls();
        if (pendingArchiveLoadNotice) {
          showArchiveFeedback(`Loaded saved review "${pendingArchiveLoadNotice}".`, 'success');
          pendingArchiveLoadNotice = null;
        }
      });

      // Build PGN from SAN list
      function buildPGNFromSAN(sanList) { const parts = []; for (let i = 0; i < sanList.length; i++) { const n = Math.floor(i / 2) + 1; if (i % 2 === 0) parts.push(n + '. ' + sanList[i]); else parts.push(sanList[i]); } return parts.join(' '); }

      // Find first illegal move using PGN loading to avoid strict per-move checks
      function findInvalidMove(sanList) {
        const temp = new Chess();
        for (let i = 0; i < sanList.length; i++) {
          const prefix = buildPGNFromSAN(sanList.slice(0, i + 1)) + ' *';
          temp.reset();
          if (!temp.load_pgn(prefix)) return { san: sanList[i], index: i + 1 };
        }
        return null;
      }

      // Parse analysis lines with optional {eval} and final Summary:
      function parseAnalysis(text) {
        const lines = text.split('\n'); const parsedMoves = []; const criticalMoments = {}; const summaries = {}; let currentSummary = null; let lastSan = null; let summaryLine = ''; let inSummary = false; let featuredMove = null;
        const moveRegex = /^(?:\d+\.{1,3}\s*)?(\S+)(?:\s*[-–—]\s*)?(?:\s*(\{[^}]+\}))?\s*([A-Za-z0-9!?\'"()\-\s]+?)\s*:\s*(.*)/;
        const criticalMomentRegex = /^Critical Moment:\s*(.*)/i;
        const summaryHeaderRegex = /^\s*\*\*(Strengths|Recurring Mistakes|Top 3 Takeaways)\*\*/i;
        // Allow leading whitespace before "Summary:" to handle AI outputs
        // that may indent or space the final summary line.
        const summaryLineRegex = /^\s*Summary[^:]*:\s*(.*)/i;
        const moveOfGameRegex = /^\s*Move of the game:\s*((?:\d+\.{1,3}\s*|\.{3}\s*)?)(\S+)(?:\s*(?:[-–—]\s*)?(\{[^}]+\}))?\s*([A-Za-z0-9!?\'"()\-\s]+?):\s*(.*)$/i;

        function assignFeatured(match) {
          if (!match) return false;
          if (featuredMove) return true;
          const prefixRaw = match[1] || '';
          const rawSan = match[2] || '';
          const combinedSan = prefixRaw + rawSan;
          let san = normalizeSanToken(combinedSan);
          if (!san) san = normalizeSanToken(rawSan);
          if (!san) san = rawSan.trim();
          if (!san) return true;
          const needsSpace = prefixRaw && rawSan && !/\s$/.test(prefixRaw) ? ' ' : '';
          let displaySan = rawSan.trim();
          if (prefixRaw) {
            displaySan = (prefixRaw + needsSpace + rawSan).trim();
          }
          if (!displaySan) displaySan = san;
          const evaluation = (match[3] || '').trim() || null;
          const classification = (match[4] || '').trim();
          const justification = (match[5] || '').trim();
          const evalInfo = parseEvaluationToken(evaluation);
          featuredMove = { san, displaySan, evaluation, classification, text: justification, ...evalInfo };
          return true;
        }

        lines.forEach(line => {
          const trimmed = line.trim();
          if (inSummary) {
            if (!trimmed) return;
            if (assignFeatured(line.match(moveOfGameRegex))) { inSummary = false; return; }
            summaryLine += ' ' + trimmed;
            return;
          }
          const sl = line.match(summaryLineRegex);
          if (sl) { summaryLine = sl[1].trim(); inSummary = true; return; }
          if (assignFeatured(line.match(moveOfGameRegex))) return;
          const m = line.match(moveRegex);
          if (m) {
            const rawSan = m[1];
            const san = normalizeSanToken(rawSan) || rawSan.trim();
            const evaluation = (m[2] || '').trim() || null;
            const classification = m[3].trim();
            const txt = m[4].trim();
            const evalInfo = parseEvaluationToken(evaluation);
            parsedMoves.push({ san, evaluation, classification, ...evalInfo, text: txt, displaySan: rawSan.trim() });
            lastSan = san; currentSummary = null; return;
          }
          const cm = line.match(criticalMomentRegex); if (cm && lastSan) { criticalMoments[lastSan] = cm[1]; return; }
          const sh = line.match(summaryHeaderRegex); if (sh) { const key = sh[1].replace(/\s/g,''); summaries[key] = []; currentSummary = key; return; }
          if (trimmed && trimmed !== '---' && currentSummary) summaries[currentSummary].push(trimmed);
        });
        return { moves: parsedMoves, criticalMoments, summaries, summary: summaryLine, featuredMove };
      }

      // Convert evaluation string like "{+0.23}", "{-1.10}", "{#3}" (WHITE-relative already)
      function parseEvalToCp(evalStr) { if (!evalStr) return null; const s = String(evalStr).replace(/[{}\s]/g,''); if (!s) return null; if (s[0] === '#') return s.includes('-') ? -999 : 999; const num = parseFloat(s); if (isNaN(num)) return null; return Math.round(num * 100); }

      function parseEvaluationToken(evalStr) {
        const info = { prob: null, delta: null, mate: null, kind: null };
        if (!evalStr) return info;
        const s = String(evalStr).replace(/[{}\s]/g, '');
        if (!s) return info;
        if (s[0] === '#') {
          const mateNum = parseInt(s.slice(1), 10);
          if (!Number.isNaN(mateNum)) {
            info.mate = mateNum;
            if (mateNum > 0) info.prob = 1;
            else if (mateNum < 0) info.prob = 0;
            else info.prob = null;
            info.kind = 'mate';
          }
          return info;
        }
        if (s.endsWith('%')) {
          const num = parseFloat(s.slice(0, -1));
          if (!Number.isNaN(num)) {
            info.prob = num / 100;
            info.kind = 'percent';
          }
          return info;
        }
        const num = parseFloat(s);
        if (!Number.isNaN(num)) {
          info.delta = num;
          info.kind = 'delta';
          return info;
        }
        const cp = parseEvalToCp(evalStr);
        if (cp != null) {
          info.prob = cpToProb(cp);
          info.kind = 'cp';
        }
        return info;
      }

      // ====== Rendering ======
      function buildEvaluationSegments(mv) {
        const segments = [];
        if (!mv) return segments;
        let mateDisplay = '';
        if (mv.analysis && mv.analysis.kind === 'mate') {
          const mateStr = mv.analysis.displayEvaluation || mv.displayEvaluation || mv.analysis.evaluation;
          if (mateStr) {
            mateDisplay = '<span class="font-mono text-xs text-yellow-300">' + mateStr + '</span>';
            segments.push(mateDisplay);
          }
        }
        const whiteProbSource = mv.prob != null ? mv.prob : (mv.analysis ? mv.analysis.prob : null);
        if (!mateDisplay) {
          const whiteProbHtml = formatWhiteWinProbDisplay(whiteProbSource);
          if (whiteProbHtml) segments.push(whiteProbHtml);
        }
        const moverDeltaSource = mv.delta != null
          ? mv.delta
          : (mv.analysis && mv.analysis.delta != null ? mv.analysis.delta : null);
        const moverDeltaHtml = formatMoverDeltaIndicator(moverDeltaSource);
        if (moverDeltaHtml) segments.push(moverDeltaHtml);
        if (!segments.length) {
          let fallbackEval = mv.displayEvaluation;
          if (!fallbackEval && mv.analysis && mv.analysis.displayEvaluation) fallbackEval = mv.analysis.displayEvaluation;
          if (!fallbackEval && mv.analysis && mv.analysis.evaluation) fallbackEval = mv.analysis.evaluation;
          if (!fallbackEval && mv.delta != null) fallbackEval = formatDeltaBraced(mv.delta);
          if (fallbackEval) {
            segments.push('<span class="font-mono text-xs text-gray-400">' + fallbackEval + '</span>');
          }
        }
        return segments;
      }

      function normalizeEvaluationString(value) {
        if (!value) return '';
        return String(value).replace(/[{}\s]/g, '').toLowerCase();
      }

      function findFeaturedMoveIndex(list, featured) {
        if (!featured || !Array.isArray(list) || !list.length) return -1;
        let targetSan = normalizeSanToken(featured.san);
        if (!targetSan && featured.displaySan) targetSan = normalizeSanToken(featured.displaySan);
        if (!targetSan) return -1;
        const targetClass = normalizeClassificationKey(featured.classification);
        const targetEval = normalizeEvaluationString(featured.evaluation);
        const matchesBase = mv => {
          if (!mv) return false;
          if (mv.analysis && normalizeSanToken(mv.analysis.san) === targetSan) return true;
          return normalizeSanToken(mv.san) === targetSan;
        };
        const matchesClass = mv => matchesBase(mv) && mv.analysis && (!targetClass || normalizeClassificationKey(mv.analysis.classification) === targetClass);
        const matchesEval = mv => {
          if (!targetEval || !matchesClass(mv)) return false;
          const candidates = [
            mv.analysis ? mv.analysis.evaluation : null,
            mv.analysis ? mv.analysis.displayEvaluation : null,
            mv.displayEvaluation
          ];
          return candidates.some(candidate => normalizeEvaluationString(candidate) === targetEval);
        };
        let idx = -1;
        if (targetEval) idx = list.findIndex(matchesEval);
        if (idx === -1 && targetClass) idx = list.findIndex(matchesClass);
        if (idx === -1) idx = list.findIndex(matchesBase);
        return idx;
      }

      function renderFeaturedMoveSummary() {
        const container = $('#featured-move');
        if (!container.length) return;
        container.addClass('hidden').empty();
        if (!featuredMoveData) return;
        const idxFromData = typeof featuredMoveData.index === 'number' ? featuredMoveData.index : -1;
        const idx = (idxFromData >= 0 && idxFromData < movesWithAnalysis.length)
          ? idxFromData
          : ((featuredMoveIndex >= 0 && featuredMoveIndex < movesWithAnalysis.length) ? featuredMoveIndex : -1);
        const move = idx >= 0 ? movesWithAnalysis[idx] : null;
        const evaluationSegments = move ? buildEvaluationSegments(move) : [];
        let displaySan = featuredMoveData.displaySan || featuredMoveData.san;
        if (move) {
          const moveNumber = Math.floor(idx / 2) + 1;
          const prefix = move.color === 'w' ? moveNumber + '. ' : moveNumber + '... ';
          displaySan = prefix + move.san;
        }
        let evaluationHtml = '';
        if (evaluationSegments.length) {
          evaluationHtml = '<div class="flex items-center gap-2 text-xs sm:text-sm flex-wrap">' + evaluationSegments.join('') + '</div>';
        } else if (featuredMoveData.evaluation) {
          evaluationHtml = '<span class="font-mono text-xs text-yellow-300">' + featuredMoveData.evaluation + '</span>';
        }
        const classificationClass = getStyleForClassification(featuredMoveData.classification) || '';
        const classificationHtml = featuredMoveData.classification
          ? '<span class="ml-auto px-2 py-0.5 text-xs font-semibold uppercase tracking-wide rounded border border-yellow-500/40 bg-yellow-500/10 ' + classificationClass + '">' + featuredMoveData.classification + '</span>'
          : '';
        const justificationHtml = featuredMoveData.text
          ? '<p class="mt-2 text-sm text-gray-200">' + formatText(featuredMoveData.text) + '</p>'
          : '';
        const isClickable = !!move;
        const tag = isClickable ? 'button' : 'div';
        const attrs = isClickable ? ' type="button" data-move-index="' + idx + '"' : '';
        const baseClasses = 'w-full text-left p-3 sm:p-4 rounded-lg border border-yellow-500/40 bg-yellow-500/10' + (isClickable ? ' hover:bg-yellow-500/20 transition cursor-pointer focus:outline-none focus:ring-2 focus:ring-yellow-400/60' : ' opacity-90');
        const headerParts = [
          '<span class="text-xs uppercase tracking-wide text-yellow-300 font-semibold">Move of the game</span>',
          '<span class="font-bold text-lg text-white">' + displaySan + '</span>'
        ];
        if (evaluationHtml) headerParts.push(evaluationHtml);
        if (classificationHtml) headerParts.push(classificationHtml);
        const headerHtml = '<div class="flex items-center gap-3 flex-wrap sm:flex-nowrap">' + headerParts.join('') + '</div>';
        container.removeClass('hidden').html('<' + tag + attrs + ' class="' + baseClasses + '">' + headerHtml + justificationHtml + '</' + tag + '>');
        if (isClickable) {
          container.find('button[data-move-index]').on('click', function(){
            const targetIdx = Number($(this).data('move-index'));
            if (Number.isNaN(targetIdx)) return;
            clearExploration();
            goToMove(targetIdx);
          });
        }
      }

      function renderMoveList() {
        const c = $('#move-analysis-container').empty();
        movesWithAnalysis.forEach((mv, i) => {
          const n = mv.color === 'w' ? (Math.floor(i / 2) + 1) + '.' : '';
          const evalSegments = buildEvaluationSegments(mv);
          const evalHtml = evalSegments.length ? '<div class="flex items-center gap-2 ml-2">' + evalSegments.join('') + '</div>' : '';
          const moveClasses = ['move-item', 'p-2', 'cursor-pointer'];
          if (mv.isFeatured) moveClasses.push('featured');
          const classificationHtml = mv.analysis
            ? '<span class="font-semibold text-sm ml-2 ' + getStyleForClassification(mv.analysis.classification) + '">' + mv.analysis.classification + '</span>'
            : '';
          const badgeHtml = mv.isFeatured
            ? '<span class="ml-auto text-xs uppercase tracking-wide text-yellow-300 font-semibold">Move of the Game</span>'
            : '';
          const commentHtml = (mv.analysis && mv.analysis.text)
            ? '<p class="pl-12 text-gray-300 text-sm">' + formatText(mv.analysis.text) + '</p>'
            : '';
          const html =
            '<div class="' + moveClasses.join(' ') + '" data-move-index="' + i + '">' +
              '<div class="flex items-baseline gap-3">' +
                '<span class="text-gray-500 font-mono w-8 text-right">' + n + '</span>' +
                '<span class="font-bold text-lg text-white">' + mv.san + '</span>' +
                evalHtml +
                classificationHtml +
                badgeHtml +
              '</div>' +
              commentHtml +
              (mv.criticalMoment ? '<p class="pl-12 mt-1 text-xs text-yellow-300 bg-yellow-900/40 p-2 rounded">' + formatText('Critical Moment: ' + mv.criticalMoment) + '</p>' : '') +
            '</div>';
          c.append(html);
        });
        $('.move-item').on('click', function(){
          const idx = Number($(this).data('move-index'));
          if (Number.isNaN(idx)) return;
          clearExploration();
          goToMove(idx);
        });
      }

      function adjustAnalysisHeight() {
        const scroll = document.getElementById('move-analysis-scroll');
        if (!scroll) return;
        const boardEl = document.getElementById('board');
        const controls = document.getElementById('controls');
        const graphEl = document.getElementById('eval-graph');
        const isPortrait = window.matchMedia ? window.matchMedia('(orientation: portrait)').matches : false;
        const isNarrow = window.innerWidth < 1024;
        if (isPortrait || isNarrow) {
          scroll.style.height = '';
          scroll.style.maxHeight = '';
          return;
        }
        let boardHeight = 0;
        if (boardEl) {
          const boardRect = boardEl.getBoundingClientRect();
          boardHeight = boardRect.height || boardRect.width || boardEl.clientHeight || boardEl.clientWidth || 0;
        }
        let graphHeight = 0;
        if (graphEl) {
          const graphRect = graphEl.getBoundingClientRect();
          graphHeight = graphRect.height || graphEl.offsetHeight || 0;
        }
        let controlsHeight = 0;
        if (controls) {
          const controlsRect = controls.getBoundingClientRect();
          controlsHeight = controlsRect.height || controls.offsetHeight || 0;
        }
        let total = boardHeight + graphHeight + controlsHeight;
        if (!Number.isFinite(total) || total <= 0) {
          total = boardEl && boardEl.clientWidth ? boardEl.clientWidth + (graphEl ? graphEl.offsetHeight || 0 : 0) : 0;
        }
        total = Math.max(200, Math.round(total + 24));
        scroll.style.height = total + 'px';
        scroll.style.maxHeight = total + 'px';
      }

      function updateEvalGraphInteractivity() {
        if (!evalCanvas) return;
        if (isExploring()) {
          evalCanvas.classList.add('exploration-disabled');
        } else {
          evalCanvas.classList.remove('exploration-disabled');
        }
      }

      function initEvalGraph() {
        evalCanvas = document.getElementById('eval-graph');
        if (!evalCanvas) return;
        evalCtx = evalCanvas.getContext('2d');
        evalCanvas.addEventListener('click', function(e) {
          if (isExploring()) {
            clearExploration();
          }
          const rect = evalCanvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const maxIdx = Math.max(probSeries.length - 1, 0);
          const idx = Math.round((x / evalCanvas.width) * maxIdx);
          goToMove(idx);
        });
        updateEvalGraphInteractivity();
        resizeEvalGraph();
      }

      function resizeEvalGraph() {
        if (!evalCanvas) return;
        const boardEl = document.getElementById('board');
        if (boardEl) evalCanvas.width = boardEl.clientWidth;
        evalCanvas.height = 60;
        renderEvalGraph(currentMoveIndex);
      }

      function renderEvalGraph(idx) {
        if (!evalCanvas || !evalCtx) return;
        const w = evalCanvas.width;
        const h = evalCanvas.height;
        evalCtx.clearRect(0, 0, w, h);
        const baselineY = h / 2;
        evalCtx.fillStyle = '#f9fafb';
        evalCtx.fillRect(0, 0, w, h);

        const hasProbSeries = probSeries.length > 0;
        let xPoints = [];
        let yPoints = [];

        if (hasProbSeries) {
          const maxIdx = Math.max(probSeries.length - 1, 1);
          const values = probSeries.map(p => {
            if (p == null) return null;
            const clamped = clampProb(p);
            if (clamped == null) return null;
            return (clamped - 0.5) * 100;
          });
          const validValues = values.filter(v => v != null);
          const scale = validValues.length ? Math.max(50, ...validValues.map(v => Math.abs(v))) : 50;

          xPoints = new Array(values.length);
          yPoints = new Array(values.length);
          let lastVal = 0;
          values.forEach((rawVal, i) => {
            let val = rawVal;
            if (val == null) val = lastVal;
            else lastVal = val;
            const x = (i / maxIdx) * w;
            const y = baselineY - (val / scale) * (h / 2);
            xPoints[i] = x;
            yPoints[i] = y;
          });

          if (values.length > 0) {
            evalCtx.fillStyle = '#0b0e15';
            evalCtx.beginPath();
            evalCtx.moveTo(0, 0);
            evalCtx.lineTo(w, 0);
            for (let i = values.length - 1; i >= 0; i--) {
              evalCtx.lineTo(xPoints[i], yPoints[i]);
            }
            evalCtx.closePath();
            evalCtx.fill();
          }

          if (values.length > 0 && Array.isArray(movesWithAnalysis) && movesWithAnalysis.length === xPoints.length) {
            for (let i = 0; i < movesWithAnalysis.length; i++) {
              const move = movesWithAnalysis[i];
              const classificationKey = move && move.analysis
                ? normalizeClassificationKey(move.analysis.classification)
                : '';
              if (!highlightedGraphClassifications.has(classificationKey)) continue;
              const color = classificationMarkerColors[classificationKey] || '#fbbf24';
              const x = xPoints[i];
              evalCtx.save();
              evalCtx.strokeStyle = color;
              evalCtx.lineWidth = 1.5;
              evalCtx.globalAlpha = 0.9;
              evalCtx.beginPath();
              evalCtx.moveTo(x, 0);
              evalCtx.lineTo(x, h);
              evalCtx.stroke();
              evalCtx.restore();
            }
          }
        } else {
          evalCtx.fillStyle = '#0b0e15';
          evalCtx.fillRect(0, 0, w, baselineY);
          evalCtx.fillStyle = '#f9fafb';
          evalCtx.fillRect(0, baselineY, w, baselineY);
        }

        evalCtx.strokeStyle = '#facc15';
        evalCtx.lineWidth = 1.2;
        evalCtx.beginPath();
        evalCtx.moveTo(0, baselineY);
        evalCtx.lineTo(w, baselineY);
        evalCtx.stroke();

        evalCtx.save();
        evalCtx.strokeStyle = 'rgba(250, 204, 21, 0.85)';
        evalCtx.lineWidth = 1.4;
        evalCtx.strokeRect(0.7, 0.7, w - 1.4, h - 1.4);
        evalCtx.restore();

        if (idx >= 0 && hasProbSeries) {
          const maxIdx = Math.max(probSeries.length - 1, 1);
          const x = (idx / maxIdx) * w;
          evalCtx.lineWidth = 1;
          evalCtx.strokeStyle = '#fbbf24';
          evalCtx.beginPath();
          evalCtx.moveTo(x, 0);
          evalCtx.lineTo(x, h);
          evalCtx.stroke();
        }
      }

      function ensureMoveVisible(idx) {
        const container = document.getElementById('move-analysis-scroll');
        const item = document.querySelector('.move-item[data-move-index="' + idx + '"]');
        if (!container || !item) return;
        const itemRect = item.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        if (itemRect.top < containerRect.top || itemRect.bottom > containerRect.bottom) {
          item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        if (window.innerWidth < 1024) {
          document.getElementById('move-analysis-shell').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }

      function syncNavigationControls() {
        const prevBtn = $('#prev-btn');
        const nextBtn = $('#next-btn');
        if (!prevBtn.length || !nextBtn.length) return;
        if (isExploring()) {
          const cursor = explorationState ? explorationState.cursor : 0;
          const total = explorationState ? explorationState.moves.length : 0;
          prevBtn.prop('disabled', cursor <= 0);
          nextBtn.prop('disabled', cursor >= total);
        } else {
          prevBtn.prop('disabled', currentMoveIndex < 0);
          nextBtn.prop('disabled', currentMoveIndex >= movesWithAnalysis.length - 1);
        }
      }

        function goToMove(idx) {
          if (idx < -1 || idx >= movesWithAnalysis.length) return;
          currentMoveIndex = idx;
          game.reset();
          for (let i = 0; i <= idx; i++) game.move(movesWithAnalysis[i].san);
          if (board) board.position(game.fen());
          $('.move-item').removeClass('highlight');
          if (idx >= 0) $('.move-item[data-move-index="' + idx + '"]').addClass('highlight');
          adjustAnalysisHeight();
          renderEvalGraph(idx);
          ensureMoveVisible(idx);
          clearBestMoveHighlight();
          if (showBestMove) {
            showBestMoveAnalyzingDisplay();
            showBestMoveForCurrentPosition();
          }
          syncNavigationControls();
        }

        $('#next-btn').on('click', function(){
          if (isExploring()) {
            if (!stepExploration(1)) return;
          } else {
            goToMove(currentMoveIndex + 1);
          }
        });
        $('#prev-btn').on('click', function(){
          if (isExploring()) {
            if (!stepExploration(-1)) return;
          } else {
            goToMove(currentMoveIndex - 1);
          }
        });
        $('#flip-btn').on('click', function(){
          if (board) {
            board.flip();
            if (showBestMove && lastBestMove) {
              const from = lastBestMove.substring(0,2);
              const to = lastBestMove.substring(2,4);
              drawBestMoveArrow(from, to);
              highlightBestMoveSquares(from, to);
            }
          }
        });
        $('#toggle-eval-btn').on('click', function(){
          showBestMove = !showBestMove;
          if (showBestMove) {
            showBestMoveAnalyzingDisplay();
            showBestMoveForCurrentPosition();
          } else {
            clearBestMoveHighlight();
          }
        });

        $(window).on('resize', function(){
          adjustAnalysisHeight();
          resizeEvalGraph();
          if (showBestMove && lastBestMove) {
            const from = lastBestMove.substring(0,2);
            const to = lastBestMove.substring(2,4);
            drawBestMoveArrow(from, to);
            highlightBestMoveSquares(from, to);
          }
        });
        $(document).on('keydown', function(e){
          if (!$('#review-section').is(':visible')) return;
          if (e.key === 'ArrowRight') {
            if (isExploring()) {
              stepExploration(1);
            } else {
              goToMove(currentMoveIndex + 1);
            }
          } else if (e.key === 'ArrowLeft') {
            if (isExploring()) {
              stepExploration(-1);
            } else {
              goToMove(currentMoveIndex - 1);
            }
          }
        });
      });
    </script>
</body>
</html>
