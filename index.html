<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>AI Chess Reviewer</title>

  <!-- Tailwind Play CDN (ok for prototypes) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css" crossorigin="anonymous">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
    body { font-family: 'Inter', sans-serif; background-color: #0f1115; color: #e5e7eb; }
    .chessboard-container { width: 100%; margin: 0 auto; aspect-ratio: 1 / 1; }
    .move-item { transition: background-color 0.2s ease-in-out; border-radius: 0.5rem; }
    .move-item.highlight { background-color: #243249; }
    .move-item:hover { background-color: #1c273a; }
    #move-analysis-scroll::-webkit-scrollbar { width: 8px; }
    #move-analysis-scroll::-webkit-scrollbar-track { background: #1a1f2a; }
    #move-analysis-scroll::-webkit-scrollbar-thumb { background-color: #4b5563; border-radius: 10px; border: 2px solid #1a1f2a; }
    .btn-primary { background-color: #3b82f6; transition: background-color 0.2s; }
    .btn-primary:hover { background-color: #2563eb; }
    .btn-primary:disabled { background-color: #374151; cursor: not-allowed; }
    .btn-secondary { background-color: #374151; transition: background-color: 0.2s; }
    .btn-secondary:hover { background-color: #4b5563; }
    textarea.form-input { background-color: #2d2d2d; border-color: #364152; color: #e5e7eb; }
    textarea.form-input:focus { border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.35); outline: none; }
    .step-indicator { background-color: #273043; }
    .step-indicator.active { background-color: #3b82f6; }
  </style>
</head>
<body class="min-h-screen flex flex-col p-3 sm:p-4">

  <!-- Header (hidden on final screen) -->
  <header id="app-header" class="text-center mb-6">
    <h1 class="text-2xl sm:text-3xl font-bold text-white">AI Chess Reviewer</h1>
    <p class="text-gray-400 mt-2">A new way to get deep, AI-powered analysis of your games.</p>
  </header>

  <!-- Step Indicators -->
  <div id="step-indicators" class="flex justify-center items-center space-x-3 mb-6">
    <div id="indicator-1" class="step-indicator active w-8 h-2 rounded-full"></div>
    <div id="indicator-2" class="step-indicator w-8 h-2 rounded-full"></div>
    <div id="indicator-3" class="step-indicator w-8 h-2 rounded-full"></div>
  </div>

  <!-- Step 1: PGN Input -->
  <section id="step1-section" class="max-w-2xl w-full mx-auto flex flex-col gap-4">
    <h2 class="text-xl sm:text-2xl font-bold text-center">Step 1: Analyze PGN with Stockfish</h2>
    <p class="text-center text-gray-400">Paste your game's PGN below. The engine will run in your browser to add move evaluations.</p>
    <div>
      <label for="pgn-input" class="block mb-2 font-semibold text-gray-300">Paste PGN here</label>
      <textarea id="pgn-input" rows="6" class="w-full p-3 rounded-lg form-input" placeholder="[Event &quot;...&quot;]..."></textarea>
    </div>
    <button id="analyze-pgn-btn" class="w-full py-3 px-6 text-lg font-semibold text-white rounded-lg btn-primary" disabled>
      Loading Engine...
    </button>
  </section>

  <!-- Step 2: Stockfish Output & AI Instructions -->
  <section id="step2-section" class="hidden max-w-2xl w-full mx-auto flex flex-col gap-4">
    <h2 class="text-xl sm:text-2xl font-bold text-center">Step 2: Get AI Coaching Comments</h2>
    <div id="stockfish-progress" class="text-center p-4 bg-[#101522] rounded-lg">
      <p id="progress-text" class="text-base sm:text-lg text-yellow-400">Initializing Stockfish...</p>
      <div class="w-full bg-gray-700 rounded-full h-2 mt-2">
        <div id="progress-bar" class="bg-blue-500 h-2 rounded-full" style="width: 0%"></div>
      </div>
    </div>
    <div>
      <label for="stockfish-output" class="block mb-2 font-semibold text-gray-300">1. Copy the prompt + annotated PGN below</label>
      <textarea id="stockfish-output" rows="7" class="w-full p-3 rounded-lg form-input font-mono text-sm" readonly></textarea>
      <button id="copy-stockfish-btn" class="w-full mt-2 py-2 px-4 font-semibold text-white rounded-lg btn-secondary">Copy to Clipboard</button>
    </div>
    <button id="goto-step3-btn" class="w-full py-3 px-6 text-lg font-semibold text-white rounded-lg btn-primary" disabled>
      Continue to Final Step
    </button>
  </section>

  <!-- Step 3: Final Analysis Input -->
  <section id="step3-section" class="hidden max-w-2xl w-full mx-auto flex flex-col gap-4">
    <h2 class="text-xl sm:text-2xl font-bold text-center">Step 3: Paste Your Final AI Review</h2>
    <p class="text-center text-gray-400">Paste the full text from the AI (PGN + comments) or just comments like <em>e4 - {53%} Good: ...</em>. The braces should contain win-probability percentages. Include the final line starting with <strong>Summary:</strong>.</p>
    <div>
      <label for="final-analysis-input" class="block mb-2 font-semibold text-gray-300">Paste complete analysis here</label>
      <textarea id="final-analysis-input" rows="6" class="w-full p-3 rounded-lg form-input" placeholder="e4 - {53%} Good: A classical opening move...\n...\nSummary: Black won after a decisive kingside attack."></textarea>
    </div>
    <button id="generate-review-btn" class="w-full py-3 px-6 text-lg font-semibold text-white rounded-lg btn-primary">
      Generate Interactive Review
    </button>
  </section>

  <!-- Final Review Section (mobile-optimized) -->
  <main id="review-section" class="hidden flex-1 max-w-5xl w-full mx-auto">
    <div class="w-full grid grid-cols-1 lg:grid-cols-2 gap-3">
      <!-- Column A: Board + evaluation graph (sticky) -->
      <div class="lg:col-span-1">
        <div class="sticky top-2">
          <!-- Evaluation graph -->
          <canvas id="eval-graph" class="w-full mb-2"></canvas>

          <!-- Board -->
          <div class="w-full max-w-xl mx-auto">
            <div id="board" class="chessboard-container"></div>
            <div id="controls" class="mt-3 flex items-center justify-center gap-2 w-full">
              <button id="prev-btn" class="px-4 py-2 text-white font-semibold rounded-lg btn-secondary">‹ Prev</button>
              <button id="next-btn" class="px-4 py-2 text-white font-semibold rounded-lg btn-secondary">Next ›</button>
              <button id="flip-btn" class="px-4 py-2 text-white font-semibold rounded-lg btn-secondary">Flip</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Column B: Independently scrollable analysis (no titles) -->
      <div class="lg:col-span-1">
        <div id="move-analysis-shell" class="bg-[#101522] p-3 rounded-lg">
          <div id="move-analysis-scroll" class="overflow-y-auto">
            <!-- One-line summary appears here (from "Summary:") -->
            <div id="game-summary" class="hidden mb-3 p-2 rounded bg-[#0b0e15] text-sm text-gray-200"></div>
            <div id="move-analysis-container" class="space-y-1"></div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Error Modal -->
  <div id="error-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
    <div class="bg-[#141926] p-8 rounded-lg shadow-xl max-w-sm w-full text-center">
      <h3 class="text-2xl font-bold text-red-400 mb-4">Error</h3>
      <p id="error-message" class="text-gray-300 mb-6">Could not process the input.</p>
      <button id="close-modal-btn" class="py-2 px-6 font-semibold text-white rounded-lg btn-primary">Close</button>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.5.1.min.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.2/chess.js"></script>

  <script>
    $(function () {
      // ====== Stockfish (same-origin Worker) ======
      const LOCAL_ENGINE = 'engine/stockfish-nnue-16-single.js';
      // Configure engine search: set either { depth: N } or { movetime: ms }
      const ENGINE_GO_OPTIONS = { depth: 12 }; // or e.g., { depth: 20 }
      let engineWorker = new Worker(LOCAL_ENGINE);
      let engineReady = false;
      let lastInfoMsg = '';
      let currentScoreResolver = null;

      function configureEngineOptions() {
        engineReady = false;
        $('#analyze-pgn-btn').prop('disabled', true).text('Loading Engine...');
        const threadCount = navigator.hardwareConcurrency || 3;
        const options = { Threads: threadCount, Hash: 256 };
        Object.entries(options).forEach(([name, value]) => {
          engineWorker.postMessage(`setoption name ${name} value ${value}`);
        });
        engineWorker.postMessage('isready');
      }

      // Prompt (adds one-line Summary at the end)
      const ANALYSIS_PROMPT = `Analyze the PGN where each move is followed by an evaluation of White's win probability in braces {}. Produce one line per half-move in this exact format without numbering:

<move> - {<eval>} <classification>: <comment>

Strict rules you MUST follow:

Post-move Eval: The number or mate score in braces {} is the evaluation after the move it follows. All percentage evaluations represent White's win probability.

Mate Sign Semantics:

{#N} means White has a forced mate in N moves.

{#-N} means Black has a forced mate in N moves.

Side-to-move Awareness & Mate Blunders:

If the move was played by Black and the resulting eval is {#N}, Black has allowed a forced mate for White → classify as Misclick?? or Blunder.

If the move was played by White and the resulting eval is {#-N}, White has allowed a forced mate for Black → classify as Misclick?? or Blunder.

Win-Probability Deltas & Classification:

First, calculate the delta: delta = abs(current_eval - previous_eval).

Next, determine if the move was a drop for the player who moved:

For White (as the mover), a drop is when current_eval < previous_eval.

For Black (as the mover), a drop is when current_eval > previous_eval.

Forced mate for Black {#-N} equals {0%} probability of mate for White.

Forced mate for White {#N} equals {100%} probability of mate for White.

If the move was a drop, classify it based on the delta:

Drop of 6–14 points → Inaccuracy

Drop of 15–39 points → Mistake

Drop of ≥40 points → Blunder

Drop of ≥65 points → Misclick??

Example: If the previous eval was {#3} and White moves, resulting in a {#-4}, 100 - 0 = 100-point drop for White and must be classified as a Misclick??.

Any half-move that classifies as an Inaccuracy or a Mistake and changes a non-mate position into a forced mate for the opponent must be classified as a Blunder.

Brilliant Moves: If the eval is improved involving a sacrifice or it creates a forced mate for their side, classify the move as Brilliant (otherwise use Good/Book for normal/theory moves).

Forced Moves: Use the Forced classification only when the move is essentially unique to avoid immediate material loss or mate (e.g., the only legal move, or the only move that doesn't result in a forced mate or a huge drop in evaluation).

Comments:

If I am one of the two players, coach me: I am 'eugenime'.

Your comment must support the classification but don't mention eval increase/drop but rather say why that half-move creates an advantage or disadvantage for the player on the board.

Keep comments consistent with the evaluation.

When discussing mates or a significant advantage, always explicitly name the benefiting side (e.g., "allows White a mate in 3" or "gives Black a winning attack").

​Factual Accuracy: Your comment must be factually accurate according to the board state at the time of the move. Before stating that a move attacks, defends, pins, forks, or has any other direct tactical consequence, you must verify that this is true based on the PGN. Do not make generic comments that might be inaccurate for the specific position.

​Sanity Checks Before Finalizing:
​Verify you have toggled the mover (White, Black, White...) correctly for each half-move.

​Ensure any move resulting in a forced mate for the opponent is labeled correctly based on the delta rules.

​Verify Factual Claims: Reread your comments to ensure that any specific claims about the move's function (e.g., "attacks the queen," "defends f7") are explicitly true for the given board state.

​Final Output:
Output exactly one line per half-move as specified, followed by a final Summary: which should be a single-line summary of the game's overall narrative. Do not use any extra headings, bullet points, or other formatting in your main output.`;

      engineWorker.onmessage = function(e) {
        const msg = String(e.data || '');
        if (msg === 'readyok') {
          engineReady = true;
          $('#analyze-pgn-btn').prop('disabled', false).text('Run Stockfish Analysis');
        } else if (msg.startsWith('info depth')) {
          lastInfoMsg = msg;
        } else if (msg.startsWith('bestmove')) {
          const cp = /score cp (-?\d+)/.exec(lastInfoMsg);
          const mt = /score mate (-?\d+)/.exec(lastInfoMsg);
          if (currentScoreResolver) {
            if (mt) {
              currentScoreResolver({ type: 'mate', value: parseInt(mt[1], 10) });
            } else if (cp) {
              currentScoreResolver({ type: 'cp', value: parseInt(cp[1], 10) });
            } else {
              currentScoreResolver({ type: 'cp', value: 0 });
            }
            currentScoreResolver = null;
          }
        }
      };
      engineWorker.postMessage('uci');
      configureEngineOptions();

      function waitForEngineReady() {
        return new Promise(resolve => {
          if (engineReady) { resolve(); return; }
          const interval = setInterval(() => {
            if (engineReady) {
              clearInterval(interval);
              resolve();
            }
          }, 50);
        });
      }

      // ====== App state ======
      let board = null;
      let game = new Chess();
      let movesWithAnalysis = [];
      let currentMoveIndex = -1;
      let probSeries = []; // WHITE win probability per ply (0..1)
      let evalCanvas = null;
      let evalCtx = null;

      const classificationStyles = {

  
    'brilliant': 'text-cyan-300',
    'great': 'text-teal-300',
    'excellent': 'text-teal-300',
    'good': 'text-green-400',
    'okay': 'text-green-400',
    'book': 'text-blue-400',

   
    'forced': 'text-gray-400',
    'default': 'text-gray-400',


    'inaccuracy': 'text-yellow-400',
    'mistake': 'text-orange-400',
    'blunder': 'text-red-500',
    'misclick??': 'text-fuchsia-500',

      };
      function getStyleForClassification(c) { return classificationStyles[(c || '').toLowerCase().replace(/\s/g,'')] || classificationStyles['default']; }
      function formatText(t) { return t ? String(t).replace(/\*\*(.*?)\*\*/g,'<strong>$1</strong>') : ''; }
      function showError(m) { $('#error-message').text(m); $('#error-modal').removeClass('hidden'); }
      $('#close-modal-btn').on('click', function(){ $('#error-modal').addClass('hidden'); });

      // ---------- Score helpers ----------
      function cpToProb(cp){ return 1 / (1 + Math.exp(-cp / 173)); }

      function cpToProbBraced(cp){ const pct = Math.round(cpToProb(cp) * 100); return `{${pct}%}`; }

      // ---------- PGN normalization ----------
      function normalizePgn(raw, opts) {
        opts = opts || {}; const keepComments = !!opts.keepComments;
        let s = String(raw || '').replace(/\r\n?/g, '\n').replace(/^\uFEFF/, '').trim(); if (!s) return '';
        const lines = s.split('\n'); const headerLines = []; let i = 0;
        while (i < lines.length && /^\s*\[.*\]\s*$/.test(lines[i])) { headerLines.push(lines[i].trim()); i++; }
        let movePart = lines.slice(i).join('\n');
        if (headerLines.length === 0) {
          const all = s.split('\n'); let lastHeaderIdx = -1;
          for (let j=0;j<all.length;j++) if (/^\s*\[.*\]\s*$/.test(all[j])) lastHeaderIdx = j;
          if (lastHeaderIdx >= 0) { headerLines.push(...all.slice(0,lastHeaderIdx+1).map(x=>x.trim())); movePart = all.slice(lastHeaderIdx+1).join('\n'); }
        }
        if (!keepComments) {
          movePart = movePart.replace(/\{[^}]*\}/g,' ');
          movePart = movePart.replace(/\([^()]*\)/g,' ');
          movePart = movePart.replace(/\$\d+/g,' ');
          movePart = movePart.replace(/([a-hRNBQKO0-9=:+#-])([!?]{1,2})/g,'$1');
          movePart = movePart.replace(/\u2026/g,'...');
        }
        movePart = movePart.replace(/\s+/g,' ').replace(/\s*\.(\.\.)?\s*/g, m=>m.trim()+' ').trim();
        const headerBlock = headerLines.length ? headerLines.join('\n') : '';
        return headerBlock ? (headerBlock+'\n\n'+movePart) : movePart;
      }

      function buildHeaderTagBlock(chess) {
        const hdr = chess.header();
        const order = ['Event','Site','Date','Round','White','Black','Result','TimeControl','WhiteElo','BlackElo','Termination','ECO','EndTime','Link','UTCDate','UTCTime','GameId','Variant','Opening','Annotator'];
        const seen = new Set(); const lines = [];
        order.forEach(k => { if (hdr[k]) { lines.push(`[${k} "${hdr[k]}"]`); seen.add(k); } });
        Object.keys(hdr).sort().forEach(k => { if (!seen.has(k)) lines.push(`[${k} "${hdr[k]}"]`); });
        return lines.join('\n');
      }

      function switchStep(step) {
        ['#step1-section','#step2-section','#step3-section','#review-section'].forEach(s => $(s).addClass('hidden'));
        $('.step-indicator').removeClass('active');
        $('#indicator-' + step).addClass('active');
        if (step <= 3) $('#step' + step + '-section').removeClass('hidden');
        else $('#review-section').removeClass('hidden');
        // Hide header on final screen (no titles)
        if (step === 4) { $('#app-header, #step-indicators').addClass('hidden'); } else { $('#app-header, #step-indicators').removeClass('hidden'); }
      }

      $('#analyze-pgn-btn').on('click', async function () {
        const pgnRaw = $('#pgn-input').val().trim(); if (!pgnRaw) { showError('Please paste a PGN.'); return; }
        const pgn = normalizePgn(pgnRaw);
        if (!game.load_pgn(pgn)) {
          const justMoves = normalizePgn(pgnRaw.replace(/^(\s*\[.*\]\s*$)+/gm,''));
          if (!game.load_pgn(justMoves)) { showError('Invalid PGN format. Try removing engine/clock comments or share the PGN example with me.'); return; }
        }
        switchStep(2);
        await runStockfishAnalysis();
      });

      async function runStockfishAnalysis() {
        await waitForEngineReady();
        const sanMoves = game.history(); let annotatedPgn = '';
        const headerBlock = buildHeaderTagBlock(game); if (headerBlock) annotatedPgn = headerBlock + '\n\n';
        const temp = new Chess();
        probSeries = [];
        for (let i = 0; i < sanMoves.length; i++) {
          const moveNumber = Math.floor(i / 2) + 1; const prefix = (i % 2 === 0) ? (moveNumber + '. ') : '';
          const move = sanMoves[i];
          $('#progress-text').text('Analyzing move ' + (i + 1) + '/' + sanMoves.length + ': ' + move);
          $('#progress-bar').css('width', (((i + 1) / sanMoves.length) * 100) + '%');

          // *** FIX STARTS HERE ***
          // The order of operations is changed.
          // 1. Make the move on the temporary board.
          const moveObj = temp.move(move);
          const lastMoveColor = moveObj.color; // 'w' or 'b'

          // 2. Get the score for the new position *after* the move has been made.
          const score = await getScore(temp.fen(), ENGINE_GO_OPTIONS);
          // *** FIX ENDS HERE ***

          let evalStr = '';
          let prob = null;
          if (score.type === 'mate') {
            let m = score.value; // mate in N from side to move
            if (temp.turn() === 'b') m = -m; // convert to WHITE-relative
            evalStr = `{#${m}}`;
            prob = (m === 0) ? (lastMoveColor === 'w' ? 1 : 0) : (m > 0 ? 1 : 0);
          } else {
            let cp = score.value; // centipawns from side to move
            if (temp.turn() === 'b') cp = -cp; // convert to WHITE-relative
            evalStr = cpToProbBraced(cp);
            prob = cpToProb(cp);
          }
          probSeries.push(prob);
          annotatedPgn += (i % 2 === 0 ? prefix : '') + move + ' ' + evalStr + ' ';
        }
        const combined = ANALYSIS_PROMPT + '\n\n' + annotatedPgn.trim();
        $('#progress-text').text('Analysis Complete!');
        $('#stockfish-output').val(combined);
        $('#goto-step3-btn').prop('disabled', false);
      }

      function getScore(fen, opts) {
        return new Promise(resolve => {
          currentScoreResolver = resolve; lastInfoMsg = '';
          engineWorker.postMessage('position fen ' + fen);
          const o = opts || ENGINE_GO_OPTIONS || {};
          let cmd;
          if (o.depth != null) cmd = 'go depth ' + o.depth;
          else if (o.movetime != null) cmd = 'go movetime ' + o.movetime;
          else cmd = 'go depth 15';
          engineWorker.postMessage(cmd);
        });
      }

      $('#copy-stockfish-btn').on('click', function () {
        navigator.clipboard.writeText($('#stockfish-output').val()).then(function(){
          $('#copy-stockfish-btn').text('Copied!'); setTimeout(function(){ $('#copy-stockfish-btn').text('Copy to Clipboard'); }, 1600);
        });
      });

      $('#goto-step3-btn').on('click', function(){ switchStep(3); });

      // ====== Step 3: accept PGN or comments-only and build review ======
      $('#generate-review-btn').on('click', function () {
        const finalAnalysisRaw = $('#final-analysis-input').val().trim(); if (!finalAnalysisRaw) { showError('Please paste the final analysis.'); return; }
        let pgn = normalizePgn(finalAnalysisRaw); let loaded = game.load_pgn(pgn);
        const parsed = parseAnalysis(finalAnalysisRaw);
        if (!loaded && parsed.moves.length) {
          let rebuiltPGN = buildPGNFromSAN(parsed.moves.map(m => m.san)); game.reset(); loaded = game.load_pgn(rebuiltPGN);
          if (!loaded) { game.reset(); let ok = true; parsed.moves.forEach(m => { if (ok) ok = !!game.move(m.san); }); if (ok) { rebuiltPGN = game.pgn({ maxWidth: 9999 }); game.reset(); loaded = game.load_pgn(rebuiltPGN); } }
          if (loaded) pgn = rebuiltPGN;
        }
        if (!loaded) { showError('Could not find or reconstruct a valid PGN from the text you pasted.'); return; }

        switchStep(4);

        const gameMoves = game.history({ verbose: true }); let cursor = 0;
        movesWithAnalysis = gameMoves.map(m => {
          let analysis = null;
          if (cursor < parsed.moves.length && parsed.moves[cursor].san === m.san) analysis = parsed.moves[cursor++];
          let prob = null;
          if (analysis) {
            if (analysis.evaluation && analysis.evaluation.includes('#0')) {
              prob = m.color === 'w' ? 1 : 0;
            } else {
              prob = analysis.prob;
            }
          }
          return { ...m, analysis, criticalMoment: parsed.criticalMoments[m.san], prob };
        });
        probSeries = movesWithAnalysis.map(m => m.prob);

        // Summary text
        const summary = parsed.summary || '';
        if (summary) { $('#game-summary').removeClass('hidden').text(summary); } else { $('#game-summary').addClass('hidden').text(''); }

        if (!board) {
          board = Chessboard('board', { position: 'start', draggable: false, pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png' });
          $(window).on('resize', function(){ board.resize(); adjustAnalysisHeight(); resizeEvalGraph(); });
          initEvalGraph();
        }

        board.position('start');
        renderMoveList();
        adjustAnalysisHeight();
        board.resize();
        resizeEvalGraph();
        renderEvalGraph(-1);
      });

      // Build PGN from SAN list
      function buildPGNFromSAN(sanList) { const parts = []; for (let i = 0; i < sanList.length; i++) { const n = Math.floor(i / 2) + 1; if (i % 2 === 0) parts.push(n + '. ' + sanList[i]); else parts.push(sanList[i]); } return parts.join(' '); }

      // Parse analysis lines with optional {eval} and final Summary:
      function parseAnalysis(text) {
        const lines = text.split('\n'); const parsedMoves = []; const criticalMoments = {}; const summaries = {}; let currentSummary = null; let lastSan = null; let summaryLine = '';
        const moveRegex = /^(?:\d+\.{1,3}\s*)?(\S+)\s*[-–—]\s*(\{[^}]+\})?\s*([A-Za-z?]+)\s*:\s*(.*)/;
        const criticalMomentRegex = /^Critical Moment:\s*(.*)/i;
        const summaryHeaderRegex = /^\s*\*\*(Strengths|Recurring Mistakes|Top 3 Takeaways)\*\*/i;
        const summaryLineRegex = /^Summary:\s*(.*)/i;
        lines.forEach(line => {
          const sl = line.match(summaryLineRegex); if (sl) { summaryLine = sl[1].trim(); return; }
          const m = line.match(moveRegex);
          if (m) {
            const san = m[1];
            const evaluation = (m[2] || '').trim() || null;
            const classification = m[3].trim();
            const txt = m[4].trim();
            const prob = parseEvalToProb(evaluation);
            parsedMoves.push({ san, evaluation, classification, prob, text: txt });
            lastSan = san; currentSummary = null; return;
          }
          const cm = line.match(criticalMomentRegex); if (cm && lastSan) { criticalMoments[lastSan] = cm[1]; return; }
          const sh = line.match(summaryHeaderRegex); if (sh) { const key = sh[1].replace(/\s/g,''); summaries[key] = []; currentSummary = key; return; }
          if (line.trim() && line.trim() !== '---' && currentSummary) summaries[currentSummary].push(line.trim());
        });
        return { moves: parsedMoves, criticalMoments, summaries, summary: summaryLine };
      }

      // Convert evaluation string like "{+0.23}", "{-1.10}", "{#3}" (WHITE-relative already)
      function parseEvalToCp(evalStr) { if (!evalStr) return null; const s = String(evalStr).replace(/[{}\s]/g,''); if (!s) return null; if (s[0] === '#') return s.includes('-') ? -999 : 999; const num = parseFloat(s); if (isNaN(num)) return null; return Math.round(num * 100); }

      function parseEvalToProb(evalStr) {
        if (!evalStr) return null;
        const s = String(evalStr).replace(/[{}\s]/g, '');
        if (!s) return null;
        if (s[0] === '#') {
          const m = parseInt(s.slice(1), 10);
          if (isNaN(m)) return null;
          if (m === 0) return null;
          return m > 0 ? 1 : 0;
        }
        if (s.endsWith('%')) {
          const num = parseFloat(s.slice(0, -1));
          if (isNaN(num)) return null;
          return num / 100;
        }
        const cp = parseEvalToCp(evalStr);
        if (cp == null) return null;
        return cpToProb(cp);
      }

      function formatProbability(p) {
        if (p == null) return '';
        return (p * 100).toFixed(1) + '%';
      }

      // ====== Rendering ======
      function renderMoveList() {
        const c = $('#move-analysis-container').empty();
        movesWithAnalysis.forEach((mv, i) => {
          const n = mv.color === 'w' ? (Math.floor(i / 2) + 1) + '.' : '';
          let evalHtml = '';
          if (mv.analysis && mv.analysis.evaluation && mv.analysis.evaluation.includes('#')) {
            evalHtml = '<span class="font-mono text-xs text-gray-400 ml-2">' + mv.analysis.evaluation + '</span>';
          } else if (mv.prob != null) {
            evalHtml = '<span class="font-mono text-xs text-gray-400 ml-2">' + formatProbability(mv.prob) + '</span>';
          }
          const html =
            '<div class="move-item p-2 cursor-pointer" data-move-index="' + i + '">' +
              '<div class="flex items-baseline gap-3">' +
                '<span class="text-gray-500 font-mono w-8 text-right">' + n + '</span>' +
                '<span class="font-bold text-lg text-white">' + mv.san + '</span>' +
                evalHtml +
                (mv.analysis ? '<span class="font-semibold text-sm ml-2 ' + getStyleForClassification(mv.analysis.classification) + '">' + mv.analysis.classification + '</span>' : '') +
              '</div>' +
              (mv.analysis ? '<p class="pl-12 text-gray-300 text-sm">' + formatText(mv.analysis.text) + '</p>' : '') +
              (mv.criticalMoment ? '<p class="pl-12 mt-1 text-xs text-yellow-300 bg-yellow-900/40 p-2 rounded">' + formatText('**Critical Moment:** ' + mv.criticalMoment) + '</p>' : '') +
            '</div>';
          c.append(html);
        });
        $('.move-item').on('click', function(){ goToMove($(this).data('move-index')); });
      }

      function adjustAnalysisHeight() {
        // Make the analysis pane scrollable and tall enough to show last moves without the board scrolling away
        const shell = document.getElementById('move-analysis-shell');
        const scroll = document.getElementById('move-analysis-scroll');
        const boardEl = document.getElementById('board');
        const controls = document.getElementById('controls');
        if (!shell || !scroll || !boardEl || !controls) return;
        // Available viewport height minus some margins
        const vh = window.innerHeight;
        const boardH = boardEl.clientWidth; // board is square: height ~ width
        const controlsH = controls.offsetHeight || 0;
        const headerHidden = document.getElementById('app-header').classList.contains('hidden');
        const topPadding = headerHidden ? 8 : 16;
        // On mobile: place analysis below; give it remaining height
        let target = vh - (boardH + controlsH + topPadding + 24);
        target = Math.floor(target * 2 / 3); // make scrollable area 1/3 shorter
        if (target < 120) target = 120; // minimum height after reduction
        scroll.style.maxHeight = target + 'px';
        scroll.style.height = target + 'px';
      }

      function initEvalGraph() {
        evalCanvas = document.getElementById('eval-graph');
        if (!evalCanvas) return;
        evalCtx = evalCanvas.getContext('2d');
        evalCanvas.addEventListener('click', function(e) {
          const rect = evalCanvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const maxIdx = Math.max(probSeries.length - 1, 0);
          const idx = Math.round((x / evalCanvas.width) * maxIdx);
          goToMove(idx);
        });
        resizeEvalGraph();
      }

      function resizeEvalGraph() {
        if (!evalCanvas) return;
        const boardEl = document.getElementById('board');
        if (boardEl) evalCanvas.width = boardEl.clientWidth;
        evalCanvas.height = 60;
        renderEvalGraph(currentMoveIndex);
      }

      function renderEvalGraph(idx) {
        if (!evalCanvas || !evalCtx) return;
        const w = evalCanvas.width;
        const h = evalCanvas.height;
        evalCtx.clearRect(0, 0, w, h);
        evalCtx.fillStyle = '#000';
        evalCtx.fillRect(0, 0, w, h);
        if (probSeries.length > 0) {
          const maxIdx = Math.max(probSeries.length - 1, 1);
          evalCtx.lineWidth = 1;

          // White probability line
          evalCtx.strokeStyle = '#fbbf24';
          evalCtx.beginPath();
          probSeries.forEach((p, i) => {
            if (p == null) p = 0.5;
            // Clamp to [0,1] so mate scores render at the extreme edges
            p = Math.min(Math.max(p, 0), 1);
            const x = (i / maxIdx) * w;
            const y = (1 - p) * h;
            if (i === 0) evalCtx.moveTo(x, y); else evalCtx.lineTo(x, y);
          });
          evalCtx.stroke();

          // Midline at 50%
          evalCtx.strokeStyle = '#ffffff';
          evalCtx.lineWidth = 0.5;
          evalCtx.beginPath();
          evalCtx.moveTo(0, h / 2);
          evalCtx.lineTo(w, h / 2);
          evalCtx.stroke();
        }
        if (idx >= 0 && probSeries.length > 0) {
          const maxIdx = Math.max(probSeries.length - 1, 1);
          const x = (idx / maxIdx) * w;
          evalCtx.lineWidth = 1;
          evalCtx.strokeStyle = '#fbbf24';
          evalCtx.beginPath();
          evalCtx.moveTo(x, 0);
          evalCtx.lineTo(x, h);
          evalCtx.stroke();
        }
      }

      function ensureMoveVisible(idx) {
        const container = document.getElementById('move-analysis-scroll');
        const item = document.querySelector('.move-item[data-move-index="' + idx + '"]');
        if (!container || !item) return;
        const itemRect = item.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        if (itemRect.top < containerRect.top || itemRect.bottom > containerRect.bottom) {
          item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        if (window.innerWidth < 1024) {
          document.getElementById('move-analysis-shell').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }

      function goToMove(idx) {
        if (idx < -1 || idx >= movesWithAnalysis.length) return;
        currentMoveIndex = idx; game.reset(); for (let i = 0; i <= idx; i++) game.move(movesWithAnalysis[i].san);
        if (board) board.position(game.fen());
        $('.move-item').removeClass('highlight'); if (idx >= 0) $('.move-item[data-move-index="' + idx + '"]').addClass('highlight');
        $('#prev-btn').prop('disabled', idx < 0); $('#next-btn').prop('disabled', idx >= movesWithAnalysis.length - 1);
        adjustAnalysisHeight(); renderEvalGraph(idx); ensureMoveVisible(idx);
      }

      $('#next-btn').on('click', function(){ goToMove(currentMoveIndex + 1); });
      $('#prev-btn').on('click', function(){ goToMove(currentMoveIndex - 1); });
      $('#flip-btn').on('click', function(){ if (board) board.flip(); });

      $(window).on('resize', function(){ adjustAnalysisHeight(); resizeEvalGraph(); });
      $(document).on('keydown', function(e){ if (!$('#review-section').is(':visible')) return; if (e.key==='ArrowRight') goToMove(currentMoveIndex + 1); if (e.key==='ArrowLeft') goToMove(currentMoveIndex - 1); });
    });
  </script>
</body>
</html>
