<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>AI Chess Reviewer</title>

  <!-- Tailwind Play CDN (ok for prototypes) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css" crossorigin="anonymous">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
    :root { --panel-max-width: 47.52rem; }
    body { font-family: 'Inter', sans-serif; background-color: #0f1115; color: #e5e7eb; }
    .chessboard-container { width: 100%; margin: 0 auto; aspect-ratio: 1 / 1; }
    .move-item { transition: background-color 0.2s ease-in-out; border-radius: 0.5rem; }
    .move-item.highlight { background-color: #243249; }
    .move-item:hover { background-color: #1c273a; }
    .move-item.featured { border: 1px solid rgba(250, 204, 21, 0.35); background-color: rgba(250, 204, 21, 0.06); }
    .move-item.featured:hover { background-color: rgba(250, 204, 21, 0.12); }
    .move-item.featured.highlight { background-color: #243249; }
    #eval-graph { cursor: pointer; transition: opacity 0.2s ease-in-out; }
    #eval-graph.exploration-disabled { opacity: 0.85; }
    #move-analysis-scroll::-webkit-scrollbar { width: 8px; }
    #move-analysis-scroll::-webkit-scrollbar-track { background: #1a1f2a; }
    #move-analysis-scroll::-webkit-scrollbar-thumb { background-color: #4b5563; border-radius: 10px; border: 2px solid #1a1f2a; }
    .btn-primary { background-color: #3b82f6; transition: background-color 0.2s; }
    .btn-primary:hover { background-color: #2563eb; }
    .btn-primary:disabled { background-color: #374151; cursor: not-allowed; }
    .btn-secondary { background-color: #374151; transition: background-color: 0.2s; }
    .btn-secondary:hover { background-color: #4b5563; }
    #toggle-eval-btn { border: 1px solid transparent; transition: background-color 0.2s, border-color 0.2s, color 0.2s; }
    #toggle-eval-btn.best-active { background-color: #0b0e15; border-color: rgba(250, 204, 21, 0.4); color: #facc15; font-family: 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas', 'Liberation Mono', 'Courier New', monospace; }
    #toggle-eval-btn.best-active:hover { background-color: #131a2c; }
    textarea.form-input, input.form-input { background-color: #2d2d2d; border-color: #364152; color: #e5e7eb; }
    textarea.form-input:focus, input.form-input:focus { border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.35); outline: none; }
    input[type=number]::-webkit-outer-spin-button,
    input[type=number]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    input[type=number] { -moz-appearance: textfield; }
    .step-indicator { background-color: #273043; cursor: pointer; }
    .step-indicator.active { background-color: #3b82f6; }
    .step-indicator:focus-visible { outline: 2px solid #60a5fa; outline-offset: 2px; }
    #board .square-55d63 { position: relative; }
    #board .piece-417db { position: relative; z-index: 2; }
    #best-move-arrow { z-index: 1; }
    #board .square-55d63::before,
    #board .square-55d63::after {
      content: '';
      position: absolute;
      inset: 8%;
      border-radius: 6px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s ease-in-out;
      box-sizing: border-box;
    }
    #board .square-55d63.selected { background-color: rgba(251, 191, 36, 0.5); }
    #board { background-color: #0b0e15; border-radius: 0.75rem; }
    .board-shell { box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45); }
    #prev-btn, #next-btn { font-size: 1rem; }
    .status-banner { display: none; border-radius: 0.75rem; padding: 0.75rem 1rem; border: 1px solid transparent; }
    .status-banner.status-visible { display: flex; align-items: flex-start; gap: 0.75rem; }
    .status-banner.status-info { background-color: rgba(59, 130, 246, 0.12); border-color: rgba(59, 130, 246, 0.35); color: #bfdbfe; }
    .status-banner.status-error { background-color: rgba(239, 68, 68, 0.12); border-color: rgba(239, 68, 68, 0.35); color: #fecaca; }
    .status-banner .detail { color: rgba(191, 219, 254, 0.8); font-size: 0.75rem; margin-top: 0.25rem; }
    .status-banner.status-error .detail { color: rgba(254, 202, 202, 0.85); }
    .board-panel { max-width: var(--panel-max-width); }
    .graph-panel { max-width: var(--panel-max-width); }
    .comment-panel { max-width: var(--panel-max-width); }
    .board-sticky-wrapper { top: 0.5rem; }
    @media (max-width: 1023px) {
      .board-sticky-wrapper { top: 0; }
    }
    .portrait-panel { width: 100%; }
    @media (orientation: portrait) {
      .portrait-panel {
        max-width: var(--panel-max-width);
        margin-left: auto;
        margin-right: auto;
      }
    }
    @media (min-width: 1024px) {
      .board-panel,
      .graph-panel,
      .comment-panel {
        max-width: none;
      }
    }
  </style>
</head>
<body class="min-h-screen flex flex-col p-3 sm:p-4">

  <!-- Header (hidden on final screen) -->
  <header id="app-header" class="text-center mb-6">
    <h1 class="text-2xl sm:text-3xl font-bold text-white">AI Chess Reviewer</h1>
  </header>

  <!-- Step Indicators -->
  <div id="step-indicators" class="flex justify-center items-center space-x-3 mb-6">
    <div id="indicator-1" class="step-indicator active w-8 h-2 rounded-full" data-step="1" role="button" tabindex="0" aria-label="Go to Step 1"></div>
    <div id="indicator-2" class="step-indicator w-8 h-2 rounded-full" data-step="2" role="button" tabindex="0" aria-label="Go to Step 2"></div>
    <div id="indicator-3" class="step-indicator w-8 h-2 rounded-full" data-step="3" role="button" tabindex="0" aria-label="Go to Step 3"></div>
  </div>

  <!-- Step 1: PGN Input -->
  <section id="step1-section" class="max-w-2xl w-full mx-auto flex flex-col gap-4">
    <h2 class="text-xl sm:text-2xl font-bold text-center">Analyze PGN with Stockfish</h2>
    <div id="engine-status-banner" class="status-banner">
      <div class="flex-1">
        <p id="engine-status-message" class="font-medium"></p>
        <p id="engine-status-detail" class="detail hidden"></p>
      </div>
      <button id="retry-engine-btn" type="button" class="hidden self-start py-2 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap">Retry</button>
    </div>
    <div>
      <div class="flex items-center justify-between gap-2 mb-2">
        <label for="player-name-input" class="font-semibold text-gray-300">Who should the AI coach?</label>
      </div>
      <input id="player-name-input" type="text" class="w-full p-3 rounded-lg form-input" placeholder="Username"/>
      <p class="mt-1 text-xs text-gray-400">Your username should appear in the PGN.</p>
    </div>
    <div class="bg-[#101522] border border-[#1f2937] rounded-lg p-4">
      <h3 class="text-sm font-semibold text-gray-200">Need a PGN?</h3>
      <p class="mt-1 text-xs text-gray-400">Load a recent game from Chess.com or Lichess, or paste one manually below.</p>
      <div class="flex flex-wrap items-center gap-2 mt-3">
        <button id="load-chesscom-btn" type="button" class="py-2 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap">
          Browse Chess.com games
        </button>
        <button id="load-lichess-btn" type="button" class="py-2 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap">
          Browse Lichess games
        </button>
        <button type="button" class="py-2 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap open-archive-btn">
          Open Saved Reviews
        </button>
      </div>
      <p id="game-loader-feedback" class="hidden mt-3 text-xs text-gray-300" role="status"></p>
    </div>
    <div>
      <div class="flex items-center justify-between gap-2 mb-2">
        <label for="pgn-input" class="font-semibold text-gray-300">Paste PGN here</label>
        <button id="clear-pgn-btn" type="button" class="py-2 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap">Clear</button>
      </div>
      <textarea id="pgn-input" rows="6" class="w-full p-3 rounded-lg form-input" placeholder="[Event &quot;...&quot;]..."></textarea>
    </div>
    <div class="flex justify-center gap-2 text-sm">
      <div class="flex flex-col items-center">
        <label for="depth-input" class="text-gray-300">Depth</label>
        <input id="depth-input" type="number" value="20" class="w-16 p-1 rounded form-input text-center"/>
      </div>
      <div class="flex flex-col items-center">
        <label for="threads-input" class="text-gray-300">Threads</label>
        <input id="threads-input" type="number" min="1" value="4" class="w-16 p-1 rounded form-input text-center"/>
      </div>
      <div class="flex flex-col items-center">
        <label for="hash-input" class="text-gray-300">Memory</label>
        <input id="hash-input" type="number" min="256" value="469" class="w-16 p-1 rounded form-input text-center"/>
      </div>
    </div>
    <div class="grid grid-cols-2 gap-2">
      <button id="analyze-pgn-btn" class="w-full py-3 px-6 text-lg font-semibold text-white rounded-lg btn-primary" disabled>
        Loading Engine...
      </button>
      <button id="goto-step2-btn" type="button" class="w-full py-3 px-6 text-lg font-semibold text-white rounded-lg btn-secondary">
        Skip
      </button>
    </div>
  </section>

  <!-- Step 2: Stockfish Output & AI Instructions -->
  <section id="step2-section" class="hidden max-w-2xl w-full mx-auto flex flex-col gap-4">
    <h2 class="text-xl sm:text-2xl font-bold text-center">Get AI Coaching Comments</h2>
    <div id="stockfish-progress" class="text-center p-4 bg-[#101522] rounded-lg">
       <p id="progress-text" class="text-sm text-gray-300"></p>
       <div class="w-full bg-gray-700 rounded-full h-2 mt-2">
        <div id="progress-bar" class="bg-blue-500 h-2 rounded-full" style="width: 0%"></div>
      </div>
    </div>
    <div>
      <label for="stockfish-output" class="block mb-2 font-semibold text-gray-300">Copy the prompt + annotated PGN below</label>
      <textarea id="stockfish-output" rows="7" class="w-full p-3 rounded-lg form-input font-mono text-sm" readonly></textarea>
      <button id="copy-stockfish-btn" class="w-full mt-2 py-2 px-4 font-semibold text-white rounded-lg btn-secondary">Copy to Clipboard</button>
    </div>
    <div class="grid grid-cols-2 gap-2">
      <button id="back-to-step1-btn" type="button" class="w-full py-3 px-6 text-lg font-semibold text-white rounded-lg btn-secondary">
        Back
      </button>
      <button id="goto-step3-btn" type="button" class="w-full py-3 px-6 text-lg font-semibold text-white rounded-lg btn-primary">
        Continue
      </button>
    </div>
  </section>

  <!-- Step 3: Final Analysis Input -->
  <section id="step3-section" class="hidden max-w-2xl w-full mx-auto flex flex-col gap-4">
    <h2 class="text-xl sm:text-2xl font-bold text-center">Paste Your Final AI Review</h2>
    <div>
      <label for="final-analysis-input" class="block font-semibold text-gray-300 mb-2">Paste complete analysis here</label>
      <div class="flex flex-col sm:flex-row sm:items-start gap-2">
        <textarea id="final-analysis-input" rows="6" class="flex-1 w-full p-3 rounded-lg form-input" placeholder="e4 - {3} Good: A classical opening move...\n...\nSummary: Black won after a decisive kingside attack."></textarea>
        <button id="clear-final-analysis-btn" type="button" class="sm:self-start py-2 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap">Clear</button>
      </div>
    </div>
    <div class="grid grid-cols-2 gap-2">
      <button id="back-to-step2-btn" type="button" class="w-full py-3 px-6 text-lg font-semibold text-white rounded-lg btn-secondary">
        Back
      </button>
      <button id="generate-review-btn" class="w-full py-3 px-6 text-lg font-semibold text-white rounded-lg btn-primary">
        Review
      </button>
    </div>
  </section>

  <!-- Final Review Section (mobile-optimized) -->
  <main id="review-section" class="hidden flex-1 max-w-5xl w-full mx-auto">
    <div class="w-full flex justify-start mb-3">
      <button id="back-to-step3-btn" type="button" class="px-4 py-2 text-white font-semibold rounded-lg btn-secondary">Back</button>
    </div>
    <div class="w-full grid grid-cols-1 lg:grid-cols-2 gap-3">
      <!-- Column A: Board + evaluation graph (sticky) -->
      <div class="lg:col-span-1 sticky top-2 board-sticky-wrapper">
        <!-- Evaluation graph -->
        <canvas id="eval-graph" class="w-full mb-2 graph-panel mx-auto block lg:mx-0"></canvas>

        <!-- Board -->
        <div class="w-full mx-auto board-panel">
          <div class="board-shell bg-[#0b0e15] border border-[#1f2937] rounded-xl p-3 shadow-xl shadow-black/40">
            <p id="material-top-label" class="text-center text-xs text-gray-300 leading-tight mb-1">White: 0</p>
            <div id="board" class="chessboard-container rounded-lg overflow-hidden"></div>
            <p id="material-bottom-label" class="text-center text-xs text-gray-300 leading-tight mt-1">Black: 0</p>
            <div id="controls" class="mt-3 flex flex-wrap items-center justify-between gap-2 w-full">
              <div class="flex flex-wrap items-center gap-2">
                <button id="toggle-eval-btn" type="button" class="px-4 py-2 text-white font-semibold rounded-lg btn-secondary" aria-pressed="false">Best</button>
                <button id="start-puzzle-btn" type="button" class="py-2 px-3 text-sm font-semibold text-white rounded-md btn-primary whitespace-nowrap">Start puzzle</button>
                <button id="exit-puzzle-btn" type="button" class="py-2 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap hidden">Exit</button>
              </div>
              <div class="flex flex-wrap items-center justify-end gap-2">
                <button id="flip-btn" class="px-4 py-2 text-white font-semibold rounded-lg btn-secondary">Flip</button>
                <button id="prev-btn" class="px-3 py-2 text-white font-semibold rounded-lg btn-secondary" aria-label="Previous move">Prev</button>
                <button id="next-btn" class="px-3 py-2 text-white font-semibold rounded-lg btn-secondary" aria-label="Next move">Next</button>
              </div>
            </div>
            <div id="puzzle-panel" class="mt-3 p-3 rounded-lg bg-[#101522] border border-[#1f2937] hidden">
              <div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
                <div>
                  <p class="text-sm font-semibold text-gray-200">Puzzle mode</p>
                  <p id="puzzle-info" class="text-xs text-gray-400">Generate a review to unlock puzzles from your worst moves.</p>
                </div>
                <div class="flex flex-wrap gap-2">
                  <button id="retry-puzzle-btn" type="button" class="py-2 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap" disabled>Retry</button>
                  <button id="next-puzzle-btn" type="button" class="py-2 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap" disabled>Next</button>
                </div>
              </div>
              <p id="puzzle-status-text" class="mt-2 text-xs text-gray-300"></p>
            </div>
          </div>
        </div>
      </div>

      <!-- Column B: Independently scrollable analysis (no titles) -->
      <div class="lg:col-span-1 flex flex-col gap-3">
        <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
          <div class="flex flex-wrap items-center gap-2">
            <button id="save-archive-btn" type="button" class="py-2 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap" disabled>
              Save to Archive
            </button>
            <button type="button" class="py-2 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap open-archive-btn">
              Open Archive
            </button>
          </div>
          <p id="archive-feedback" class="hidden text-xs"></p>
        </div>
        <div id="move-analysis-shell" class="bg-[#101522] p-3 rounded-lg portrait-panel comment-panel">
          <div id="move-analysis-scroll" class="overflow-y-auto">
            <!-- One-line summary appears here (from "Summary:") -->
            <div id="game-summary" class="hidden mb-3 p-2 rounded bg-[#0b0e15] text-sm text-gray-200"></div>
            <div id="featured-move" class="hidden mb-3"></div>
            <div id="move-analysis-container" class="space-y-1"></div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Game Picker Modal -->
  <div id="game-picker-modal" class="hidden fixed inset-0 z-50 bg-black bg-opacity-70 flex items-center justify-center px-4" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="bg-[#141926] w-full max-w-lg p-6 rounded-xl shadow-2xl border border-[#1f2937]">
      <div class="flex items-start justify-between gap-3">
        <h3 id="game-picker-title" class="text-xl font-semibold text-white">Select a game</h3>
        <button id="close-game-picker-btn" type="button" class="py-1.5 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap">Close</button>
      </div>
      <p id="game-picker-status" class="mt-3 text-sm text-gray-300"></p>
      <div id="game-picker-list" class="mt-4 space-y-2 max-h-96 overflow-y-auto" role="list"></div>
    </div>
  </div>

  <!-- Error Modal -->
  <div id="error-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
    <div class="bg-[#141926] p-8 rounded-lg shadow-xl max-w-sm w-full text-center">
      <h3 class="text-2xl font-bold text-red-400 mb-4">Error</h3>
      <p id="error-message" class="text-gray-300 mb-6">Could not process the input.</p>
      <button id="close-modal-btn" class="py-2 px-6 font-semibold text-white rounded-lg btn-primary">Close</button>
    </div>
  </div>

  <div id="puzzle-result-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
    <div class="bg-[#141926] p-8 rounded-lg shadow-xl max-w-sm w-full text-center border border-[#1f2937]">
      <h3 id="puzzle-result-title" class="text-2xl font-bold text-white mb-3">Puzzle Result</h3>
      <p id="puzzle-result-message" class="text-gray-300 mb-6"></p>
      <button id="close-puzzle-modal-btn" class="py-2 px-6 font-semibold text-white rounded-lg btn-primary">Continue</button>
    </div>
  </div>

  <!-- Archive Modal -->
  <div id="archive-modal" class="hidden fixed inset-0 z-50 bg-black bg-opacity-70 flex items-center justify-center px-4" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="bg-[#141926] w-full max-w-lg p-6 rounded-xl shadow-2xl border border-[#1f2937]">
      <div class="flex flex-wrap items-center justify-between gap-2">
        <h3 class="text-xl font-semibold text-white">Saved Reviews</h3>
        <div class="flex items-center gap-2">
          <button id="clear-archive-btn" type="button" class="py-1.5 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap">Clear All</button>
          <button id="close-archive-btn" type="button" class="py-1.5 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap">Close</button>
        </div>
      </div>
      <p id="archive-status" class="mt-3 text-sm text-gray-300"></p>
      <div id="archive-list" class="mt-4 space-y-3 max-h-96 overflow-y-auto"></div>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.5.1.min.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.2/chess.js"></script>

  <script>
    $(function () {
      $('#threads-input').val(4);

      const hardwareThreadCap = (typeof navigator !== 'undefined' && navigator.hardwareConcurrency)
        ? Math.max(1, Math.min(16, navigator.hardwareConcurrency))
        : 8;

      function sanitizeIntegerSetting(value, rules) {
        const normalizedRules = rules || {};
        const fallback = Number.isFinite(normalizedRules.fallback) ? normalizedRules.fallback : 0;
        let numeric = parseInt(value, 10);
        if (!Number.isFinite(numeric)) numeric = fallback;
        if (Number.isFinite(normalizedRules.min) && numeric < normalizedRules.min) numeric = normalizedRules.min;
        if (Number.isFinite(normalizedRules.max) && numeric > normalizedRules.max) numeric = normalizedRules.max;
        if (!Number.isFinite(numeric)) numeric = fallback;
        return numeric;
      }

      const ENGINE_SETTING_LIMITS = {
        depth: { min: 4, max: 30, fallback: sanitizeIntegerSetting($('#depth-input').val(), { fallback: 24 }) },
        threads: { min: 1, max: hardwareThreadCap, fallback: sanitizeIntegerSetting($('#threads-input').val(), { fallback: 4 }) },
        hash: { min: 32, max: 512, fallback: sanitizeIntegerSetting($('#hash-input').val(), { fallback: 384 }) }
      };

      function sanitizeEngineSetting(key, value) {
        const rules = ENGINE_SETTING_LIMITS[key] || {};
        const fallback = Number.isFinite(rules.fallback)
          ? Math.min(Math.max(rules.fallback, rules.min ?? rules.fallback), rules.max ?? rules.fallback)
          : 0;
        let numeric = parseInt(value, 10);
        if (!Number.isFinite(numeric)) numeric = fallback;
        if (Number.isFinite(rules.min) && numeric < rules.min) numeric = rules.min;
        if (Number.isFinite(rules.max) && numeric > rules.max) numeric = rules.max;
        if (!Number.isFinite(numeric)) numeric = fallback;
        return numeric;
      }

      function getDepthSettingInfo() {
        const rules = ENGINE_SETTING_LIMITS.depth || {};
        const raw = $('#depth-input').val();
        const numeric = parseInt(raw, 10);
        const isNumeric = Number.isFinite(numeric);
        const valid = isNumeric
          && (!Number.isFinite(rules.min) || numeric >= rules.min)
          && (!Number.isFinite(rules.max) || numeric <= rules.max);
        return {
          raw,
          value: isNumeric ? numeric : null,
          valid
        };
      }

      Object.keys(ENGINE_SETTING_LIMITS).forEach(key => {
        const rules = ENGINE_SETTING_LIMITS[key];
        rules.fallback = sanitizeEngineSetting(key, rules.fallback);
      });

      const STEP_HASHES = { 1: '', 2: '#step-2', 3: '#step-3', 4: '#step-4' };
      const DEFAULT_PLAYER_NAME = 'eugenime';
      let formState = loadFormState();
      let currentStep = 1;

      // ====== App state ======
      let board = null;
      let game = new Chess();
      let reviewPlayerColor = null;
      let lastEngineMoveRecords = null;
      let movesWithAnalysis = [];
      let currentMoveIndex = -1;
      let probSeries = []; // WHITE win probability per ply (0..1)
      let evalCanvas = null;
      let evalCtx = null;
      const copyStockfishBtn = $('#copy-stockfish-btn');
      const defaultCopyLabel = copyStockfishBtn.length ? (copyStockfishBtn.text().trim() || 'Copy to Clipboard') : 'Copy to Clipboard';
      const analyzingCopyLabel = 'Analyzing...';
      let featuredMoveData = null;
      let featuredMoveIndex = -1;
      let lastAnnotatedPgn = '';
      let playerGameOutcome = null;
      const engineStatusBanner = $('#engine-status-banner');
      const engineStatusMessage = $('#engine-status-message');
      const engineStatusDetail = $('#engine-status-detail');
      const retryEngineBtn = $('#retry-engine-btn');
      let explorationState = null;
      const puzzlePanel = $('#puzzle-panel');
      const puzzleInfo = $('#puzzle-info');
      const puzzleStatusText = $('#puzzle-status-text');
      const startPuzzleBtn = $('#start-puzzle-btn');
      const exitPuzzleBtn = $('#exit-puzzle-btn');
      const retryPuzzleBtn = $('#retry-puzzle-btn');
      const nextPuzzleBtn = $('#next-puzzle-btn');
      const puzzleResultModal = $('#puzzle-result-modal');
      const puzzleResultTitle = $('#puzzle-result-title');
      const puzzleResultMessage = $('#puzzle-result-message');
      const closePuzzleModalBtn = $('#close-puzzle-modal-btn');
      const materialTopLabel = $('#material-top-label');
      const materialBottomLabel = $('#material-bottom-label');
      let puzzleQueue = [];
      let activePuzzleIndex = -1;
      let puzzleActive = false;
      let puzzleLoading = false;
      let puzzleStartFen = '';
      let puzzleTargetMove = '';
      let puzzleTargetSan = '';
      let puzzleReturnIndex = -1;
      let puzzleOriginalMove = '';
      let puzzleOriginalEval = null;
      let puzzleAnalysisActive = false;
      const PIECE_VALUES = { p: 1, n: 3, b: 3, r: 5, q: 9 };
      const STARTING_PIECE_COUNTS = {
        w: { p: 8, n: 2, b: 2, r: 2, q: 1 },
        b: { p: 8, n: 2, b: 2, r: 2, q: 1 }
      };
      let puzzleAnalysisFenNormalized = '';
      let puzzleTopCandidates = [];
      let puzzleAnalysisToken = 0;
      let puzzleScoreRequestToken = 0;
      let puzzleGraphIndex = -1;
      let puzzleContextSquares = null;
      const loadChessComBtn = $('#load-chesscom-btn');
      const loadLichessBtn = $('#load-lichess-btn');
      const gameLoaderFeedback = $('#game-loader-feedback');
      const gamePickerModal = $('#game-picker-modal');
      const gamePickerTitle = $('#game-picker-title');
      const gamePickerStatus = $('#game-picker-status');
      const gamePickerList = $('#game-picker-list');
      const closeGamePickerBtn = $('#close-game-picker-btn');
      let activeGameRequestToken = 0;
      let gamePickerReturnFocus = null;
      const saveArchiveBtn = $('#save-archive-btn');
      const archiveFeedback = $('#archive-feedback');
      const openArchiveButtons = $('.open-archive-btn');
      const archiveModal = $('#archive-modal');
      const archiveList = $('#archive-list');
      const archiveStatus = $('#archive-status');
      const closeArchiveBtn = $('#close-archive-btn');
      const clearArchiveBtn = $('#clear-archive-btn');
      let archiveReturnFocus = null;
      let archiveFeedbackTimeout = null;
      const ARCHIVE_STORAGE_KEY = 'cmr.reviewArchive.v1';
      const ARCHIVE_MAX_ENTRIES = 25;
      let archiveEntries = [];
      let storageAvailable = isLocalStorageAvailable();
      if (storageAvailable) {
        archiveEntries = loadArchiveEntriesFromStorage();
      }
      let lastFinalAnalysisText = '';
      let currentReviewMetadata = null;
      let pendingArchiveLoadNotice = null;

      applySavedFormState();
      bindPersistentInput('#player-name-input', 'playerName');
      bindPersistentInput('#pgn-input', 'pgnInput');
      $('#pgn-input').on('input', function () {
        invalidateAnalysisState();
      });
      bindPersistentInput('#final-analysis-input', 'finalAnalysisInput');
      bindPersistentInput('#depth-input', 'depthInput');
      bindPersistentInput('#threads-input', 'threadsInput', { sanitize: value => sanitizeEngineSetting('threads', value) });
      bindPersistentInput('#hash-input', 'hashInput', { sanitize: value => sanitizeEngineSetting('hash', value) });
      $('#player-name-input').on('input change', function () {
        const rawName = getRawPlayerNameInput();
        if (rawName) {
          updateReviewPlayerColorFromGame(game, rawName);
        } else {
          setReviewPlayerColor(null);
        }
        updatePlayerOutcomeFromGame(game);
        if (Array.isArray(lastEngineMoveRecords) && lastEngineMoveRecords.length) {
          automatedMoveInsights = computeAutomatedMoveInsights(lastEngineMoveRecords, reviewPlayerColor, playerGameOutcome);
          automatedReviewText = buildAutomatedReviewText(automatedMoveInsights);
        }
        refreshStockfishOutput();
      });

      if (loadChessComBtn.length) {
        loadChessComBtn.data('defaultLabel', loadChessComBtn.text().trim() || 'Browse Chess.com games');
        loadChessComBtn.on('click', function () { handleGameLoad('chesscom'); });
      }
      if (loadLichessBtn.length) {
        loadLichessBtn.data('defaultLabel', loadLichessBtn.text().trim() || 'Browse Lichess games');
        loadLichessBtn.on('click', function () { handleGameLoad('lichess'); });
      }
      if (closeGamePickerBtn.length) {
        closeGamePickerBtn.on('click', function () { closeGamePickerModal(); });
      }
      if (gamePickerModal.length) {
        gamePickerModal.on('click', function (evt) {
          if (evt.target === this) { closeGamePickerModal(); }
        });
      }
      $(document).on('keydown', function (evt) {
        if (evt.key === 'Escape' || evt.key === 'Esc') {
          if (archiveModal.length && !archiveModal.hasClass('hidden')) {
            evt.preventDefault();
            closeArchiveModal();
            return;
          }
          if (gamePickerModal.length && !gamePickerModal.hasClass('hidden')) {
            evt.preventDefault();
            closeGamePickerModal();
          }
        }
      });

      if (saveArchiveBtn.length) {
        saveArchiveBtn.on('click', function () {
          handleSaveArchiveEntry();
        });
      }
      if (openArchiveButtons.length) {
        openArchiveButtons.on('click', function () {
          if (!storageAvailable) {
            showArchiveFeedback('Saving is unavailable in this browser session.', 'error');
            return;
          }
          openArchiveModal();
        });
      }
      if (archiveModal.length) {
        archiveModal.on('click', function (evt) {
          if (evt.target === this) { closeArchiveModal(); }
        });
      }
      if (closeArchiveBtn.length) {
        closeArchiveBtn.on('click', function () { closeArchiveModal(); });
      }
      if (clearArchiveBtn.length) {
        clearArchiveBtn.on('click', function () {
          handleClearArchive();
        });
      }
      if (archiveList.length) {
        archiveList.on('click', 'button[data-archive-action]', function () {
          const action = $(this).attr('data-archive-action');
          const id = $(this).attr('data-archive-id');
          if (action === 'load') {
            loadArchiveEntryById(id);
          } else if (action === 'delete') {
            handleDeleteArchiveEntry(id);
          }
        });
      }

      function handleGameSelection(game) {
        if (!game || !game.pgn) {
          showGameLoaderFeedback('Unable to load the selected game.', 'error');
          return;
        }
        closeGamePickerModal();
        $('#pgn-input').val(game.pgn).trigger('input');
        $('#pgn-input').focus();
        lastAnnotatedPgn = '';
        updateFormState('annotatedPgn', '');
        $('#stockfish-output').val('');
        updateFormState('stockfishOutput', '');
        const headers = parsePgnHeaders(game.pgn);
        setReviewPlayerColor(game && game.color ? game.color : null);
        if (getRawPlayerNameInput()) {
          updateReviewPlayerColorFromHeaders(headers, getPlayerName(), { clearOnMiss: false });
        }
        updatePlayerOutcomeFromHeaders(headers);
        lastEngineMoveRecords = null;
        automatedMoveInsights = { moves: [], summary: null, moveOfGame: null };
        automatedReviewText = '';
        const detailParts = [];
        if (game.colorLabel && game.colorLabel !== 'Unknown color') detailParts.push(game.colorLabel);
        if (game.resultLabel) detailParts.push(game.resultLabel);
        const detail = detailParts.length ? ` (${detailParts.join(' • ')})` : '';
        const opponent = game.opponent || 'opponent';
        const source = game.sourceLabel || 'Game';
        showGameLoaderFeedback(`Loaded ${source} game vs ${opponent}${detail}.`, 'success');
        lastFinalAnalysisText = '';
        currentReviewMetadata = null;
        updateArchiveControls();
      }

      async function handleGameLoad(source) {
        const button = source === 'chesscom' ? loadChessComBtn : loadLichessBtn;
        const defaultLabel = button && button.length ? (button.data('defaultLabel') || button.text().trim()) : '';
        const sourceLabel = source === 'chesscom' ? 'Chess.com' : 'Lichess';
        const usernameRaw = $('#player-name-input').val();
        const username = usernameRaw == null ? '' : String(usernameRaw).trim();
        if (!username) {
          showGameLoaderFeedback('Enter a username before loading games.', 'error');
          if ($('#player-name-input').length) $('#player-name-input').focus();
          return;
        }
        hideGameLoaderFeedback();
        if (button && button.length) {
          button.prop('disabled', true).text(`Loading ${sourceLabel}…`);
        }
        const requestToken = ++activeGameRequestToken;
        openGamePickerModal(sourceLabel, username);
        setGamePickerStatus(`Fetching recent ${sourceLabel} games for ${username}…`, 'info');
        clearGamePickerList();
        try {
          const loader = source === 'chesscom' ? fetchChessComGames : fetchLichessGames;
          const games = await loader(username);
          if (requestToken !== activeGameRequestToken) return;
          if (!games.length) {
            setGamePickerStatus(`No recent ${sourceLabel} games found for ${username}.`, 'info');
            return;
          }
          renderGamePickerList(games);
          setGamePickerStatus('Choose a game to load into the PGN field.', 'info');
        } catch (err) {
          if (requestToken !== activeGameRequestToken) return;
          console.error('Game fetch failed:', err);
          const message = err && err.message ? err.message : `Unable to load ${sourceLabel} games.`;
          setGamePickerStatus(message, 'error');
        } finally {
          if (button && button.length) {
            button.prop('disabled', false).text(defaultLabel || (source === 'chesscom' ? 'Browse Chess.com games' : 'Browse Lichess games'));
          }
        }
      }

      function showGameLoaderFeedback(message, tone) {
        if (!gameLoaderFeedback.length) return;
        const toneClass = tone === 'error' ? 'text-red-300' : tone === 'success' ? 'text-emerald-300' : 'text-sky-300';
        gameLoaderFeedback
          .removeClass('hidden text-red-300 text-emerald-300 text-sky-300 text-gray-300')
          .addClass(toneClass)
          .text(message);
      }

      function hideGameLoaderFeedback() {
        if (!gameLoaderFeedback.length) return;
        gameLoaderFeedback
          .addClass('hidden')
          .removeClass('text-red-300 text-emerald-300 text-sky-300 text-gray-300')
          .text('');
      }

      function openGamePickerModal(sourceLabel, username) {
        if (!gamePickerModal.length) return;
        gamePickerReturnFocus = document.activeElement;
        const titleParts = ['Select a game'];
        if (sourceLabel) titleParts[0] = `Select a ${sourceLabel} game`;
        if (username) titleParts.push(`for ${username}`);
        if (gamePickerTitle.length) gamePickerTitle.text(titleParts.join(' '));
        gamePickerModal.removeClass('hidden').attr('aria-hidden', 'false');
        if (closeGamePickerBtn.length) {
          setTimeout(() => { closeGamePickerBtn.trigger('focus'); }, 0);
        }
      }

      function closeGamePickerModal() {
        if (!gamePickerModal.length) return;
        activeGameRequestToken++;
        gamePickerModal.addClass('hidden').attr('aria-hidden', 'true');
        clearGamePickerList();
        setGamePickerStatus('', 'info');
        if (gamePickerReturnFocus && typeof gamePickerReturnFocus.focus === 'function') {
          try { gamePickerReturnFocus.focus(); } catch (err) { /* noop */ }
        }
        gamePickerReturnFocus = null;
      }

      function setGamePickerStatus(message, tone) {
        if (!gamePickerStatus.length) return;
        gamePickerStatus
          .removeClass('text-red-300 text-emerald-300 text-sky-300 text-gray-300 hidden')
          .addClass(message ? '' : 'hidden')
          .text(message || '');
        if (!message) return;
        const toneClass = tone === 'error' ? 'text-red-300' : tone === 'success' ? 'text-emerald-300' : tone === 'info' ? 'text-sky-300' : 'text-gray-300';
        gamePickerStatus.addClass(toneClass);
      }

      function clearGamePickerList() {
        if (!gamePickerList.length) return;
        gamePickerList.empty();
      }

      function renderGamePickerList(games) {
        if (!gamePickerList.length) return;
        clearGamePickerList();
        games.forEach((game, index) => {
          const item = $('<button type="button" class="w-full text-left bg-[#0b0e15] border border-[#1f2937] hover:bg-[#172033] rounded-lg p-3 focus:outline-none focus-visible:ring-2 focus-visible:ring-blue-500"></button>');
          item.data('game', game);
          const titleRow = $('<div class="flex items-center justify-between gap-2"></div>');
          const titleText = game.summary || `Game ${index + 1}`;
          $('<span class="font-semibold text-gray-100"></span>').text(titleText).appendTo(titleRow);
          const badgeText = game.resultCode ? game.resultCode : (game.resultLabel || '');
          if (badgeText) {
            $('<span class="text-xs font-semibold px-2 py-0.5 rounded bg-[#1f2937] text-gray-200"></span>').text(badgeText).appendTo(titleRow);
          }
          item.append(titleRow);
          const subtitleParts = [];
          if (game.sourceLabel) subtitleParts.push(game.sourceLabel);
          if (game.colorLabel && game.colorLabel !== 'Unknown color') subtitleParts.push(game.colorLabel);
          if (game.dateLabel) subtitleParts.push(game.dateLabel);
          if (subtitleParts.length) {
            $('<div class="mt-2 text-sm text-gray-300"></div>').text(subtitleParts.join(' • ')).appendTo(item);
          }
          const detailParts = [];
          if (game.eventLabel) detailParts.push(game.eventLabel);
          if (game.timeControlLabel) detailParts.push(game.timeControlLabel);
          if (game.siteLabel) detailParts.push(game.siteLabel);
          if (game.speedLabel) detailParts.push(game.speedLabel);
          if (game.ratingLabel) detailParts.push(game.ratingLabel);
          const detailLine = detailParts.join(' • ');
          if (detailLine) {
            $('<div class="mt-2 text-xs text-gray-400"></div>').text(detailLine).appendTo(item);
          }
          item.on('click', function () {
            const selected = $(this).data('game');
            handleGameSelection(selected);
          });
          gamePickerList.append(item);
        });
      }

      async function fetchChessComGames(username) {
        const normalized = String(username || '').trim();
        if (!normalized) return [];
        const lower = normalized.toLowerCase();
        const archivesUrl = `https://api.chess.com/pub/player/${encodeURIComponent(normalized)}/games/archives`;
        let archiveResponse;
        try {
          archiveResponse = await fetch(archivesUrl, { mode: 'cors' });
        } catch (err) {
          throw new Error('Unable to reach Chess.com. Check your connection and try again.');
        }
        if (!archiveResponse.ok) {
          if (archiveResponse.status === 404) {
            throw new Error(`Chess.com user "${normalized}" was not found.`);
          }
          throw new Error(`Chess.com request failed (status ${archiveResponse.status}).`);
        }
        let archiveJson;
        try {
          archiveJson = await archiveResponse.json();
        } catch (err) {
          throw new Error('Received an unexpected response from Chess.com.');
        }
        const archiveList = Array.isArray(archiveJson.archives) ? archiveJson.archives : [];
        if (!archiveList.length) return [];
        const archiveUrls = archiveList.slice(-3).reverse();
        const collected = [];
        for (const url of archiveUrls) {
          if (!url) continue;
          try {
            const resp = await fetch(url, { mode: 'cors' });
            if (!resp.ok) continue;
            const data = await resp.json();
            if (data && Array.isArray(data.games)) {
              data.games.forEach(game => collected.push(game));
            }
          } catch (err) {
            console.warn('Failed to load Chess.com archive', url, err);
          }
          if (collected.length >= 40) break;
        }
        const mapped = collected
          .map(game => mapChessComGame(game, normalized, lower))
          .filter(Boolean);
        mapped.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
        return mapped.slice(0, 30);
      }

      function mapChessComGame(game, username, usernameLower) {
        if (!game || !game.pgn) return null;
        const headers = parsePgnHeaders(game.pgn);
        const whiteNameRaw = headers.White || (game.white && game.white.username) || '';
        const blackNameRaw = headers.Black || (game.black && game.black.username) || '';
        const whiteName = whiteNameRaw ? String(whiteNameRaw).trim() : '';
        const blackName = blackNameRaw ? String(blackNameRaw).trim() : '';
        const whiteLower = whiteName.toLowerCase();
        const blackLower = blackName.toLowerCase();
        let color = null;
        if (whiteLower === usernameLower) {
          color = 'white';
        } else if (blackLower === usernameLower) {
          color = 'black';
        } else if (game.white && typeof game.white.username === 'string' && game.white.username.toLowerCase() === usernameLower) {
          color = 'white';
        } else if (game.black && typeof game.black.username === 'string' && game.black.username.toLowerCase() === usernameLower) {
          color = 'black';
        }
        const opponent = color === 'white'
          ? (blackName || (game.black && game.black.username) || 'Unknown opponent')
          : color === 'black'
            ? (whiteName || (game.white && game.white.username) || 'Unknown opponent')
            : (whiteName && blackName ? `${whiteName} vs ${blackName}` : 'Unknown opponent');
        const colorLabel = color === 'white' ? 'White' : color === 'black' ? 'Black' : 'Unknown color';
        const resultCodeRaw = headers.Result || '';
        const resultCode = String(resultCodeRaw).trim();
        const resultLabel = describeResult(resultCode);
        const timestamp = timestampFromHeaders(headers)
          || normalizeTimestamp(game.end_time)
          || normalizeTimestamp(game.start_time);
        const dateLabel = formatDateTime(timestamp);
        const timeControlLabel = formatTimeControl(headers.TimeControl);
        const eventLabel = headers.Event || '';
        let siteLabel = headers.Site || '';
        if (!siteLabel) {
          try {
            siteLabel = game.url ? new URL(game.url).hostname.replace(/^www\./, '') : 'Chess.com';
          } catch (err) {
            siteLabel = 'Chess.com';
          }
        }
        const ratingYou = color === 'white' ? getNumeric(game.white && game.white.rating) : color === 'black' ? getNumeric(game.black && game.black.rating) : null;
        const ratingOpp = color === 'white' ? getNumeric(game.black && game.black.rating) : color === 'black' ? getNumeric(game.white && game.white.rating) : null;
        const ratingParts = [];
        if (ratingYou != null) ratingParts.push(`You: ${ratingYou}`);
        if (ratingOpp != null) ratingParts.push(`Opp: ${ratingOpp}`);
        const ratingLabel = ratingParts.join(' • ');
        const summaryOpponent = opponent || 'opponent';
        const summary = color && color !== 'unknown'
          ? `${colorLabel} vs ${summaryOpponent}`
          : `${whiteName || 'White'} vs ${blackName || 'Black'}`;
        const resultCodeDisplay = resultCode && resultCode !== '*' ? resultCode : '';
        const idSource = game.url || game.uuid || `${timestamp || Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
        return {
          id: `chesscom-${idSource}`,
          source: 'chesscom',
          sourceLabel: 'Chess.com',
          pgn: game.pgn,
          color,
          colorLabel,
          opponent: summaryOpponent,
          resultCode: resultCodeDisplay,
          resultLabel,
          timestamp,
          dateLabel,
          eventLabel,
          siteLabel,
          timeControlLabel,
          ratingLabel,
          summary,
          speedLabel: ''
        };
      }

      async function fetchLichessGames(username) {
        const normalized = String(username || '').trim();
        if (!normalized) return [];
        const lower = normalized.toLowerCase();
        const params = new URLSearchParams({
          max: '20',
          pgnInJson: 'true',
          clocks: 'false',
          evals: 'false',
          opening: 'false'
        });
        const url = `https://lichess.org/api/games/user/${encodeURIComponent(normalized)}?${params.toString()}`;
        let response;
        try {
          response = await fetch(url, {
            headers: { 'Accept': 'application/x-ndjson' },
            mode: 'cors'
          });
        } catch (err) {
          throw new Error('Unable to reach Lichess. Check your connection and try again.');
        }
        if (!response.ok) {
          if (response.status === 404) {
            throw new Error(`Lichess user "${normalized}" was not found.`);
          }
          throw new Error(`Lichess request failed (status ${response.status}).`);
        }
        const payload = await response.text();
        if (!payload) return [];
        const lines = payload.split('\n');
        const mapped = [];
        for (const line of lines) {
          const trimmed = line.trim();
          if (!trimmed) continue;
          try {
            const data = JSON.parse(trimmed);
            if (data && data.pgn) {
              const mappedGame = mapLichessGame(data, normalized, lower);
              if (mappedGame) mapped.push(mappedGame);
            }
          } catch (err) {
            console.warn('Failed to parse Lichess game payload', err);
          }
          if (mapped.length >= 40) break;
        }
        mapped.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
        return mapped.slice(0, 30);
      }

      function mapLichessGame(game, username, usernameLower) {
        if (!game || !game.pgn) return null;
        const headers = parsePgnHeaders(game.pgn);
        const whiteNameRaw = headers.White || pickLichessName(game.players && game.players.white);
        const blackNameRaw = headers.Black || pickLichessName(game.players && game.players.black);
        const whiteName = whiteNameRaw ? String(whiteNameRaw).trim() : '';
        const blackName = blackNameRaw ? String(blackNameRaw).trim() : '';
        const whiteLower = whiteName.toLowerCase();
        const blackLower = blackName.toLowerCase();
        let color = null;
        if (whiteLower === usernameLower) {
          color = 'white';
        } else if (blackLower === usernameLower) {
          color = 'black';
        } else {
          const whiteFallback = pickLichessName(game.players && game.players.white).toLowerCase();
          const blackFallback = pickLichessName(game.players && game.players.black).toLowerCase();
          if (whiteFallback === usernameLower) {
            color = 'white';
          } else if (blackFallback === usernameLower) {
            color = 'black';
          }
        }
        const opponent = color === 'white'
          ? (blackName || pickLichessName(game.players && game.players.black) || 'Unknown opponent')
          : color === 'black'
            ? (whiteName || pickLichessName(game.players && game.players.white) || 'Unknown opponent')
            : (whiteName && blackName ? `${whiteName} vs ${blackName}` : 'Unknown opponent');
        const colorLabel = color === 'white' ? 'White' : color === 'black' ? 'Black' : 'Unknown color';
        let resultCode = (headers.Result || '').trim();
        if (!resultCode || resultCode === '*') {
          const winner = game.winner ? String(game.winner).toLowerCase() : '';
          if (winner === 'white') {
            resultCode = '1-0';
          } else if (winner === 'black') {
            resultCode = '0-1';
          } else if ((game.status || '').toLowerCase() === 'draw') {
            resultCode = '1/2-1/2';
          }
        }
        const resultLabel = describeResult(resultCode);
        const timestamp = timestampFromHeaders(headers)
          || normalizeTimestamp(game.lastMoveAt)
          || normalizeTimestamp(game.createdAt);
        const dateLabel = formatDateTime(timestamp);
        const eventLabel = headers.Event || game.event || '';
        const siteLabel = headers.Site || 'Lichess';
        let timeControlLabel = formatTimeControl(headers.TimeControl);
        if (!timeControlLabel && game.clock && Number.isFinite(Number(game.clock.initial)) && Number.isFinite(Number(game.clock.increment))) {
          timeControlLabel = formatTimeControl(`${game.clock.initial}+${game.clock.increment}`);
        }
        const ratingWhite = game.players && game.players.white ? getNumeric(game.players.white.rating) : null;
        const ratingBlack = game.players && game.players.black ? getNumeric(game.players.black.rating) : null;
        const ratingYou = color === 'white' ? ratingWhite : color === 'black' ? ratingBlack : null;
        const ratingOpp = color === 'white' ? ratingBlack : color === 'black' ? ratingWhite : null;
        const ratingParts = [];
        if (ratingYou != null) ratingParts.push(`You: ${ratingYou}`);
        if (ratingOpp != null) ratingParts.push(`Opp: ${ratingOpp}`);
        const ratingLabel = ratingParts.join(' • ');
        const speedLabel = buildSpeedLabel(game.speed, game.perf, game.variant);
        const summaryOpponent = opponent || 'opponent';
        const summary = color && color !== 'unknown'
          ? `${colorLabel} vs ${summaryOpponent}`
          : `${whiteName || 'White'} vs ${blackName || 'Black'}`;
        const resultCodeDisplay = resultCode && resultCode !== '*' ? resultCode : '';
        const idSource = game.id || game.url || `${timestamp || Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
        return {
          id: `lichess-${idSource}`,
          source: 'lichess',
          sourceLabel: 'Lichess',
          pgn: game.pgn,
          color,
          colorLabel,
          opponent: summaryOpponent,
          resultCode: resultCodeDisplay,
          resultLabel,
          timestamp,
          dateLabel,
          eventLabel,
          siteLabel,
          timeControlLabel,
          ratingLabel,
          summary,
          speedLabel
        };
      }

      function parsePgnHeaders(pgn) {
        const headers = {};
        if (!pgn) return headers;
        const headerRegex = /\[(\w+)\s+"([^"]*)"\]/g;
        let match;
        while ((match = headerRegex.exec(pgn)) !== null) {
          headers[match[1]] = match[2];
        }
        return headers;
      }

      function normalizeTimestamp(value) {
        if (value == null) return null;
        const numeric = Number(value);
        if (!Number.isFinite(numeric) || numeric <= 0) return null;
        if (numeric < 1e11) {
          return numeric * 1000;
        }
        return numeric;
      }

      function timestampFromHeaders(headers) {
        if (!headers) return null;
        const dateRaw = headers.UTCDate || headers.Date;
        if (!dateRaw) return null;
        const dateMatch = String(dateRaw).match(/^\s*(\d{4})[.\-](\d{2})[.\-](\d{2})\s*$/);
        if (!dateMatch) return null;
        const sanitizedDate = `${dateMatch[1]}-${dateMatch[2]}-${dateMatch[3]}`;
        const timeRaw = headers.UTCTime || headers.Time;
        const sanitizedTime = normalizeTimeComponent(timeRaw);
        const isoCandidate = `${sanitizedDate}T${sanitizedTime}`;
        const withZone = headers.UTCDate || headers.UTCTime ? `${isoCandidate}Z` : isoCandidate;
        const parsed = Date.parse(withZone);
        return Number.isFinite(parsed) ? parsed : null;
      }

      function normalizeTimeComponent(value) {
        if (!value) return '00:00:00';
        const str = String(value).trim();
        const match = str.match(/^(\d{1,2})(?::(\d{1,2}))?(?::(\d{1,2}))?$/);
        if (!match) return '00:00:00';
        const hours = match[1].padStart(2, '0');
        const minutes = (match[2] || '0').padStart(2, '0');
        const seconds = (match[3] || '0').padStart(2, '0');
        return `${hours}:${minutes}:${seconds}`;
      }

      function formatDateTime(timestamp) {
        if (!timestamp) return '';
        try {
          const date = new Date(timestamp);
          if (Number.isNaN(date.getTime())) return '';
          return new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' }).format(date);
        } catch (err) {
          return '';
        }
      }

      function formatTimeControl(value) {
        if (!value) return '';
        const normalized = String(value).trim();
        if (!normalized || normalized === '-' || normalized === '?') return '';
        if (normalized.includes('+')) {
          const [baseStr, incStr] = normalized.split('+');
          const base = Number(baseStr);
          const increment = Number(incStr);
          if (Number.isFinite(base) && Number.isFinite(increment)) {
            const baseDisplay = base >= 60 && base % 60 === 0
              ? `${base / 60}`
              : `${base}s`;
            return `TC ${baseDisplay}+${increment}`;
          }
        }
        return `TC ${normalized}`;
      }

      function describeResult(resultCode) {
        const normalized = (resultCode || '').trim();
        if (!normalized || normalized === '*') return 'In progress';
        if (normalized === '1-0') return 'White won (1-0)';
        if (normalized === '0-1') return 'Black won (0-1)';
        if (normalized === '1/2-1/2') return 'Draw (½-½)';
        return normalized;
      }

      function getNumeric(value) {
        const numeric = Number(value);
        return Number.isFinite(numeric) ? numeric : null;
      }

      function pickLichessName(player) {
        if (!player) return '';
        if (player.user && player.user.name) return String(player.user.name);
        if (player.userId) return String(player.userId);
        if (player.name) return String(player.name);
        if (player.aiLevel != null) return `Stockfish L${player.aiLevel}`;
        return '';
      }

      function buildSpeedLabel(speed, perf, variant) {
        const parts = [];
        if (speed) parts.push(capitalizeFirst(speed));
        if (variant && variant !== 'standard') parts.push(capitalizeFirst(variant));
        if (perf && perf !== speed && perf !== variant) parts.push(capitalizeFirst(perf));
        return parts.join(' • ');
      }

      function capitalizeFirst(value) {
        const str = String(value || '').trim();
        if (!str) return '';
        return str.charAt(0).toUpperCase() + str.slice(1);
      }


      // ====== Stockfish (same-origin Worker) ======
      const ENGINE_BUNDLE_VERSION = '20240609';
      const LOCAL_ENGINE = `engine/stockfish-nnue-16-single.js?v=${ENGINE_BUNDLE_VERSION}`;
      function resolveWorkerUrl(path) {
        if (!path) return path;
        try {
          const normalized = String(path);
          if (/^(?:[a-z]+:)?\/\//i.test(normalized) || normalized.startsWith('blob:') || normalized.startsWith('data:')) {
            return normalized;
          }
          if (typeof window === 'undefined' || !window.location) {
            return normalized;
          }
          const { origin, pathname } = window.location;
          let base = origin || '';
          if (pathname && typeof pathname === 'string') {
            const dir = pathname.replace(/[^/]*$/, '');
            base = base + dir;
          }
          if (!base) return normalized;
          return new URL(normalized, base).toString();
        } catch (err) {
          console.warn('Falling back to raw worker path due to resolution error:', err);
          return path;
        }
      }
      const ENGINE_GO_OPTIONS = { depth: 24 };
      let engineWorker = null;
      let engineReady = false;
      let currentMultiPvSetting = 1;
      let engineInitTimeout = null;
      let lastInfoMsg = '';
      let currentScoreResolver = null;
      let showBestMove = false;
      const toggleBestBtn = $('#toggle-eval-btn');
      const defaultBestButtonLabel = toggleBestBtn.length ? (toggleBestBtn.text().trim() || 'Best') : 'Best';
      let primaryBestMoveSquares = null;
      let secondaryBestMoveSquares = null;
      let arrowCanvas = null;
      let arrowCtx = null;
      let lastBestMove = null;
      let lastSecondBestMove = null;
      let bestMoveAnalysisToken = 0;
      let bestMoveActiveToken = 0;
      let bestMoveUpdateTimeout = null;
      let pendingBestMoveInfo = null;
      let lastBestMoveUpdate = 0;
      let bestMoveFen = null;
      let bestMoveFenNormalized = null;
      let pendingBestMoveVisualData = null;
      let bestMoveVisualRetryHandle = null;
      let bestMoveResponseTimeoutHandle = null;
      let bestMoveStallTimeoutHandle = null;
      let bestMovePvMap = {};
      const BEST_MOVE_UPDATE_INTERVAL = 250;
      const BEST_MOVE_VISUAL_RETRY_DELAY = 50;
      const BEST_MOVE_VISUAL_RETRY_LIMIT = 20;
      const BEST_MOVE_RESPONSE_TIMEOUT = 2500;
      const BEST_MOVE_STALL_TIMEOUT = 9000;
      const PUZZLE_MAX_ALT_MOVES = 4;
      const PUZZLE_CLOSE_SCORE_THRESHOLD = 35;
      const PUZZLE_MATE_SCORE = 100000;
      const ENGINE_REQUEST_TIMEOUT_MS = 8000;

      function setEngineMultiPv(value, options = {}) {
        const numeric = Number.parseInt(value, 10);
        if (!Number.isFinite(numeric) || numeric < 1) return;
        const force = options && options.force;
        if (!force && currentMultiPvSetting === numeric) return;
        currentMultiPvSetting = numeric;
        if (!engineWorker) return;
        engineWorker.postMessage(`setoption name MultiPV value ${numeric}`);
      }

      function configureEngineOptions() {
        if (!engineWorker) return;
        engineReady = false;
        $('#analyze-pgn-btn').prop('disabled', true);
        const depthInfo = getDepthSettingInfo();
        const threadVal = sanitizeEngineSetting('threads', $('#threads-input').val());
        const hashVal = sanitizeEngineSetting('hash', $('#hash-input').val());
        $('#threads-input').val(threadVal);
        $('#hash-input').val(hashVal);
        if (depthInfo.valid) {
          ENGINE_GO_OPTIONS.depth = depthInfo.value;
        }
        const options = { Threads: threadVal, Hash: hashVal };
        Object.entries(options).forEach(([name, value]) => {
          engineWorker.postMessage(`setoption name ${name} value ${value}`);
        });
        setEngineMultiPv(1);
        engineWorker.postMessage('isready');
      }

      function showEngineStatus(opts) {
        if (!engineStatusBanner.length) return;
        const tone = opts && opts.tone ? String(opts.tone) : 'info';
        const message = opts && opts.message ? String(opts.message) : '';
        const detail = opts && opts.detail ? String(opts.detail) : '';
        const showRetry = !!(opts && opts.showRetry);
        engineStatusBanner
          .removeClass('status-info status-error status-visible')
          .addClass('status-visible')
          .addClass(tone === 'error' ? 'status-error' : 'status-info');
        if (engineStatusMessage.length) engineStatusMessage.text(message);
        if (engineStatusDetail.length) {
          if (detail) {
            engineStatusDetail.text(detail).removeClass('hidden');
          } else {
            engineStatusDetail.text('').addClass('hidden');
          }
        }
        if (retryEngineBtn.length) {
          if (showRetry) {
            retryEngineBtn.removeClass('hidden').prop('disabled', false);
          } else {
            retryEngineBtn.addClass('hidden');
          }
        }
      }

      function hideEngineStatus() {
        if (!engineStatusBanner.length) return;
        engineStatusBanner.removeClass('status-visible status-info status-error');
        if (engineStatusMessage.length) engineStatusMessage.text('');
        if (engineStatusDetail.length) engineStatusDetail.text('').addClass('hidden');
        if (retryEngineBtn.length) retryEngineBtn.addClass('hidden');
      }

      function handleEngineLoadFailure(detailMessage) {
        engineReady = false;
        $('#analyze-pgn-btn').prop('disabled', true).text('Engine Load Error');
        showEngineStatus({
          tone: 'error',
          message: 'Stockfish engine failed to load.',
          detail: detailMessage || 'Please retry or continue without engine analysis.',
          showRetry: true
        });
      }

      function initEngine(initial = false) {
        if (engineWorker) engineWorker.terminate();
        engineReady = false;
        currentMultiPvSetting = 1;
        if (initial) {
          $('#analyze-pgn-btn').prop('disabled', true).text('Loading Engine...');
        } else {
          $('#analyze-pgn-btn').prop('disabled', true);
        }
        showEngineStatus({
          tone: 'info',
          message: 'Loading Stockfish engine…',
          detail: 'This can take a few seconds on mobile devices.'
        });
        try {
          engineWorker = new Worker(resolveWorkerUrl(LOCAL_ENGINE));
        } catch (err) {
          console.error('Engine load error', err);
          handleEngineLoadFailure(err && err.message ? err.message : 'Worker could not be created.');
          return;
        }
        engineWorker.onerror = function (err) {
          console.error('Engine load error', err);
          handleEngineLoadFailure('Worker reported an error during initialization.');
        };
        engineWorker.onmessage = function (e) {
          const rawMsg = String(e.data || '');
          const msg = rawMsg.trim();
          if (msg === 'uciok') {
            configureEngineOptions();
          } else if (msg === 'readyok') {
            engineReady = true;
            clearTimeout(engineInitTimeout);
            $('#analyze-pgn-btn').prop('disabled', false).text('Analyze');
            hideEngineStatus();
          } else if (msg.startsWith('info')) {
            handleEngineInfoMessage(rawMsg);
          } else if (msg.startsWith('bestmove')) {
            const cp = /score cp (-?\d+)/.exec(lastInfoMsg);
            const mt = /score mate (-?\d+)/.exec(lastInfoMsg);
            const bmMatch = /bestmove\s(\S+)/.exec(msg);
            const bm = bmMatch ? bmMatch[1] : null;
            if (currentScoreResolver) {
              if (mt) {
                currentScoreResolver({ type: 'mate', value: parseInt(mt[1], 10), bestmove: bm });
              } else if (cp) {
                currentScoreResolver({ type: 'cp', value: parseInt(cp[1], 10), bestmove: bm });
              } else {
                currentScoreResolver({ type: 'cp', value: 0, bestmove: bm });
              }
              currentScoreResolver = null;
            }
          }
        };
        engineWorker.postMessage('uci');
        engineInitTimeout = setTimeout(() => {
          if (!engineReady) {
            engineWorker.terminate();
            handleEngineLoadFailure('Initialization timed out.');
          }
        }, 20000);
      }

      if (retryEngineBtn.length) {
        retryEngineBtn.on('click', function(){
          $(this).prop('disabled', true);
          initEngine(true);
        });
      }

      $('#depth-input, #threads-input, #hash-input').on('change', function(){ initEngine(); });

      initEngine(true);

      // Prompt (adds one-line Summary at the end)
      const ANALYSIS_PROMPT_TEMPLATE = `You are given:
1) A PGN with SAN moves and mover-centric deltas {…}.
2) An “Automated Insights” block listing each half-move with its FINAL classification (Book, Good, Forced, Inaccuracy, Mistake, Blunder, Misclick??, Great, Brilliant).
3) Precomputed Summary counts, Accuracy, Move of the game.
4) The name of the player being coached: eugenime.
Do NOT change any classification or counts.

TASK
- Output exactly ONE line per half-move in this format:
  <move> - {<eval>} <classification>: <comment>
- Show ALL moves with their provided classification.
- At the end, output:
  Summary: Brilliant = X | Great = Y | Mistakes = Z | Blunders = W | Misclicks = V
  Accuracy: <Accuracy percentage>
  Narrative Summary: One-sentence overview of the game of the player being coached.
  Move of the game: <move> - {<eval>} <classification>: <one-sentence why it’s most impactful>

COMMENTING RULES
- You are addressing the player being coached.
- Comment every move.
- Keep comments SHORT (1–2 sentences), purely from SAN and obvious consequences:
  • checks (+/#), captures (what piece is taken if SAN makes it clear), promotions (=Q/R/B/N), castling.
  • immediate positional effects: “opens the e-file,” “weakens king safety,” “creates/advances a passed pawn,” “wins a rook/queen,” “keeps the attack,” “drives the king,” “loses coordination,” “concedes dark squares.”
- Do NOT include numeric evaluations or hidden engine lines.
- Do NOT re-evaluate or contradict any mate token in the eval:
  • {#N} = White has mate in N; {#-N} = Black has mate in N. You may say “starts/continues a forced mate” when such tokens appear or are flagged by the input’s insights.
- Do NOT change the provided classification. If the input marks a move as Great/Brilliant, explain why in positional terms (e.g., wins a rook/queen; keeps the mating attack; visible sacrifice that maintains the attack). If marked Mistake/Blunder/Misclick??, explain how it worsens the position (e.g., walks into checks; drops a piece; opens king; loses a passer).

DISCIPLINE
- Toggle movers correctly and use SAN exactly as given.
- Use the provided {eval} token exactly as given.
- No extra prose before or after the required sections.
- Be consistent and terse to minimize compute.

INPUT FORMAT (example)
<PGN headers and moves with deltas>
=== Automated Insights ===
<one line per half-move with FINAL classification>
Summary: Brilliant = X | Great = Y | Mistakes = Z | Blunders = W | Misclicks = V
Accuracy: <Accuracy percentage>
Move of the game: <move> - {<eval>} <classification>: <reason>

OUTPUT FORMAT (strict)
<move> - {<eval>} <classification>: <comment>
...
Summary: Brilliant = X | Great = Y | Mistakes = Z | Blunders = W | Misclicks = V
Accuracy: <Accuracy percentage>
Narrative Summary: <one sentence>
Move of the game: <move> - {<eval>} <classification>: <one sentence why>`;

      function getPlayerName() {
        const raw = $('#player-name-input').val();
        const trimmed = raw == null ? '' : String(raw).trim();
        return trimmed || DEFAULT_PLAYER_NAME;
      }

      function getRawPlayerNameInput() {
        const el = $('#player-name-input');
        if (!el.length) return '';
        const raw = el.val();
        return raw == null ? '' : String(raw).trim();
      }

      function normalizePlayerHandle(value) {
        if (value == null) return '';
        let normalized = String(value).trim();
        if (!normalized) return '';
        normalized = normalized.replace(/^@+/, '');
        normalized = normalized.replace(/\s*\([^)]*\)\s*$/, '');
        normalized = normalized.replace(/\s+/g, ' ');
        return normalized.toLowerCase();
      }

      function setReviewPlayerColor(color) {
        if (color === 'w' || color === 'b') {
          reviewPlayerColor = color;
          return reviewPlayerColor;
        }
        if (color === 'white') {
          reviewPlayerColor = 'w';
          return reviewPlayerColor;
        }
        if (color === 'black') {
          reviewPlayerColor = 'b';
          return reviewPlayerColor;
        }
        reviewPlayerColor = null;
        return reviewPlayerColor;
      }

      function determinePlayerColorFromHeaders(headers, playerName) {
        if (!headers) return null;
        const target = normalizePlayerHandle(playerName);
        if (!target) return null;
        const white = normalizePlayerHandle(headers.White);
        const black = normalizePlayerHandle(headers.Black);
        if (white && white === target) return 'w';
        if (black && black === target) return 'b';
        return null;
      }

      function updateReviewPlayerColorFromHeaders(headers, playerName, opts) {
        const detected = determinePlayerColorFromHeaders(headers, playerName);
        opts = opts || {};
        if (detected) return setReviewPlayerColor(detected);
        if (opts.clearOnMiss === false) return reviewPlayerColor;
        return setReviewPlayerColor(null);
      }

      function updateReviewPlayerColorFromGame(chess, playerName, opts) {
        opts = opts || {};
        if (!chess || typeof chess.header !== 'function') {
          if (opts.clearOnMiss === false) return reviewPlayerColor;
          return setReviewPlayerColor(null);
        }
        const headers = chess.header();
        return updateReviewPlayerColorFromHeaders(headers, playerName, opts);
      }

      function normalizeResultCodeForOutcome(code) {
        if (code == null) return '';
        let normalized = String(code).trim();
        if (!normalized) return '';
        normalized = normalized.replace(/½/g, '1/2');
        normalized = normalized.replace(/\s+/g, '');
        return normalized.toLowerCase();
      }

      function derivePlayerOutcome(resultCode, playerColor) {
        if (playerColor !== 'w' && playerColor !== 'b') return null;
        const normalized = normalizeResultCodeForOutcome(resultCode);
        if (!normalized || normalized === '*') return null;
        if (normalized.startsWith('1-0')) {
          return playerColor === 'w' ? 'win' : 'loss';
        }
        if (normalized.startsWith('0-1')) {
          return playerColor === 'b' ? 'win' : 'loss';
        }
        if (normalized.startsWith('1/2-1/2') || normalized.startsWith('0.5-0.5')) {
          return 'draw';
        }
        return null;
      }

      function updatePlayerOutcomeFromHeaders(headers) {
        const resultCode = headers && headers.Result ? headers.Result : '';
        playerGameOutcome = derivePlayerOutcome(resultCode, reviewPlayerColor);
        return playerGameOutcome;
      }

      function updatePlayerOutcomeFromGame(chess) {
        if (!chess || typeof chess.header !== 'function') {
          playerGameOutcome = null;
          return playerGameOutcome;
        }
        const headers = chess.header();
        return updatePlayerOutcomeFromHeaders(headers);
      }

      function normalizePlayerColorToken(color) {
        if (color === 'w' || color === 'b') return color;
        if (!color) return null;
        const lower = String(color).toLowerCase();
        if (lower === 'white') return 'w';
        if (lower === 'black') return 'b';
        return null;
      }

      function buildAnalysisPrompt(playerName) {
        const target = (playerName == null ? '' : String(playerName)).trim() || DEFAULT_PLAYER_NAME;
        return ANALYSIS_PROMPT_TEMPLATE.replace(/eugenime/gi, target);
      }

      function waitForEngineReady() {
        return new Promise(resolve => {
          if (engineReady) { resolve(); return; }
          const interval = setInterval(() => {
            if (engineReady) {
              clearInterval(interval);
              resolve();
            }
          }, 50);
        });
      }

      const classificationStyles = {
        brilliant: 'text-cyan-300',
        great: 'text-teal-300',
        good: 'text-green-400',
        book: 'text-blue-400',
        forced: 'text-gray-400',
        inaccuracy: 'text-yellow-400',
        mistake: 'text-orange-400',
        blunder: 'text-red-500',
        misclick: 'text-fuchsia-500',
        default: ''
      };
      const classificationMarkerColors = {
        brilliant: '#67e8f9',
        great: '#5eead4',
        blunder: '#ef4444',
        misclick: '#d946ef'
      };
      const highlightedGraphClassifications = new Set(['brilliant', 'great', 'blunder', 'misclick']);
      function normalizeClassificationKey(c) {
        return (c || '')
          .toLowerCase()
          .replace(/[\s!?]/g, '');
      }
      function getStyleForClassification(c) {
        return classificationStyles[normalizeClassificationKey(c)] || classificationStyles['default'];
      }
      const CLASSIFICATION_CANONICAL = {
        brilliant: 'Brilliant',
        great: 'Great',
        good: 'Good',
        book: 'Book',
        forced: 'Forced',
        inaccuracy: 'Inaccuracy',
        mistake: 'Mistake',
        blunder: 'Blunder',
        misclick: 'Misclick??'
      };
      const CLASSIFICATION_SEVERITY = {
        misclick: 5,
        blunder: 4,
        mistake: 3,
        inaccuracy: 2,
        forced: 1,
        good: 1,
        book: 1,
        great: 0,
        brilliant: 0
      };
      const SACRIFICE_PIECE_VALUES = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };
      const PREVIOUS_ERROR_KEYS = new Set(['mistake', 'blunder', 'misclick']);
      const MOVE_OF_GAME_TARGET_KEYS = new Set(['brilliant', 'great', 'blunder', 'misclick']);
      let automatedMoveInsights = { moves: [], summary: null, moveOfGame: null };
      let automatedReviewText = '';

      function canonicalizeClassification(value) {
        const key = normalizeClassificationKey(value);
        return CLASSIFICATION_CANONICAL[key] || (value || '');
      }

      function simplifyMoveObject(moveObj) {
        if (!moveObj) return null;
        return {
          san: moveObj.san,
          from: moveObj.from,
          to: moveObj.to,
          piece: moveObj.piece,
          captured: moveObj.captured || null,
          promotion: moveObj.promotion || null,
          color: moveObj.color,
          flags: moveObj.flags || ''
        };
      }

      function chooseMoreSevereClassification(current, target) {
        const currentKey = normalizeClassificationKey(current);
        const targetKey = normalizeClassificationKey(target);
        const currentRank = CLASSIFICATION_SEVERITY[currentKey] ?? -Infinity;
        const targetRank = CLASSIFICATION_SEVERITY[targetKey] ?? -Infinity;
        if (targetRank > currentRank) {
          return CLASSIFICATION_CANONICAL[targetKey] || canonicalizeClassification(target);
        }
        return canonicalizeClassification(current);
      }

      function computeBaseClassification(delta, plyIndex) {
        if (!Number.isFinite(delta)) return plyIndex < 7 ? 'Book' : 'Good';
        if (delta >= -2) return plyIndex < 7 ? 'Book' : 'Good';
        if (delta >= -9) return 'Inaccuracy';
        if (delta >= -20) return 'Mistake';
        if (delta >= -49) return 'Blunder';
        return 'Misclick??';
      }

      function isLikelySacrificeMove(moveRecord) {
        if (!moveRecord || !moveRecord.move) return false;
        const move = moveRecord.move;
        const piece = move.piece;
        if (!piece || piece === 'p' || piece === 'k') return false;
        const captured = move.captured;
        if (!captured) return false;
        const moverValue = SACRIFICE_PIECE_VALUES[piece] || 0;
        const capturedValue = SACRIFICE_PIECE_VALUES[captured] || 0;
        return moverValue >= capturedValue + 3;
      }

      function hadMateForMoverBefore(moveRecord) {
        if (!moveRecord) return false;
        const mateBefore = moveRecord.mateBefore;
        if (!Number.isFinite(mateBefore)) return false;
        if (moveRecord.color === 'w') return mateBefore > 0;
        return mateBefore < 0;
      }

      function retainsMateForMover(moveRecord) {
        if (!moveRecord) return false;
        const mateAfter = moveRecord.mateAfter;
        if (!Number.isFinite(mateAfter)) return false;
        if (mateAfter === 0) return true;
        if (moveRecord.color === 'w') return mateAfter > 0;
        return mateAfter < 0;
      }

      function opponentHasForcedMateAfter(moveRecord) {
        if (!moveRecord) return false;
        const mateAfter = moveRecord.mateAfter;
        if (!Number.isFinite(mateAfter)) return false;
        if (moveRecord.color === 'w') return mateAfter < 0;
        return mateAfter > 0;
      }

      function opponentHadForcedMateBefore(moveRecord) {
        if (!moveRecord) return false;
        const mateBefore = moveRecord.mateBefore;
        if (!Number.isFinite(mateBefore)) return false;
        if (moveRecord.color === 'w') return mateBefore < 0;
        return mateBefore > 0;
      }

      function mateDistance(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) return Infinity;
        return Math.abs(numeric);
      }

      function isForcedDefenseMove(moveRecord) {
        if (!moveRecord) return false;
        if (!opponentHasForcedMateAfter(moveRecord)) return false;
        if (!opponentHadForcedMateBefore(moveRecord)) return false;
        const mateAfterDistance = mateDistance(moveRecord.mateAfter);
        const mateBeforeDistance = mateDistance(moveRecord.mateBefore);
        if (!Number.isFinite(mateAfterDistance) || !Number.isFinite(mateBeforeDistance)) return false;
        if (mateBeforeDistance > mateAfterDistance) return false;
        const delta = Number(moveRecord.moverDelta);
        return Number.isFinite(delta) && delta >= 0;
      }

      function computeImpactScore(moveRecord) {
        if (!moveRecord) return -Infinity;
        let score = Math.abs(Number(moveRecord.moverDelta || 0));
        if (!Number.isFinite(score)) score = 0;
        if (opponentHasForcedMateAfter(moveRecord)) {
          score = Math.max(score, 950 - Math.min(100, Math.abs(moveRecord.mateAfter || 0)));
        }
        if (hadMateForMoverBefore(moveRecord) && !retainsMateForMover(moveRecord)) {
          score = Math.max(score, 940);
        }
        if (retainsMateForMover(moveRecord)) {
          score = Math.max(score, 960 - Math.min(100, Math.abs(moveRecord.mateAfter || 0)));
        }
        return score;
      }

      function computeAutomatedMoveInsights(rawMoves, playerColor, playerOutcome) {
        if (!Array.isArray(rawMoves) || !rawMoves.length) {
          return { moves: [], summary: null, moveOfGame: null };
        }

        const moves = rawMoves.map((mv, idx) => ({
          ...mv,
          index: idx,
          classification: computeBaseClassification(mv.moverDelta, idx)
        }));

        moves.forEach((mv) => {
          const opponentMateAfter = opponentHasForcedMateAfter(mv);
          const opponentMateBefore = opponentHadForcedMateBefore(mv);
          const mateAfterDistance = mateDistance(mv.mateAfter);
          const mateBeforeDistance = mateDistance(mv.mateBefore);
          const createdNewMate = opponentMateAfter && !opponentMateBefore;
          const worsenedExistingMate = opponentMateAfter && opponentMateBefore && mateAfterDistance < mateBeforeDistance;
          const maintainsOpponentMate = opponentMateAfter && opponentMateBefore && !worsenedExistingMate;
          mv._maintainsOpponentMate = maintainsOpponentMate;

          const lostMateForMover = hadMateForMoverBefore(mv) && !retainsMateForMover(mv);
          const needsSevere = createdNewMate || worsenedExistingMate || lostMateForMover;

          if (needsSevere) {
            const severeTarget = Number.isFinite(mv.moverDelta) && mv.moverDelta <= -50 ? 'Misclick??' : 'Blunder';
            mv.classification = chooseMoreSevereClassification(mv.classification, severeTarget);
          }
        });

        moves.forEach((mv, idx) => {
          if (!Number.isFinite(mv.moverDelta) || mv.moverDelta < 0) return;
          const prev = moves[idx - 1];
          if (!prev) return;
          const prevKey = normalizeClassificationKey(prev.classification);
          if (!PREVIOUS_ERROR_KEYS.has(prevKey)) return;
          mv.classification = isLikelySacrificeMove(mv) ? 'Brilliant' : 'Great';
        });

        const summaryCounts = {};
        Object.values(CLASSIFICATION_CANONICAL).forEach(name => { summaryCounts[name] = 0; });
        moves.forEach(mv => {
          const name = canonicalizeClassification(mv.classification);
          mv.classification = name;
          if (summaryCounts[name] == null) summaryCounts[name] = 0;
        });

        moves.forEach(mv => {
          if (mv._maintainsOpponentMate || isForcedDefenseMove(mv)) {
            mv.classification = 'Forced';
          }
          delete mv._maintainsOpponentMate;
        });

        const normalizedColor = playerColor === 'w' || playerColor === 'b'
          ? playerColor
          : playerColor === 'white'
            ? 'w'
            : playerColor === 'black'
              ? 'b'
              : null;
        const normalizedOutcome = playerOutcome === 'win' || playerOutcome === 'loss' || playerOutcome === 'draw'
          ? playerOutcome
          : null;
        const relevantMoves = normalizedColor ? moves.filter(mv => mv.color === normalizedColor) : moves;
        relevantMoves.forEach(mv => {
          if (summaryCounts[mv.classification] == null) summaryCounts[mv.classification] = 0;
          summaryCounts[mv.classification] += 1;
        });

        const totalMoves = relevantMoves.length;
        const totalGood = (summaryCounts['Brilliant'] || 0) + (summaryCounts['Great'] || 0) + (summaryCounts['Good'] || 0) + (summaryCounts['Book'] || 0) + (summaryCounts['Forced'] || 0);
        const totalBad = (summaryCounts['Mistake'] || 0) + (summaryCounts['Blunder'] || 0) + (summaryCounts['Misclick??'] || 0);
        const accuracy = totalMoves ? (totalGood / totalMoves) * 100 : 0;

        let largestDrop = null;
        let bestNonNegative = null;
        relevantMoves.forEach(mv => {
          const delta = Number(mv.moverDelta);
          if (!Number.isFinite(delta)) return;
          if (delta < 0) {
            if (!largestDrop || delta < Number(largestDrop.moverDelta) || (delta === Number(largestDrop.moverDelta) && mv.index < largestDrop.index)) {
              largestDrop = mv;
            }
          } else {
            if (!bestNonNegative || delta > Number(bestNonNegative.moverDelta) || (delta === Number(bestNonNegative.moverDelta) && mv.index < bestNonNegative.index)) {
              bestNonNegative = mv;
            }
          }
        });

        let moveOfGame = null;
        const opponentColor = normalizedColor === 'w' ? 'b' : normalizedColor === 'b' ? 'w' : null;
        const strongReplyClasses = new Set(['Good', 'Great', 'Brilliant']);
        const highlightFollowupClasses = new Set(['Brilliant', 'Great', 'Good']);
        const opponentErrorClasses = new Set(['Blunder', 'Misclick??', 'Inaccuracy']);

        if (normalizedColor && normalizedOutcome === 'loss' && opponentColor) {
          let targetedLossMove = null;
          moves.forEach((mv, idx) => {
            if (mv.color !== normalizedColor) return;
            const delta = Number(mv.moverDelta);
            if (!Number.isFinite(delta) || delta >= 0) return;
            const reply = moves[idx + 1];
            if (!reply || reply.color !== opponentColor) return;
            if (!strongReplyClasses.has(reply.classification)) return;
            if (!targetedLossMove || delta < Number(targetedLossMove.moverDelta) || (delta === Number(targetedLossMove.moverDelta) && idx < targetedLossMove.index)) {
              targetedLossMove = mv;
            }
          });
          if (targetedLossMove) {
            targetedLossMove.moveOfGameContext = 'loss-critical';
            moveOfGame = targetedLossMove;
          }
        } else if (normalizedColor && normalizedOutcome === 'win' && opponentColor) {
          let bestPunishingFollow = null;
          let bestRelatedMistake = null;
          moves.forEach((mv, idx) => {
            if (mv.color !== opponentColor) return;
            if (!opponentErrorClasses.has(mv.classification)) return;
            const delta = Number(mv.moverDelta);
            if (!Number.isFinite(delta)) return;
            const follow = moves[idx + 1];
            if (!follow || follow.color !== normalizedColor) return;
            if (!highlightFollowupClasses.has(follow.classification)) return;
            const currentBestDelta = bestRelatedMistake ? Number(bestRelatedMistake.moverDelta) : null;
            if (
              !bestPunishingFollow
              || currentBestDelta == null
              || delta < currentBestDelta
              || (delta === currentBestDelta && idx < bestRelatedMistake.index)
            ) {
              bestPunishingFollow = follow;
              bestRelatedMistake = mv;
            }
          });
          if (bestPunishingFollow && bestRelatedMistake) {
            bestPunishingFollow.moveOfGameContext = 'win-conversion';
            bestPunishingFollow.relatedMistakeIndex = bestRelatedMistake.index;
            moveOfGame = bestPunishingFollow;
          }
        }

        if (!moveOfGame) {
          if (largestDrop) moveOfGame = largestDrop;
          else if (bestNonNegative) moveOfGame = bestNonNegative;
        }

        return {
          moves,
          summary: {
            counts: summaryCounts,
            totalMoves,
            totalGood,
            totalBad,
            accuracy,
            playerColor: normalizedColor
          },
          moveOfGame
        };
      }

      function describeAutomatedImpact(delta) {
        const swing = Math.abs(Number(delta || 0));
        if (!Number.isFinite(swing)) return 'severe';
        if (swing >= 60) return 'devastating';
        if (swing >= 40) return 'huge';
        if (swing >= 25) return 'major';
        return 'costly';
      }

      function buildAutomatedComment(move) {
        if (!move) return '';
        const key = normalizeClassificationKey(move.classification);
        if (key === 'brilliant') {
          if (retainsMateForMover(move)) {
            return 'Auto insight: keeps the forced mate alive.';
          }
          if (isLikelySacrificeMove(move)) {
            return 'Auto insight: engine-backed sacrifice keeps the initiative.';
          }
          return 'Auto insight: Stockfish approves this tactic to extend the attack.';
        }
        if (key === 'great') {
          if (retainsMateForMover(move)) {
            return 'Auto insight: preserves the forced mate the engine spotted.';
          }
          if (Number.isFinite(move.moverDelta) && move.moverDelta > 0) {
            return 'Auto insight: extends the advantage according to Stockfish.';
          }
          return 'Auto insight: flagged as the only move that keeps control.';
        }
        if (key === 'blunder') {
          if (opponentHasForcedMateAfter(move)) {
            return 'Auto insight: allows a forced mate per Stockfish.';
          }
          return `Auto insight: ${describeAutomatedImpact(move.moverDelta)} drop flagged by Stockfish.`;
        }
        if (key === 'misclick') {
          if (opponentHasForcedMateAfter(move)) {
            return 'Auto insight: hands the opponent a forced mate.';
          }
          return `Auto insight: ${describeAutomatedImpact(move.moverDelta)} collapse detected by Stockfish.`;
        }
        if (key === 'forced') {
          return 'Auto insight: only defensive move available in an unavoidable mate.';
        }
        return '';
      }

      function buildAutomatedMoveOfGameComment(move) {
        if (!move) return '';
        const key = normalizeClassificationKey(move.classification);
        const context = move.moveOfGameContext || '';
        if (context === 'win-conversion' && (key === 'brilliant' || key === 'great' || key === 'good')) {
          return 'Auto insight: capitalizes on the opponent\'s slip to convert the game.';
        }
        if (context === 'loss-critical' && (key === 'mistake' || key === 'blunder' || key === 'misclick' || key === 'inaccuracy')) {
          return 'Auto insight: decisive error that the opponent punished with precise play.';
        }
        if (key === 'brilliant' || key === 'great') {
          if (retainsMateForMover(move)) {
            return 'Auto insight: decisive tactic that keeps the mate on the board.';
          }
          return 'Auto insight: engine-marked turning point that secured the advantage.';
        }
        if (key === 'mistake') {
          if (opponentHasForcedMateAfter(move)) {
            return 'Auto insight: error that hands the opponent a forcing sequence.';
          }
          return `Auto insight: ${describeAutomatedImpact(move.moverDelta)} mistake that swung the evaluation.`;
        }
        if (key === 'inaccuracy') {
          return `Auto insight: ${describeAutomatedImpact(move.moverDelta)} slip highlighted by Stockfish.`;
        }
        if (key === 'blunder' || key === 'misclick') {
          if (opponentHasForcedMateAfter(move)) {
            return 'Auto insight: pivotal mistake that yields a forced mate.';
          }
          return 'Auto insight: largest collapse in evaluation during the game.';
        }
        if (key === 'forced') {
          return 'Auto insight: best defensive try while staring down a forced mate.';
        }
        if (key === 'good' || key === 'book') {
          if (Number.isFinite(move.moverDelta) && move.moverDelta > 0) {
            return 'Auto insight: precise move that kept or grew the initiative.';
          }
          return 'Auto insight: steady choice that held the evaluation in balance.';
        }
        return 'Auto insight: most impactful swing detected by Stockfish.';
      }

      function formatAutomatedMoveLabel(move, idx) {
        if (!move) return '';
        const moveNumber = move.moveNumber || Math.floor(idx / 2) + 1;
        const prefix = move.color === 'b' ? `${moveNumber}...` : `${moveNumber}.`;
        return `${prefix} ${move.san}`;
      }

      function formatAutomatedEvaluation(move) {
        if (!move) return '{0}';
        if (move.evaluation) return move.evaluation;
        if (Number.isFinite(move.mateAfter)) return `{#${move.mateAfter}}`;
        if (Number.isFinite(move.mateBefore)) return `{#${move.mateBefore}}`;
        const deltaToken = formatDeltaBraced(move.moverDelta);
        if (deltaToken) return deltaToken;
        const whiteDeltaToken = formatDeltaBraced(move.whiteDelta);
        return whiteDeltaToken || '{0}';
      }

      function buildAutomatedReviewText(insights) {
        if (!insights || !Array.isArray(insights.moves) || !insights.moves.length) return '';
        const lines = [];
        insights.moves.forEach((move, idx) => {
          const label = formatAutomatedMoveLabel(move, idx);
          if (!label) return;
          const evaluation = formatAutomatedEvaluation(move);
          const classification = move.classification || 'Good';
          const comment = buildAutomatedComment(move);
          const commentSuffix = comment ? ` ${comment}` : '';
          lines.push(`${label} - ${evaluation} ${classification}:${commentSuffix}`);
        });

        const summaryLine = buildAutomatedSummaryLine(insights.summary);
        if (summaryLine) {
          lines.push('', summaryLine);
        }

        if (insights.moveOfGame) {
          const featured = insights.moveOfGame;
          const label = formatAutomatedMoveLabel(featured, featured.index || 0);
          const evaluation = formatAutomatedEvaluation(featured);
          const classification = featured.classification || 'Great';
          const justification = buildAutomatedMoveOfGameComment(featured);
          lines.push(`Move of the game: ${label} - ${evaluation} ${classification}: ${justification}`);
        }

        return lines.join('\n');
      }

      function buildAutomatedSummaryLine(summaryData) {
        if (!summaryData) return '';
        const counts = summaryData.counts || {};
        const brilliant = counts['Brilliant'] || 0;
        const great = counts['Great'] || 0;
        const mistakes = counts['Mistake'] || 0;
        const blunders = counts['Blunder'] || 0;
        const misclicks = counts['Misclick??'] || 0;
        const totalGood = summaryData.totalGood || 0;
        const totalBad = summaryData.totalBad || 0;
        const accuracy = summaryData.totalMoves ? (summaryData.totalGood / summaryData.totalMoves) * 100 : 0;
        return `Summary: Brilliant = ${brilliant} | Great = ${great} | Mistakes = ${mistakes} | Blunders = ${blunders} | Misclicks = ${misclicks}. ${totalGood} Total Good = (Brilliant + Great + Good + Book + Forced); ${totalBad} Total Bad = (Inaccuracies + Mistakes + Blunders + Misclicks). Accuracy: ${accuracy.toFixed(2)}%. Narrative Summary: Automated engine insights summary generated from Stockfish evaluations.`;
      }

      function convertAutomatedMoveToFeatured(autoMove) {
        if (!autoMove) return null;
        return {
          san: autoMove.san,
          displaySan: null,
          evaluation: autoMove.evaluation || null,
          classification: autoMove.classification || null,
          text: '',
          index: autoMove.index
        };
      }
      function normalizeSanToken(value) {
        if (!value) return '';
        let san = String(value).trim();
        san = san.replace(/^[0-9]+\.(?:\.\.)?\s*/, '');
        san = san.replace(/^\.{3}/, '');
        san = san.replace(/[!?]+$/, '');
        san = san.replace(/0-0-0/gi, 'O-O-O').replace(/0-0/gi, 'O-O');
        return san;
      }
      let selectedSquare = null;
      let moveSound = null;
      let captureSound = null;

      function ensureMoveSounds() {
        if (!moveSound) moveSound = createSoundEffect('sounds/move.mp3');
        if (!captureSound) captureSound = createSoundEffect('sounds/capture.mp3');
      }

      function createSoundEffect(src) {
        try {
          const audio = new Audio(src);
          audio.preload = 'auto';
          return audio;
        } catch (err) {
          console.warn('Unable to initialize sound asset:', src, err);
          return null;
        }
      }

      function playSoundEffect(audio) {
        if (!audio) return;
        try {
          audio.currentTime = 0;
          const playPromise = audio.play();
          if (playPromise && typeof playPromise.catch === 'function') {
            playPromise.catch(() => {});
          }
        } catch (err) {
          // Ignore playback errors (e.g., autoplay restrictions).
        }
      }

      function playMoveSound(move) {
        if (!move) return;
        ensureMoveSounds();
        const flags = move.flags || '';
        const isCapture = !!(move.captured || flags.includes('c') || flags.includes('e'));
        playSoundEffect(isCapture ? captureSound : moveSound);
      }
      function clearSelected() {
        $('#board .square-55d63').removeClass('selected');
        selectedSquare = null;
      }

      function isExploring() {
        return !!(explorationState && explorationState.active);
      }

      function startExploration(baseFen, baseIndex) {
        explorationState = {
          active: true,
          baseFen: baseFen || null,
          baseIndex: Number.isFinite(baseIndex) ? baseIndex : -1,
          moves: [],
          cursor: 0
        };
      }

      function clearExploration(forceUpdate) {
        const wasExploring = isExploring();
        explorationState = null;
        if (wasExploring || forceUpdate) {
          syncNavigationControls();
        }
        updateEvalGraphInteractivity();
      }

      function applyExplorationCursor(targetCursor) {
        if (!isExploring()) return;
        const maxMoves = explorationState.moves.length;
        const safeTarget = Math.max(0, Math.min(targetCursor, maxMoves));
        const baseFen = explorationState.baseFen;
        let loaded = false;
        if (baseFen) {
          loaded = game.load(baseFen);
        }
        if (!loaded) {
          game.reset();
        }
        explorationState.cursor = 0;
        let lastAppliedMove = null;
        for (let i = 0; i < safeTarget; i++) {
          const mv = explorationState.moves[i];
          if (!mv) break;
          let applied = null;
          if (mv.san) applied = game.move(mv.san);
          if (!applied && mv.from && mv.to) {
            const moveSpec = { from: mv.from, to: mv.to };
            if (mv.promotion) moveSpec.promotion = mv.promotion;
            applied = game.move(moveSpec);
          }
          if (!applied) break;
          lastAppliedMove = applied;
          explorationState.cursor = i + 1;
        }
        if (board) board.position(game.fen(), false);
        updateMaterialDisplay();
        if (lastAppliedMove) playMoveSound(lastAppliedMove);
      }

      function stepExploration(delta) {
        if (!isExploring()) return false;
        const target = explorationState.cursor + delta;
        if (target < 0 || target > explorationState.moves.length) return false;
        applyExplorationCursor(target);
        handleExplorationPositionChanged();
        return true;
      }

      function computeMaterialGains(chessInstance) {
        if (!chessInstance || typeof chessInstance.history !== 'function') {
          return { white: 0, black: 0, diff: 0 };
        }
        const gains = { white: 0, black: 0 };
        const history = chessInstance.history({ verbose: true }) || [];
        history.forEach(move => {
          if (!move || !move.captured) return;
          const value = PIECE_VALUES[move.captured];
          if (!Number.isFinite(value)) return;
          if (move.color === 'w') gains.white += value; else if (move.color === 'b') gains.black += value;
        });
        return { ...gains, diff: gains.white - gains.black };
      }

      function updateMaterialDisplay() {
        if (!materialTopLabel.length || !materialBottomLabel.length) return;
        const gains = computeMaterialGains(game);
        const orientation = board && typeof board.orientation === 'function' ? board.orientation() : 'white';
        const topColor = orientation === 'white' ? 'black' : 'white';
        const bottomColor = orientation === 'white' ? 'white' : 'black';
        const labels = { white: 'White', black: 'Black' };
        const headers = game && typeof game.header === 'function' ? game.header() : {};
        const buildPlayerName = (color) => {
          const name = color === 'white' ? headers.White : headers.Black;
          const elo = color === 'white' ? headers.WhiteElo : headers.BlackElo;
          const base = name || labels[color];
          return elo ? `${base} (${elo})` : base;
        };
        const formatLabel = (color) => {
          const player = buildPlayerName(color);
          const net = color === 'white' ? gains.diff : -gains.diff;
          const netLabel = Number.isFinite(net) && net > 0 ? `+${net}` : `${net || 0}`;
          return `${player}: ${netLabel}`;
        };
        materialTopLabel.text(formatLabel(topColor));
        materialBottomLabel.text(formatLabel(bottomColor));
      }

      function setPuzzleStatus(text) {
        if (!puzzleStatusText.length) return;
        if (text) {
          puzzleStatusText.text(text).removeClass('hidden');
        } else {
          puzzleStatusText.text('').addClass('hidden');
        }
      }

      function clearPuzzleContextHighlight() {
        if (puzzleContextSquares) {
          puzzleContextSquares.forEach(sq => {
            $('#board .square-' + sq).css('box-shadow', '');
          });
          puzzleContextSquares = null;
        }
      }

      function showPuzzleContextMove(moveRecord) {
        clearPuzzleContextHighlight();
        if (!moveRecord || !moveRecord.from || !moveRecord.to) return;
        puzzleContextSquares = highlightMoveSquares(
          moveRecord.from,
          moveRecord.to,
          'rgba(96, 165, 250, 0.7)',
          0.55
        );
      }

      function clearPuzzleState() {
        puzzleQueue = [];
        activePuzzleIndex = -1;
        puzzleActive = false;
        puzzleLoading = false;
        puzzleStartFen = '';
        puzzleTargetMove = '';
        puzzleTargetSan = '';
        puzzleReturnIndex = -1;
        puzzleOriginalMove = '';
        puzzleOriginalEval = null;
        puzzleAnalysisActive = false;
        puzzleAnalysisFenNormalized = '';
        puzzleTopCandidates = [];
        puzzleGraphIndex = -1;
        clearPuzzleContextHighlight();
        setPuzzleStatus('');
        updatePuzzleInfo();
        updatePuzzleControls();
      }

      function formatPuzzleLabel(puzzle, idx) {
        if (!puzzle) return '';
        const humanIndex = Number.isFinite(idx) ? (idx + 1) : null;
        const totalLabel = puzzleQueue.length ? `/ ${puzzleQueue.length}` : '';
        const classLabel = puzzle.classification || 'Mistake';
        const swing = Number(puzzle.delta);
        const swingLabel = Number.isFinite(swing) ? ` (${swing.toFixed(1)}%)` : '';
        const idxLabel = humanIndex ? `Puzzle ${humanIndex}${totalLabel}` : 'Puzzle';
        return `${idxLabel}: Fix the ${classLabel}${swingLabel}`;
      }

      function updatePuzzleInfo() {
        if (!puzzleInfo.length) return;
        let infoText = 'Generate a review to unlock puzzles from your worst moves.';
        if (!$('#review-section').is(':visible')) {
          puzzleInfo.text(infoText);
          if (startPuzzleBtn.length) startPuzzleBtn.attr('title', infoText);
          return;
        }
        if (!puzzleQueue.length) {
          infoText = 'No misclicks, blunders, or mistakes detected for puzzles.';
          puzzleInfo.text(infoText);
          if (startPuzzleBtn.length) startPuzzleBtn.attr('title', infoText);
          return;
        }
        const puzzle = activePuzzleIndex >= 0 ? puzzleQueue[activePuzzleIndex] : puzzleQueue[0];
        const label = formatPuzzleLabel(puzzle, activePuzzleIndex >= 0 ? activePuzzleIndex : 0);
        infoText = label || 'Puzzle ready.';
        puzzleInfo.text(infoText);
        if (startPuzzleBtn.length) startPuzzleBtn.attr('title', infoText);
      }

      function updatePuzzleControls() {
        if (!puzzlePanel.length) return;
        const reviewVisible = $('#review-section').is(':visible');
        const showPanel = reviewVisible && puzzleActive;
        puzzlePanel.toggleClass('hidden', !showPanel);
        const hasQueue = puzzleQueue.length > 0;
        if (startPuzzleBtn.length) {
          startPuzzleBtn.prop('disabled', !hasQueue || puzzleLoading);
          startPuzzleBtn.toggleClass('hidden', puzzleActive);
        }
        if (exitPuzzleBtn.length) {
          exitPuzzleBtn.toggleClass('hidden', !puzzleActive);
        }
        if (retryPuzzleBtn.length) {
          retryPuzzleBtn.prop('disabled', !puzzleActive || puzzleLoading);
        }
        if (nextPuzzleBtn.length) {
          const atEnd = activePuzzleIndex >= puzzleQueue.length - 1 || activePuzzleIndex === -1;
          nextPuzzleBtn.prop('disabled', !puzzleActive || atEnd || puzzleLoading);
        }
      }

      function rebuildPuzzleQueue() {
        puzzleQueue = [];
        activePuzzleIndex = -1;
        puzzleActive = false;
        puzzleStartFen = '';
        puzzleTargetMove = '';
        puzzleTargetSan = '';
        puzzleOriginalMove = '';
        puzzleOriginalEval = null;
        puzzleAnalysisActive = false;
        puzzleAnalysisFenNormalized = '';
        puzzleTopCandidates = [];
        puzzleGraphIndex = -1;
        clearPuzzleContextHighlight();
        const normalizedColor = normalizePlayerColorToken(reviewPlayerColor);
        if (!Array.isArray(movesWithAnalysis) || !movesWithAnalysis.length) {
          updatePuzzleInfo();
          updatePuzzleControls();
          return;
        }
        const temp = new Chess();
        const candidates = [];
        movesWithAnalysis.forEach((mv, idx) => {
          const key = normalizeClassificationKey(mv.analysis && mv.analysis.classification);
          if (!['misclick', 'blunder', 'mistake'].includes(key)) {
            temp.move(mv.san);
            return;
          }
          if (normalizedColor && mv.color !== normalizedColor) {
            temp.move(mv.san);
            return;
          }
          const fenBefore = temp.fen();
          const deltaCandidates = [mv.delta, mv.analysis && mv.analysis.delta, mv.automated && mv.automated.moverDelta];
          const deltaValue = deltaCandidates.find(val => Number.isFinite(Number(val)));
          const severity = CLASSIFICATION_SEVERITY[key] || 0;
          candidates.push({
            index: idx,
            classification: canonicalizeClassification(mv.analysis && mv.analysis.classification),
            delta: deltaValue != null ? Number(deltaValue) : null,
            severity,
            fen: fenBefore,
            move: mv
          });
          temp.move(mv.san);
        });
        candidates.sort((a, b) => {
          if (b.severity !== a.severity) return b.severity - a.severity;
          const aDelta = Number(a.delta);
          const bDelta = Number(b.delta);
          if (Number.isFinite(aDelta) && Number.isFinite(bDelta) && aDelta !== bDelta) {
            return aDelta - bDelta;
          }
          return a.index - b.index;
        });
        puzzleQueue = candidates;
        updatePuzzleInfo();
        updatePuzzleControls();
      }

      function normalizePuzzleScoreValue(entry) {
        if (!entry) return null;
        if (entry.scoreType === 'mate') {
          const distance = Math.min(Math.abs(entry.scoreValue || 0), 50);
          const magnitude = PUZZLE_MATE_SCORE - (distance * 50);
          return (entry.scoreValue || 0) > 0 ? magnitude : -magnitude;
        }
        if (entry.scoreType === 'cp' && Number.isFinite(entry.scoreValue)) {
          return Number(entry.scoreValue);
        }
        return null;
      }

      function isPuzzleScoreClose(candidate, best) {
        const candidateScore = normalizePuzzleScoreValue(candidate);
        const bestScore = normalizePuzzleScoreValue(best);
        if (candidateScore == null || bestScore == null) return false;
        return Math.abs(candidateScore - bestScore) <= PUZZLE_CLOSE_SCORE_THRESHOLD;
      }

      function updatePuzzleCandidateList(list, entry) {
        const cleaned = (list || []).filter(item => item && item.move !== entry.move && item.multipv !== entry.multipv);
        cleaned.push(entry);
        cleaned.sort((a, b) => (a.multipv || 0) - (b.multipv || 0));
        return cleaned.slice(0, PUZZLE_MAX_ALT_MOVES);
      }

      function processPuzzleInfo(msg) {
        if (!puzzleActive || !puzzleAnalysisActive) return;
        if (!puzzleAnalysisFenNormalized || !puzzleStartFen) return;
        const normalizedFen = normalizeFenForComparison(puzzleStartFen);
        if (puzzleAnalysisFenNormalized !== normalizedFen) return;
        if (!msg || typeof msg !== 'string') return;
        if (!msg.includes(' multipv ')) return;
        const multipvMatch = msg.match(/\bmultipv\s+(\d+)/i);
        const pvMatch = msg.match(/\spv\s+([a-h][1-8][a-h][1-8][nbrq]?)/i);
        if (!multipvMatch || !pvMatch) return;
        const move = normalizeUciMove(pvMatch[1]);
        if (!move) return;
        const depthMatch = msg.match(/\bdepth\s+(\d+)/i);
        const mateMatch = msg.match(/\bscore mate (-?\d+)/i);
        const cpMatch = msg.match(/\bscore cp (-?\d+)/i);
        const entry = {
          move,
          multipv: parseInt(multipvMatch[1], 10) || 1,
          depth: depthMatch ? parseInt(depthMatch[1], 10) : null,
          scoreType: mateMatch ? 'mate' : 'cp',
          scoreValue: mateMatch ? parseInt(mateMatch[1], 10) : (cpMatch ? parseInt(cpMatch[1], 10) : null)
        };
        puzzleTopCandidates = updatePuzzleCandidateList(puzzleTopCandidates, entry);
      }

      function stopPuzzleBackgroundAnalysis() {
        if (!engineWorker || !puzzleAnalysisActive) return;
        puzzleAnalysisActive = false;
        puzzleAnalysisFenNormalized = '';
        puzzleTopCandidates = [];
        engineWorker.postMessage('stop');
        setEngineMultiPv(1);
      }

      function startPuzzleBackgroundAnalysis(fen) {
        if (!engineWorker || !fen) return;
        puzzleAnalysisActive = true;
        puzzleAnalysisFenNormalized = normalizeFenForComparison(fen);
        puzzleTopCandidates = [];
        puzzleAnalysisToken += 1;
        const localToken = puzzleAnalysisToken;
        setEngineMultiPv(PUZZLE_MAX_ALT_MOVES);
        engineWorker.postMessage('stop');
        engineWorker.postMessage('position fen ' + fen);
        engineWorker.postMessage('go infinite');
        setTimeout(() => {
          if (puzzleAnalysisActive && puzzleAnalysisToken === localToken) {
            setEngineMultiPv(PUZZLE_MAX_ALT_MOVES);
          }
        }, 50);
      }

      async function evaluatePuzzleMoveScore(fen, moveUci) {
        if (!moveUci) return null;
        const requestToken = ++puzzleScoreRequestToken;
        const wasAnalyzing = puzzleAnalysisActive;
        if (wasAnalyzing) stopPuzzleBackgroundAnalysis();
        await waitForEngineReady();
        const score = await getScoreWithTimeout(
          fen,
          { ...ENGINE_GO_OPTIONS, searchmoves: [moveUci], multipv: 1, preserveMultiPv: false },
          'puzzle attempt score'
        );
        if (wasAnalyzing && puzzleActive) {
          startPuzzleBackgroundAnalysis(fen);
        }
        if (requestToken !== puzzleScoreRequestToken) return null;
        if (!score) return null;
        if (score.type === 'mate') {
          const distance = Math.min(Math.abs(score.value || 0), 50);
          const magnitude = PUZZLE_MATE_SCORE - (distance * 50);
          return (score.value || 0) > 0 ? magnitude : -magnitude;
        }
        return Number.isFinite(score.value) ? Number(score.value) : null;
      }

      function isScoreBetterThanOriginal(attemptScore) {
        if (puzzleOriginalEval == null || attemptScore == null) return null;
        return attemptScore > puzzleOriginalEval + 5;
      }

      async function evaluatePuzzleAttemptOutcome(attemptUci) {
        const normalizedAttempt = normalizeUciMove(attemptUci || '');
        const target = normalizeUciMove(puzzleTargetMove || '');
        const bestCandidate = puzzleTopCandidates.length ? puzzleTopCandidates[0] : null;
        const attemptCandidate = puzzleTopCandidates.find(c => c.move === normalizedAttempt);
        let attemptScore = attemptCandidate ? normalizePuzzleScoreValue(attemptCandidate) : null;
        let correct = target ? normalizedAttempt === target : true;
        let nearBest = false;
        if (!correct && attemptCandidate && bestCandidate) {
          nearBest = isPuzzleScoreClose(attemptCandidate, bestCandidate);
          if (nearBest) correct = true;
        }
        if (attemptScore == null && normalizedAttempt) {
          attemptScore = await evaluatePuzzleMoveScore(puzzleStartFen, normalizedAttempt);
        }
        const improvementFlag = isScoreBetterThanOriginal(attemptScore);
        return { correct, nearBest, improvement: improvementFlag };
      }

      function resetPuzzlePosition() {
        if (!puzzleActive || !puzzleStartFen) return;
        game.load(puzzleStartFen);
        if (board) board.position(puzzleStartFen, false);
        updateMaterialDisplay();
        clearSelected();
      }

      function hidePuzzleResult() {
        if (puzzleResultModal.length) puzzleResultModal.addClass('hidden');
      }

      function showPuzzleResult(success, message) {
        if (!puzzleResultModal.length) return;
        puzzleResultTitle.text(success ? 'Correct!' : 'Not quite');
        puzzleResultMessage.text(message || '');
        puzzleResultModal.removeClass('hidden');
      }

      async function ensurePuzzleTarget(puzzle) {
        if (!puzzle) return '';
        if (puzzle.bestMove) return puzzle.bestMove;
        await waitForEngineReady();
        const score = await getScoreWithTimeout(puzzle.fen, ENGINE_GO_OPTIONS, 'puzzle best move');
        const bestmove = score && score.bestmove ? normalizeUciMove(score.bestmove) : '';
        let resolved = bestmove || '';
        const fallback = buildUciFromMoveLike(puzzle.move);
        if (!resolved && fallback) resolved = normalizeUciMove(fallback);
        puzzle.bestMove = resolved;
        const san = resolved ? (uciToSan(resolved, puzzle.fen) || '') : '';
        puzzle.bestMoveSan = san || (puzzle.move && puzzle.move.san) || '';
        return puzzle.bestMove;
      }

      async function loadPuzzleAtIndex(targetIndex) {
        if (!puzzleQueue.length || puzzleLoading) return;
        puzzleLoading = true;
        setPuzzleStatus('Loading puzzle...');
        try {
          const idx = Math.max(0, Math.min(targetIndex, puzzleQueue.length - 1));
          activePuzzleIndex = idx;
          const puzzle = puzzleQueue[idx];
          puzzleActive = true;
          puzzleReturnIndex = currentMoveIndex;
          puzzleGraphIndex = Number.isFinite(puzzle.index) ? puzzle.index : -1;
          const previousMove = puzzle.index > 0 ? movesWithAnalysis[puzzle.index - 1] : null;
          stopPuzzleBackgroundAnalysis();
          clearSelected();
          clearExploration(true);
          if (!game.load(puzzle.fen)) {
            throw new Error('Could not load puzzle position.');
          }
          if (board) board.position(game.fen(), false);
          updateMaterialDisplay();
          showPuzzleContextMove(previousMove);
          puzzleStartFen = game.fen();
          puzzleTargetMove = '';
          puzzleTargetSan = '';
          puzzleOriginalMove = normalizeUciMove(buildUciFromMoveLike(puzzle.move) || '');
          puzzleOriginalEval = null;
          setPuzzleStatus('Analyzing the position...');
          await ensurePuzzleTarget(puzzle);
          puzzleTargetMove = normalizeUciMove(puzzle.bestMove || '');
          puzzleTargetSan = puzzle.bestMoveSan || '';
          if (puzzleOriginalMove) {
            puzzleOriginalEval = await evaluatePuzzleMoveScore(puzzleStartFen, puzzleOriginalMove);
          }
          startPuzzleBackgroundAnalysis(puzzleStartFen);
          renderEvalGraph(currentMoveIndex);
          setPuzzleStatus('Find the engine move that avoids this mistake.');
        } catch (err) {
          console.error('Puzzle load failed:', err);
          puzzleActive = false;
          puzzleGraphIndex = -1;
          clearPuzzleContextHighlight();
          setPuzzleStatus(err && err.message ? err.message : 'Could not load puzzle position.');
        } finally {
          puzzleLoading = false;
          updatePuzzleInfo();
          updatePuzzleControls();
        }
      }

      async function startPuzzleMode() {
        hidePuzzleResult();
        if (!puzzleQueue.length) {
          setPuzzleStatus('No mistakes to review as puzzles.');
          return;
        }
        puzzleLoading = false;
        showBestMove = false;
        clearBestMoveHighlight();
        await loadPuzzleAtIndex(0);
      }

      function exitPuzzleMode() {
        puzzleActive = false;
        puzzleLoading = false;
        activePuzzleIndex = -1;
        puzzleStartFen = '';
        puzzleTargetMove = '';
        puzzleTargetSan = '';
        puzzleOriginalMove = '';
        puzzleOriginalEval = null;
        stopPuzzleBackgroundAnalysis();
        hidePuzzleResult();
        setPuzzleStatus('');
        puzzleGraphIndex = -1;
        clearPuzzleContextHighlight();
        if (puzzleReturnIndex != null && puzzleReturnIndex >= -1) {
          goToMove(puzzleReturnIndex, { scrollMode: 'none' });
        }
        renderEvalGraph(currentMoveIndex);
        updatePuzzleInfo();
        updatePuzzleControls();
      }

      function finalizePuzzleAttempt(outcome) {
        if (!puzzleActive || activePuzzleIndex < 0 || activePuzzleIndex >= puzzleQueue.length) return;
        const puzzle = puzzleQueue[activePuzzleIndex];
        const correct = !!(outcome && outcome.correct);
        const nearBest = !!(outcome && outcome.nearBest);
        const improvement = outcome ? outcome.improvement : null;
        if (correct) puzzle.solved = true;
        const improvementText = improvement === true
          ? ' That improves on your game move.'
          : (improvement === false ? ' This repeats the original mistake.' : '');
        let message;
        if (correct) {
          const detail = puzzleTargetSan && !nearBest ? ` ${puzzleTargetSan} was the top engine line.` : '';
          const closeness = nearBest && puzzleTargetSan ? 'Close enough to the top choice.' : 'Great find.';
          message = `${closeness}${detail}${improvementText}`;
        } else {
          message = `Not quite. Try again or explore another line.${improvementText}`;
        }
        showPuzzleResult(!!correct, message);
        setPuzzleStatus(correct ? 'Nice! Use Next for the following puzzle.' : 'Incorrect. Retry to try again.');
        updatePuzzleControls();
      }

      async function advancePuzzle() {
        hidePuzzleResult();
        if (!puzzleActive || puzzleLoading) return;
        const nextIndex = activePuzzleIndex + 1;
        if (nextIndex >= puzzleQueue.length) {
          setPuzzleStatus('You have finished every puzzle.');
          updatePuzzleControls();
          return;
        }
        await loadPuzzleAtIndex(nextIndex);
      }

      async function retryPuzzle() {
        hidePuzzleResult();
        if (!puzzleActive || puzzleLoading) return;
        await loadPuzzleAtIndex(activePuzzleIndex >= 0 ? activePuzzleIndex : 0);
        setPuzzleStatus('Try again to find the engine move.');
        updatePuzzleControls();
      }

      async function handlePuzzleSquareClick(square) {
        if (!puzzleActive || puzzleLoading) return false;
        if (selectedSquare) {
          if (selectedSquare === square) {
            clearSelected();
            return true;
          }
          const move = game.move({ from: selectedSquare, to: square, promotion: 'q' });
          if (move) {
            if (board) board.position(game.fen());
            updateMaterialDisplay();
            playMoveSound(move);
            clearSelected();
            const attempt = buildUciFromMoveLike(move);
            const outcome = await evaluatePuzzleAttemptOutcome(attempt);
            finalizePuzzleAttempt(outcome);
            if (!outcome || !outcome.correct) {
              resetPuzzlePosition();
            }
          } else {
            clearSelected();
          }
          return true;
        }
        if (!game.get(square)) return true;
        selectedSquare = square;
        $('#board .square-' + square).addClass('selected');
        return true;
      }
      function handleSquareClick(square) {
        if (puzzleActive) {
          handlePuzzleSquareClick(square);
          return;
        }
        if (selectedSquare) {
          if (selectedSquare === square) {
            clearSelected();
            return;
          }
          const fenBeforeMove = game.fen();
            const move = game.move({ from: selectedSquare, to: square, promotion: 'q' });
          if (move) {
            if (!isExploring()) {
              startExploration(fenBeforeMove, currentMoveIndex);
            } else if (explorationState.cursor < explorationState.moves.length) {
              explorationState.moves = explorationState.moves.slice(0, explorationState.cursor);
            }
            explorationState.moves.push({ san: move.san, from: move.from, to: move.to, promotion: move.promotion });
            explorationState.cursor = explorationState.moves.length;
            if (board) board.position(game.fen());
            updateMaterialDisplay();
            playMoveSound(move);
            clearSelected();
            handleExplorationPositionChanged();
          } else {
            clearSelected();
            if (game.get(square)) {
              selectedSquare = square;
              $('#board .square-' + square).addClass('selected');
            }
          }
        } else {
          if (!game.get(square)) return;
          selectedSquare = square;
          $('#board .square-' + square).addClass('selected');
        }
      }
      function formatText(t) {
        return t ? String(t).replace(/\*\*(.*?)\*\*/g,'<strong>$1</strong>') : '';
      }
      function formatSummaryLine(s) {
        if (!s) return '';

        // Split into the portion to format and the portion to leave untouched.
        const pctIdx = s.lastIndexOf('%');
        let before = s;
        let after = '';
        if (pctIdx !== -1) {
          before = s.slice(0, pctIdx + 1);
          after = s.slice(pctIdx + 1);
        }

        let html = formatText(before);

        // Temporarily replace totals so 'Good'/'Bad' aren't recolored inside them.
        let totalGood = null;
        let totalBad = null;
        html = html.replace(/(\d+\s+Total\s+Good)/i, m => { totalGood = m; return '@@TOTAL_GOOD@@'; });
        html = html.replace(/(\d+\s+Total\s+Bad)/i, m => { totalBad = m; return '@@TOTAL_BAD@@'; });

        Object.keys(classificationStyles).forEach(k => {
          if (k === 'default') return;
          let pattern = k;
          if (k === 'inaccuracy') pattern = 'inaccurac(?:y|ies)';
          else if (k !== 'forced' && k !== 'good') pattern += 's?';
          const regex = new RegExp('(?:\\b(\\d+)\\s+)?\\b' + pattern + '\\b', 'gi');
          html = html.replace(regex, (match, num) => {
            if (num && parseInt(num, 10) === 0) return match;
            return '<span class="' + getStyleForClassification(k) + '">' + match + '</span>';
          });
        });

        // Highlight any percentages (e.g., "Accuracy: 65%" or "65% accuracy")
        html = html.replace(/(\d+(?:\.\d+)?)%/g,
          m => '<strong class="text-yellow-400">' + m + '</strong>');

        if (totalGood) {
          html = html.replace('@@TOTAL_GOOD@@', '<strong class="text-yellow-400">' + totalGood + '</strong>');
        }
        if (totalBad) {
          html = html.replace('@@TOTAL_BAD@@', '<strong class="text-yellow-400">' + totalBad + '</strong>');
        }

        // Append untouched portion after the percentage sign.
        return html + after;
      }
      function showError(m) { $('#error-message').text(m); $('#error-modal').removeClass('hidden'); }
      $('#close-modal-btn').on('click', function(){ $('#error-modal').addClass('hidden'); });

      // ---------- Score helpers ----------
      function cpToProb(cp){ return 1 / (1 + Math.exp(-cp / 173)); }

      function clampProb(p) {
        if (p == null || Number.isNaN(p)) return null;
        if (p < 0) return 0;
        if (p > 1) return 1;
        return p;
      }

      function formatDeltaNumber(delta) {
        if (delta == null || !isFinite(delta)) return null;
        let rounded = Math.round(delta);
        if (Object.is(rounded, -0)) rounded = 0;
        return String(rounded);
      }

      function formatDeltaBraced(delta) {
        const formatted = formatDeltaNumber(delta);
        if (!formatted) return '';
        return `{${formatted}}`;
      }

      function formatProbBraced(prob) {
        const clamped = clampProb(prob);
        if (clamped == null) return '';
        const percent = Math.round(clamped * 100);
        return `{${percent}%}`;
      }

      function formatWhiteWinProbDisplay(prob) {
        const clamped = clampProb(prob);
        if (clamped == null) return '';
        const percent = Math.round(clamped * 100);
        return '<span class="font-mono text-xs text-yellow-400">{' + percent + '%}</span>';
      }

      function formatMoverDeltaIndicator(delta) {
        if (delta == null) return '';
        const numeric = Number(delta);
        if (!Number.isFinite(numeric)) return '';
        let rounded = Math.round(numeric);
        if (Object.is(rounded, -0)) rounded = 0;
        if (rounded >= 0) {
          return '<span class="font-mono text-sm font-bold text-green-400">&uarr;' + rounded + '</span>';
        }
        return '<span class="font-mono text-sm font-bold text-red-400">&darr;' + Math.abs(rounded) + '</span>';
      }

      // ---------- PGN normalization ----------
      function normalizePgn(raw, opts) {
        opts = opts || {}; const keepComments = !!opts.keepComments;
        let s = String(raw || '').replace(/\r\n?/g, '\n').replace(/^\uFEFF/, '').trim(); if (!s) return '';
        const lines = s.split('\n'); const headerLines = []; let i = 0;
        while (i < lines.length && /^\s*\[.*\]\s*$/.test(lines[i])) { headerLines.push(lines[i].trim()); i++; }
        let movePart = lines.slice(i).join('\n');
        if (headerLines.length === 0) {
          const all = s.split('\n'); let lastHeaderIdx = -1;
          for (let j=0;j<all.length;j++) if (/^\s*\[.*\]\s*$/.test(all[j])) lastHeaderIdx = j;
          if (lastHeaderIdx >= 0) { headerLines.push(...all.slice(0,lastHeaderIdx+1).map(x=>x.trim())); movePart = all.slice(lastHeaderIdx+1).join('\n'); }
        }
        if (!keepComments) {
          movePart = movePart.replace(/\{[^}]*\}/g,' ');
          movePart = movePart.replace(/\([^()]*\)/g,' ');
          movePart = movePart.replace(/\$\d+/g,' ');
          movePart = movePart.replace(/([a-hRNBQKO0-9=:+#-])([!?]{1,2})/g,'$1');
          movePart = movePart.replace(/\u2026/g,'...');
        }
        movePart = movePart.replace(/\s+/g,' ').replace(/\s*\.(\.\.)?\s*/g, m=>m.trim()+' ').trim();
        const headerBlock = headerLines.length ? headerLines.join('\n') : '';
        return headerBlock ? (headerBlock+'\n\n'+movePart) : movePart;
      }

      function buildHeaderTagBlock(chess) {
        const hdr = chess.header();
        const order = ['Event','Site','Date','Round','White','Black','Result','TimeControl','WhiteElo','BlackElo','Termination','ECO','EndTime','Link','UTCDate','UTCTime','GameId','Variant','Opening','Annotator'];
        const seen = new Set(); const lines = [];
        order.forEach(k => { if (hdr[k]) { lines.push(`[${k} "${hdr[k]}"]`); seen.add(k); } });
        Object.keys(hdr).sort().forEach(k => { if (!seen.has(k)) lines.push(`[${k} "${hdr[k]}"]`); });
        return lines.join('\n');
      }

      function normalizeStep(step) {
        const n = parseInt(step, 10);
        if (!Number.isFinite(n) || Number.isNaN(n)) return 1;
        if (n < 1) return 1;
        if (n > 4) return 4;
        return n;
      }

      function getStepFromHash(hash) {
        if (!hash) return 1;
        if (hash === '#step-1') return 1;
        const match = Object.entries(STEP_HASHES).find(([, value]) => value === hash);
        if (!match) return 1;
        return normalizeStep(parseInt(match[0], 10));
      }

      function loadFormState() {
        return {};
      }

      function persistFormState() {
        // Disabled: Avoid persisting PGN or analysis data to storage.
      }

      function isLocalStorageAvailable() {
        try {
          if (typeof window === 'undefined' || !window.localStorage) return false;
          const testKey = '__cmr_storage_test__';
          window.localStorage.setItem(testKey, '1');
          window.localStorage.removeItem(testKey);
          return true;
        } catch (err) {
          return false;
        }
      }

      function loadArchiveEntriesFromStorage() {
        if (typeof window === 'undefined' || !window.localStorage) return [];
        try {
          const raw = window.localStorage.getItem(ARCHIVE_STORAGE_KEY);
          if (!raw) return [];
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return [];
          const normalized = parsed.map(normalizeArchiveEntry).filter(Boolean);
          normalized.sort((a, b) => (b.updatedAt || b.createdAt || 0) - (a.updatedAt || a.createdAt || 0));
          return normalized;
        } catch (err) {
          console.warn('Failed to load saved reviews:', err);
          return [];
        }
      }

      function normalizeArchiveEntry(entry) {
        if (!entry || typeof entry !== 'object') return null;
        if (!entry.finalAnalysis) return null;
        const createdAt = Number(entry.createdAt) || Date.now();
        const updatedAt = Number(entry.updatedAt) || createdAt;
        return {
          id: entry.id || `archive-${createdAt}-${Math.random().toString(36).slice(2, 8)}`,
          version: entry.version || 1,
          title: entry.title || '',
          finalAnalysis: String(entry.finalAnalysis),
          pgn: entry.pgn || '',
          annotatedPgn: entry.annotatedPgn || '',
          stockfishOutput: entry.stockfishOutput || '',
          summary: entry.summary || '',
          playerColor: entry.playerColor || null,
          playerName: entry.playerName || '',
          opponent: entry.opponent || '',
          resultCode: entry.resultCode || '',
          resultLabel: entry.resultLabel || '',
          headers: entry.headers && typeof entry.headers === 'object' ? entry.headers : {},
          movesCount: Number.isFinite(Number(entry.movesCount)) ? Number(entry.movesCount) : null,
          featuredMove: entry.featuredMove && typeof entry.featuredMove === 'object' ? entry.featuredMove : null,
          createdAt,
          updatedAt
        };
      }

      function persistArchiveEntries(entries) {
        if (!storageAvailable || typeof window === 'undefined' || !window.localStorage) return false;
        try {
          const payload = Array.isArray(entries) ? entries.map(entry => ({
            id: entry.id,
            version: entry.version || 1,
            title: entry.title || '',
            finalAnalysis: entry.finalAnalysis || '',
            pgn: entry.pgn || '',
            annotatedPgn: entry.annotatedPgn || '',
            stockfishOutput: entry.stockfishOutput || '',
            summary: entry.summary || '',
            playerColor: entry.playerColor || null,
            playerName: entry.playerName || '',
            opponent: entry.opponent || '',
            resultCode: entry.resultCode || '',
            resultLabel: entry.resultLabel || '',
            headers: entry.headers || {},
            movesCount: entry.movesCount != null ? entry.movesCount : null,
            featuredMove: entry.featuredMove || null,
            createdAt: entry.createdAt || Date.now(),
            updatedAt: entry.updatedAt || entry.createdAt || Date.now()
          })) : [];
          window.localStorage.setItem(ARCHIVE_STORAGE_KEY, JSON.stringify(payload));
          return true;
        } catch (err) {
          console.warn('Failed to persist saved reviews:', err);
          return false;
        }
      }

      function openArchiveModal() {
        if (!archiveModal.length) return;
        archiveReturnFocus = document.activeElement;
        renderArchiveList();
        showArchiveStatus('', 'info');
        archiveModal.removeClass('hidden').attr('aria-hidden', 'false');
        if (closeArchiveBtn.length) {
          setTimeout(() => { closeArchiveBtn.trigger('focus'); }, 0);
        }
      }

      function closeArchiveModal() {
        if (!archiveModal.length) return;
        archiveModal.addClass('hidden').attr('aria-hidden', 'true');
        showArchiveStatus('', 'info');
        if (archiveReturnFocus && typeof archiveReturnFocus.focus === 'function') {
          try { archiveReturnFocus.focus(); } catch (err) { /* ignore */ }
        }
        archiveReturnFocus = null;
      }

      function showArchiveStatus(message, tone) {
        if (!archiveStatus.length) return;
        archiveStatus
          .removeClass('hidden text-red-300 text-emerald-300 text-sky-300 text-gray-300')
          .addClass(message ? '' : 'hidden')
          .text(message || '');
        if (!message) return;
        const toneClass = tone === 'error' ? 'text-red-300'
          : tone === 'success' ? 'text-emerald-300'
            : tone === 'info' ? 'text-sky-300'
              : 'text-gray-300';
        archiveStatus.addClass(toneClass);
      }

      function showArchiveFeedback(message, tone) {
        if (!archiveFeedback.length) return;
        if (archiveFeedbackTimeout) {
          clearTimeout(archiveFeedbackTimeout);
          archiveFeedbackTimeout = null;
        }
        if (!message) {
          archiveFeedback.addClass('hidden').text('');
          return;
        }
        const toneClass = tone === 'error' ? 'text-red-300'
          : tone === 'success' ? 'text-emerald-300'
            : 'text-sky-300';
        archiveFeedback
          .removeClass('hidden text-red-300 text-emerald-300 text-sky-300')
          .addClass(toneClass)
          .text(message);
        archiveFeedbackTimeout = setTimeout(() => {
          archiveFeedback.addClass('hidden');
        }, 4500);
      }

      function syncArchiveModalControls() {
        if (clearArchiveBtn.length) {
          clearArchiveBtn.prop('disabled', !storageAvailable || archiveEntries.length === 0);
        }
      }

      function renderArchiveList() {
        if (!archiveList.length) return;
        archiveList.empty();
        if (!storageAvailable) {
          showArchiveStatus('Saving is unavailable in this browser session.', 'error');
          syncArchiveModalControls();
          return;
        }
        if (!archiveEntries.length) {
          showArchiveStatus('No saved reviews yet. Analyze a game and save it to build your archive.', 'info');
          syncArchiveModalControls();
          return;
        }
        showArchiveStatus('', 'info');
        const ordered = archiveEntries.slice().sort((a, b) => (b.updatedAt || b.createdAt || 0) - (a.updatedAt || a.createdAt || 0));
        ordered.forEach(entry => {
          const item = $('<div class="bg-[#0b0e15] border border-[#1f2937] rounded-lg p-4"></div>');
          const header = $('<div class="flex items-center justify-between gap-3"></div>').appendTo(item);
          const textWrap = $('<div class="min-w-0 flex-1"></div>').appendTo(header);
          const title = entry.title || buildArchiveTitle(entry);
          $('<h4 class="text-lg font-semibold text-white truncate"></h4>').text(title).appendTo(textWrap);
          const timestamp = entry.updatedAt || entry.createdAt || Date.now();
          $('<p class="text-xs text-gray-400"></p>').text(formatDateTime(timestamp)).appendTo(textWrap);
          const infoParts = [];
          if (entry.opponent) infoParts.push('vs ' + entry.opponent);
          if (entry.resultLabel) infoParts.push(entry.resultLabel);
          else if (entry.resultCode) infoParts.push(entry.resultCode);
          if (entry.playerColor === 'white') infoParts.push('You were White');
          else if (entry.playerColor === 'black') infoParts.push('You were Black');
          if (infoParts.length) {
            $('<p class="text-xs text-gray-400"></p>').text(infoParts.join(' • ')).appendTo(textWrap);
          }
          const actions = $('<div class="flex items-center gap-2 shrink-0"></div>').appendTo(header);
          $('<button type="button" class="py-1 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap" data-archive-action="load"></button>')
            .attr('data-archive-id', entry.id)
            .text('Load')
            .appendTo(actions);
          $('<button type="button" class="py-1 px-3 text-sm font-semibold text-white rounded-md btn-secondary whitespace-nowrap" data-archive-action="delete"></button>')
            .attr('data-archive-id', entry.id)
            .text('Delete')
            .appendTo(actions);
          if (entry.summary) {
            $('<p class="text-sm text-gray-300 mt-2 whitespace-pre-wrap break-words"></p>').text(entry.summary).appendTo(item);
          }
          if (entry.featuredMove && entry.featuredMove.displaySan) {
            $('<p class="text-xs text-yellow-300 mt-1"></p>').text('Move of the Game: ' + entry.featuredMove.displaySan).appendTo(item);
          }
          if (entry.movesCount) {
            $('<p class="text-xs text-gray-500 mt-1"></p>').text(entry.movesCount + ' moves').appendTo(item);
          }
          archiveList.append(item);
        });
        syncArchiveModalControls();
      }

      function deriveOpponentFromHeaders(headers, color, playerNameInput) {
        if (!headers || typeof headers !== 'object') return '';
        const white = headers.White || '';
        const black = headers.Black || '';
        if (color === 'white') return black;
        if (color === 'black') return white;
        const normalized = playerNameInput ? String(playerNameInput).trim().toLowerCase() : '';
        if (normalized && white && white.toLowerCase() === normalized) return black;
        if (normalized && black && black.toLowerCase() === normalized) return white;
        return white && black ? `${white} vs ${black}` : (white || black || '');
      }

      function normalizeArchiveDateToken(value) {
        if (!value) return null;
        let str = String(value).trim();
        if (!str) return null;
        if (/[?]/.test(str)) return null;
        str = str.replace(/\s+/g, '');
        const dotMatch = str.match(/^(\d{4})[.\/-](\d{1,2})[.\/-](\d{1,2})$/);
        if (dotMatch) {
          const [, y, m, d] = dotMatch;
          const month = m.padStart(2, '0');
          const day = d.padStart(2, '0');
          return `${y}-${month}-${day}`;
        }
        const compactMatch = str.match(/^(\d{4})(\d{2})(\d{2})$/);
        if (compactMatch) {
          const [, y, m, d] = compactMatch;
          return `${y}-${m}-${d}`;
        }
        const isoMatch = str.match(/^(\d{4})-(\d{2})-(\d{2})$/);
        if (isoMatch) {
          return `${isoMatch[1]}-${isoMatch[2]}-${isoMatch[3]}`;
        }
        return null;
      }

      function formatDateForArchive(date) {
        if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '';
        const year = date.getUTCFullYear();
        const month = String(date.getUTCMonth() + 1).padStart(2, '0');
        const day = String(date.getUTCDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      }

      function deriveArchiveDateLabel(meta, headers) {
        const headerSource = headers && typeof headers === 'object' ? headers : {};
        const dateCandidates = [];
        ['Date', 'UTCDate', 'EndDate'].forEach(key => {
          if (headerSource[key]) dateCandidates.push(headerSource[key]);
        });
        for (const candidate of dateCandidates) {
          const normalized = normalizeArchiveDateToken(candidate);
          if (normalized) return normalized;
        }
        if (meta && Number.isFinite(meta.createdAt)) {
          const created = new Date(meta.createdAt);
          const createdLabel = formatDateForArchive(created);
          if (createdLabel) return createdLabel;
        }
        const todayLabel = formatDateForArchive(new Date());
        return todayLabel || 'Unknown Date';
      }

      function extractFeaturedMoveMeta(meta) {
        if (meta && meta.featuredMove && typeof meta.featuredMove === 'object') {
          return meta.featuredMove;
        }
        if (meta && meta.featuredMoveData && typeof meta.featuredMoveData === 'object') {
          return meta.featuredMoveData;
        }
        if (featuredMoveData && typeof featuredMoveData === 'object') {
          return featuredMoveData;
        }
        return null;
      }

      function extractFeaturedDelta(featured) {
        if (!featured || typeof featured !== 'object') return null;
        const candidates = [featured.delta, featured.moverDelta];
        for (const candidate of candidates) {
          const numeric = Number(candidate);
          if (Number.isFinite(numeric)) return numeric;
        }
        if (featured.evaluation) {
          const evalInfo = parseEvaluationToken(featured.evaluation);
          if (evalInfo && Number.isFinite(evalInfo.delta)) return Number(evalInfo.delta);
        }
        return null;
      }

      function formatDeltaForArchiveTitle(delta) {
        if (!Number.isFinite(delta)) return '';
        const sign = delta > 0 ? '+' : delta < 0 ? '-' : '';
        const magnitude = Math.abs(delta);
        let formatted;
        if (magnitude >= 100) {
          formatted = Math.round(magnitude).toString();
        } else if (magnitude >= 10) {
          formatted = Math.round(magnitude).toString();
        } else if (magnitude >= 1) {
          formatted = (Math.round(magnitude * 10) / 10).toFixed(1);
        } else {
          formatted = (Math.round(magnitude * 100) / 100).toFixed(2);
        }
        formatted = formatted.replace(/\.0+$/, '').replace(/(\.\d*?)0+$/, '$1');
        return `${sign}${formatted}`;
      }

      function buildArchiveTitle(meta) {
        const headers = meta && meta.headers ? meta.headers : (game && typeof game.header === 'function' ? game.header() : {});
        const dateLabel = deriveArchiveDateLabel(meta, headers);
        const featured = extractFeaturedMoveMeta(meta);
        const classification = featured && featured.classification
          ? String(featured.classification).trim()
          : '';
        const deltaValue = extractFeaturedDelta(featured);
        let deltaLabel = formatDeltaForArchiveTitle(deltaValue);
        if (!deltaLabel) {
          deltaLabel = '0';
        }
        const classLabel = classification || 'Unclassified';
        const baseLabel = [dateLabel || 'Unknown Date', classLabel].join(' - ');
        return `${baseLabel}: ${deltaLabel}`;
      }

      function buildArchiveEntry(customTitle) {
        if (!lastFinalAnalysisText) return null;
        const now = Date.now();
        const meta = currentReviewMetadata || {};
        const headers = meta.headers && typeof meta.headers === 'object'
          ? { ...meta.headers }
          : (game && typeof game.header === 'function' ? { ...game.header() } : {});
        const title = customTitle && customTitle.trim() ? customTitle.trim() : buildArchiveTitle({ ...meta, headers });
        const pgnSnapshot = meta.pgn || (game && typeof game.pgn === 'function' ? game.pgn({ max_width: 0, newline_char: '\n' }) : '');
        const opponent = meta.opponent || deriveOpponentFromHeaders(headers, meta.playerColor || reviewPlayerColor, meta.playerName || getPlayerName());
        const resultCode = meta.resultCode || headers.Result || '';
        const resultLabel = meta.resultLabel || describeResult(resultCode);
        return {
          id: '',
          version: 1,
          title,
          finalAnalysis: lastFinalAnalysisText,
          pgn: pgnSnapshot || '',
          annotatedPgn: meta.annotatedPgn || lastAnnotatedPgn || '',
          stockfishOutput: meta.stockfishOutput || ($('#stockfish-output').val() || ''),
          summary: meta.summary || '',
          playerColor: meta.playerColor || reviewPlayerColor,
          playerName: meta.playerName || getPlayerName(),
          opponent,
          resultCode,
          resultLabel,
          headers,
          movesCount: meta.movesCount != null ? meta.movesCount : (Array.isArray(movesWithAnalysis) ? movesWithAnalysis.length : null),
          featuredMove: meta.featuredMove || null,
          createdAt: now,
          updatedAt: now
        };
      }

      function updateArchiveControls() {
        const reviewVisible = $('#review-section').is(':visible');
        if (saveArchiveBtn.length) {
          if (!storageAvailable) {
            saveArchiveBtn.prop('disabled', true);
            saveArchiveBtn.attr('title', 'Browser storage is unavailable in this session.');
          } else if (!reviewVisible || !lastFinalAnalysisText) {
            saveArchiveBtn.prop('disabled', true);
            saveArchiveBtn.attr('title', 'Generate a review before saving it to your archive.');
          } else {
            saveArchiveBtn.prop('disabled', false);
            saveArchiveBtn.attr('title', 'Save this review to your archive.');
          }
        }
        if (openArchiveButtons.length) {
          openArchiveButtons.each(function () {
            if (!storageAvailable) {
              $(this).prop('disabled', true);
              $(this).attr('title', 'Browser storage is unavailable in this session.');
            } else {
              $(this).prop('disabled', false);
              $(this).attr('title', 'Open your saved reviews.');
            }
          });
        }
        if (!reviewVisible) {
          showArchiveFeedback('', 'info');
        }
        syncArchiveModalControls();
      }

      function handleSaveArchiveEntry() {
        if (!storageAvailable) {
          showArchiveFeedback('Saving is unavailable in this browser session.', 'error');
          return;
        }
        if (!$('#review-section').is(':visible') || !lastFinalAnalysisText) {
          showArchiveFeedback('Generate a review before saving.', 'error');
          return;
        }
        const defaultTitle = buildArchiveTitle(currentReviewMetadata || {});
        const response = window.prompt('Name this saved review:', defaultTitle);
        if (response == null) return;
        const entry = buildArchiveEntry(response);
        if (!entry) {
          showArchiveFeedback('Nothing to save yet.', 'error');
          return;
        }
        const timestamp = Date.now();
        entry.updatedAt = timestamp;
        const existing = archiveEntries.find(e => e.finalAnalysis === entry.finalAnalysis);
        if (existing) {
          entry.id = existing.id;
          entry.createdAt = existing.createdAt || timestamp;
        } else {
          entry.id = `archive-${timestamp}-${Math.random().toString(36).slice(2, 10)}`;
          entry.createdAt = timestamp;
        }
        const previous = archiveEntries.slice();
        archiveEntries = [entry, ...archiveEntries.filter(e => e.id !== entry.id)];
        if (archiveEntries.length > ARCHIVE_MAX_ENTRIES) {
          archiveEntries = archiveEntries.slice(0, ARCHIVE_MAX_ENTRIES);
        }
        if (!persistArchiveEntries(archiveEntries)) {
          archiveEntries = previous;
          showArchiveFeedback('Unable to save review. Storage may be full.', 'error');
          return;
        }
        showArchiveFeedback(`Saved "${entry.title}".`, 'success');
        if (archiveModal.length && !archiveModal.hasClass('hidden')) {
          renderArchiveList();
        }
        updateArchiveControls();
      }

      function handleDeleteArchiveEntry(id) {
        if (!storageAvailable || !id) return;
        if (!window.confirm('Delete this saved review?')) return;
        const previous = archiveEntries.slice();
        archiveEntries = archiveEntries.filter(entry => entry.id !== id);
        if (!persistArchiveEntries(archiveEntries)) {
          archiveEntries = previous;
          showArchiveStatus('Unable to delete the saved review.', 'error');
          return;
        }
        showArchiveStatus('Saved review deleted.', 'success');
        renderArchiveList();
        updateArchiveControls();
      }

      function handleClearArchive() {
        if (!storageAvailable || !archiveEntries.length) {
          showArchiveStatus(archiveEntries.length ? 'Saving is unavailable in this session.' : 'No saved reviews to clear.', archiveEntries.length ? 'error' : 'info');
          return;
        }
        if (!window.confirm('Remove all saved reviews? This cannot be undone.')) return;
        archiveEntries = [];
        if (!persistArchiveEntries(archiveEntries)) {
          showArchiveStatus('Unable to clear saved reviews.', 'error');
          archiveEntries = loadArchiveEntriesFromStorage();
          renderArchiveList();
          updateArchiveControls();
          return;
        }
        showArchiveStatus('Archive cleared.', 'success');
        renderArchiveList();
        updateArchiveControls();
      }

      function loadArchiveEntryById(id) {
        if (!id) return false;
        const entry = archiveEntries.find(e => e.id === id);
        if (!entry) {
          showArchiveStatus('Could not find the selected review.', 'error');
          return false;
        }
        const analysisText = entry.finalAnalysis || '';
        if (!analysisText.trim()) {
          showArchiveStatus('This saved review is missing its analysis text.', 'error');
          return false;
        }
        if ($('#player-name-input').length) {
          $('#player-name-input').val(entry.playerName || '');
          updateFormState('playerName', entry.playerName || '');
          $('#player-name-input').trigger('input');
        }
        if ($('#pgn-input').length) {
          $('#pgn-input').val(entry.pgn || '');
          updateFormState('pgnInput', entry.pgn || '');
        }
        if ($('#final-analysis-input').length) {
          $('#final-analysis-input').val(analysisText);
          updateFormState('finalAnalysisInput', analysisText);
        }
        if (entry.annotatedPgn) {
          lastAnnotatedPgn = entry.annotatedPgn;
          updateFormState('annotatedPgn', lastAnnotatedPgn);
        }
        if (entry.stockfishOutput) {
          $('#stockfish-output').val(entry.stockfishOutput);
          updateFormState('stockfishOutput', entry.stockfishOutput);
        }
        if (entry.playerColor) {
          const assignedColor = setReviewPlayerColor(entry.playerColor);
          playerGameOutcome = derivePlayerOutcome(entry.resultCode || '', assignedColor);
        } else {
          setReviewPlayerColor(null);
          playerGameOutcome = null;
        }
        lastFinalAnalysisText = analysisText;
        currentReviewMetadata = {
          headers: entry.headers || {},
          summary: entry.summary || '',
          playerColor: entry.playerColor || null,
          playerName: entry.playerName || '',
          opponent: entry.opponent || '',
          annotatedPgn: entry.annotatedPgn || '',
          stockfishOutput: entry.stockfishOutput || '',
          pgn: entry.pgn || '',
          resultCode: entry.resultCode || '',
          resultLabel: entry.resultLabel || '',
          movesCount: entry.movesCount || null,
          featuredMove: entry.featuredMove || null
        };
        closeArchiveModal();
        pendingArchiveLoadNotice = entry.title || 'Review';
        switchStep(3);
        setTimeout(() => {
          $('#generate-review-btn').trigger('click');
        }, 0);
        return true;
      }

      const TRANSIENT_FORM_KEYS = new Set(['pgnInput', 'finalAnalysisInput', 'stockfishOutput']);

      function updateFormState(key, value) {
        if (!key || TRANSIENT_FORM_KEYS.has(String(key))) return;
        if (!formState || typeof formState !== 'object') formState = {};
        formState[key] = value;
        persistFormState();
      }

      function buildCombinedStockfishOutput(playerName, annotatedPgn, automatedText) {
        const prompt = buildAnalysisPrompt(playerName);
        let combined = prompt;
        if (annotatedPgn) {
          combined += '\n\n' + annotatedPgn;
        }
        if (automatedText) {
          combined += '\n\n=== Automated Stockfish Insights ===\n' + automatedText;
        }
        return combined;
      }

      function refreshStockfishOutput() {
        if (!lastAnnotatedPgn) return;
        const combined = buildCombinedStockfishOutput(getPlayerName(), lastAnnotatedPgn, automatedReviewText);
        $('#stockfish-output').val(combined);
        updateFormState('stockfishOutput', combined);
      }

      function syncStep2View(opts) {
        opts = opts || {};
        const previousStep = opts.previousStep;
        const outputEl = $('#stockfish-output');
        if (!outputEl.length) return;
        const hasExistingText = !!outputEl.val();
        if (previousStep === 3) {
          if (copyStockfishBtn.length) {
            copyStockfishBtn.text(defaultCopyLabel).prop('disabled', !hasExistingText);
          }
          return;
        }
        const hasAnalysis = !!(lastAnnotatedPgn || automatedReviewText);
        const combined = hasAnalysis
          ? buildCombinedStockfishOutput(getPlayerName(), lastAnnotatedPgn, automatedReviewText)
          : buildAnalysisPrompt(getPlayerName());
        outputEl.val(combined);
        if (copyStockfishBtn.length) {
          copyStockfishBtn.text(defaultCopyLabel).prop('disabled', !combined);
        }
        if (hasAnalysis) {
          $('#progress-bar').css('width', '100%');
          $('#progress-text').text('Analysis ready.');
        } else {
          $('#progress-bar').css('width', '0%');
          $('#progress-text').text('');
        }
      }

      function bindPersistentInput(selector, key, opts) {
        const el = $(selector);
        if (!el.length) return;
        const sanitizer = opts && typeof opts.sanitize === 'function' ? opts.sanitize : (value => value);
        el.on('input change', function () {
          const raw = $(this).val();
          const sanitized = sanitizer(raw);
          const sanitizedStr = sanitized == null ? '' : String(sanitized);
          if (raw !== sanitizedStr) {
            $(this).val(sanitizedStr);
          }
          updateFormState(key, sanitized);
        });
      }

      function applySavedFormState() {
        if (!formState) return;
        if (formState.playerName != null) $('#player-name-input').val(formState.playerName);
        if (formState.pgnInput != null) $('#pgn-input').val(formState.pgnInput);
        if (formState.finalAnalysisInput != null) $('#final-analysis-input').val(formState.finalAnalysisInput);
        if (formState.depthInput != null) {
          $('#depth-input').val(formState.depthInput);
        }
        if (formState.threadsInput != null) {
          const sanitizedThreads = sanitizeEngineSetting('threads', formState.threadsInput);
          $('#threads-input').val(sanitizedThreads);
          if (sanitizedThreads !== formState.threadsInput) updateFormState('threadsInput', sanitizedThreads);
        }
        if (formState.hashInput != null) {
          const sanitizedHash = sanitizeEngineSetting('hash', formState.hashInput);
          $('#hash-input').val(sanitizedHash);
          if (sanitizedHash !== formState.hashInput) updateFormState('hashInput', sanitizedHash);
        }
        if (formState.stockfishOutput != null) $('#stockfish-output').val(formState.stockfishOutput);
        if (formState.annotatedPgn != null) lastAnnotatedPgn = formState.annotatedPgn;
        if (lastAnnotatedPgn) refreshStockfishOutput();
      }

      function switchStep(step, opts) {
        opts = opts || {};
        const normalized = normalizeStep(step);
        const previous = currentStep;
        currentStep = normalized;

        const sections = ['#step1-section', '#step2-section', '#step3-section', '#review-section'];
        sections.forEach((selector, index) => {
          if (index === normalized - 1) {
            $(selector).removeClass('hidden');
          } else {
            $(selector).addClass('hidden');
          }
        });

        if (normalized === 2) {
          syncStep2View({ previousStep: previous });
        }

        if (normalized === 3) {
          const finalInput = $('#final-analysis-input');
          if (finalInput.length) {
            const currentVal = finalInput.val();
            if ((!currentVal || !String(currentVal).trim()) && automatedReviewText) {
              finalInput.val(automatedReviewText);
            }
          }
        }

        $('.step-indicator').removeClass('active').removeAttr('aria-current');
        const indicatorIndex = Math.min(normalized, 3);
        const indicatorEl = $('#indicator-' + indicatorIndex);
        if (indicatorEl.length) {
          indicatorEl.addClass('active').attr('aria-current', 'step');
        }

        if (normalized === 4) {
          $('#app-header, #step-indicators').addClass('hidden');
        } else {
          $('#app-header, #step-indicators').removeClass('hidden');
        }

        if (normalized !== 4) {
          currentReviewMetadata = null;
        }

        updateArchiveControls();

        if (!opts.skipHistory && window.history && window.history.pushState) {
          try {
            const targetHash = STEP_HASHES[normalized] != null ? STEP_HASHES[normalized] : STEP_HASHES[1];
            const basePath = window.location.pathname + window.location.search;
            const targetUrl = targetHash ? (basePath + targetHash) : basePath;
            const state = { step: normalized };
            if (opts.replace) {
              window.history.replaceState(state, '', targetUrl);
            } else if (previous === normalized) {
              window.history.replaceState(state, '', targetUrl);
            } else {
              window.history.pushState(state, '', targetUrl);
            }
          } catch (err) {
            console.warn('Unable to update history state:', err);
          }
        }
      }

      $('.step-indicator').each(function () {
        const step = parseInt($(this).data('step'), 10);
        if (!step) return;
        $(this).on('click', function () { switchStep(step); });
        $(this).on('keydown', function (evt) {
          if (evt.key === 'Enter' || evt.key === ' ' || evt.key === 'Spacebar' || evt.key === 'Space') {
            evt.preventDefault();
            switchStep(step);
          }
        });
      });

      const initialStep = (window.history && window.history.state && typeof window.history.state.step === 'number')
        ? normalizeStep(window.history.state.step)
        : getStepFromHash(window.location.hash);
      switchStep(initialStep, { skipHistory: true });
      if (window.history && window.history.replaceState) {
        const initialHash = STEP_HASHES[initialStep] != null ? STEP_HASHES[initialStep] : STEP_HASHES[1];
        const basePath = window.location.pathname + window.location.search;
        const initialUrl = initialHash ? (basePath + initialHash) : basePath;
        window.history.replaceState({ step: initialStep }, '', initialUrl);
      }

      updateArchiveControls();

      window.addEventListener('popstate', function (event) {
        const stateStep = event.state && typeof event.state.step === 'number'
          ? normalizeStep(event.state.step)
          : getStepFromHash(window.location.hash);
        switchStep(stateStep, { skipHistory: true });
      });

      function invalidateAnalysisState(opts) {
        opts = opts || {};
        const hadData = opts.force
          || !!(lastAnnotatedPgn
            || (lastEngineMoveRecords && lastEngineMoveRecords.length)
            || (automatedMoveInsights && Array.isArray(automatedMoveInsights.moves) && automatedMoveInsights.moves.length)
            || (automatedReviewText && String(automatedReviewText).trim()));
        if (!hadData) return;
        lastEngineMoveRecords = null;
        automatedMoveInsights = { moves: [], summary: null, moveOfGame: null };
        automatedReviewText = '';
        lastAnnotatedPgn = '';
        $('#stockfish-output').val('');
        updateFormState('annotatedPgn', '');
        $('#progress-bar').css('width', '0%');
        $('#progress-text').text('');
        if (copyStockfishBtn.length) {
          copyStockfishBtn.text(defaultCopyLabel).prop('disabled', true);
        }
        clearPuzzleState();
      }

      $('#goto-step2-btn').on('click', function(){ switchStep(2); });
      $('#back-to-step1-btn').on('click', function(){ switchStep(1); });
      $('#back-to-step2-btn').on('click', function(){ switchStep(2); });
      $('#back-to-step3-btn').on('click', function(){ switchStep(3); });
      $('#clear-pgn-btn').on('click', function(){
        const pgnInput = $('#pgn-input');
        pgnInput.val('').focus();
        updateFormState('pgnInput', '');
        invalidateAnalysisState({ force: true });
        setReviewPlayerColor(null);
        playerGameOutcome = null;
        lastFinalAnalysisText = '';
        currentReviewMetadata = null;
        updateArchiveControls();
      });
      $('#clear-final-analysis-btn').on('click', function(){
        const finalAnalysisInput = $('#final-analysis-input');
        finalAnalysisInput.val('').focus();
        updateFormState('finalAnalysisInput', '');
        lastFinalAnalysisText = '';
        currentReviewMetadata = null;
        updateArchiveControls();
      });

      $('#analyze-pgn-btn').on('click', async function () {
        const pgnRaw = $('#pgn-input').val().trim(); if (!pgnRaw) { showError('Please paste a PGN.'); return; }
        const pgn = normalizePgn(pgnRaw);
        if (!game.load_pgn(pgn)) {
          const justMoves = normalizePgn(pgnRaw.replace(/^(\s*\[.*\]\s*$)+/gm,''));
          if (!game.load_pgn(justMoves)) { showError('Invalid PGN format. Try removing engine/clock comments or share the PGN example with me.'); return; }
        }
        const rawNameForAnalysis = getRawPlayerNameInput();
        if (rawNameForAnalysis) {
          updateReviewPlayerColorFromGame(game, rawNameForAnalysis);
        }
        updatePlayerOutcomeFromGame(game);
        const depthInfoForAnalysis = getDepthSettingInfo();
        if (!depthInfoForAnalysis.valid) {
          showError('Please change the engine depth to somewhere between 4 and 30 before running the analysis.');
          $('#depth-input').focus();
          return;
        }
        await waitForEngineReady();
        if (!engineReady) { handleEngineLoadFailure('Stockfish failed to initialize.'); return; }
        switchStep(2);
        await runStockfishAnalysis();
      });

      function setCopyButtonAnalyzing(active) {
        if (!copyStockfishBtn.length) return;
        if (active) {
          copyStockfishBtn.text(analyzingCopyLabel).prop('disabled', true);
        } else {
          copyStockfishBtn.text(defaultCopyLabel).prop('disabled', false);
        }
      }

      async function runStockfishAnalysis() {
        setCopyButtonAnalyzing(true);
        try {
          configureEngineOptions();
          await waitForEngineReady();
          if (!engineReady) {
            handleEngineLoadFailure('Stockfish failed to initialize.');
            return;
          }
          setEngineMultiPv(1);
          const rawNameDuringAnalysis = getRawPlayerNameInput();
          if (rawNameDuringAnalysis) {
            updateReviewPlayerColorFromGame(game, rawNameDuringAnalysis);
          }
          const sanMoves = game.history(); let annotatedPgn = '';
          const headerBlock = buildHeaderTagBlock(game); if (headerBlock) annotatedPgn = headerBlock + '\n\n';
          const temp = new Chess();
          probSeries = [];
          let prevProb = 0.5;
          let lastMateScore = null;
          const engineMoveRecords = [];
          automatedMoveInsights = { moves: [], summary: null, moveOfGame: null };
          automatedReviewText = '';
          for (let i = 0; i < sanMoves.length; i++) {
            const moveNumber = Math.floor(i / 2) + 1; const prefix = (i % 2 === 0) ? (moveNumber + '. ') : '';
            const move = sanMoves[i];
            $('#progress-text').text('Analyzing move ' + (i + 1) + '/' + sanMoves.length + ': ' + move);
            $('#progress-bar').css('width', (((i + 1) / sanMoves.length) * 100) + '%');

            // * FIX STARTS HERE *
            // The order of operations is changed.
            // 1. Make the move on the temporary board.
            const moveObj = temp.move(move);
            const lastMoveColor = moveObj.color; // 'w' or 'b'
            const probBeforeMove = prevProb;

            // 2. Get the score for the new position *after* the move has been made.
            const score = await getScore(temp.fen(), ENGINE_GO_OPTIONS);
            // * FIX ENDS HERE *

            let evalStr = '';
            let prob = null;
            let mateScore = null;
            if (score.type === 'mate') {
              mateScore = score.value; // mate in N from side to move
              if (temp.turn() === 'b') mateScore = -mateScore; // convert to WHITE-relative
              prob = (mateScore === 0) ? (lastMoveColor === 'w' ? 1 : 0) : (mateScore > 0 ? 1 : 0);
            } else {
              let cp = score.value; // centipawns from side to move
              if (temp.turn() === 'b') cp = -cp; // convert to WHITE-relative
              prob = cpToProb(cp);
            }
            prob = clampProb(prob);
            let moverDelta = null;
            let whiteDelta = null;
            if (prob != null && prevProb != null) {
              const diff = (prob - prevProb) * 100;
              const moverSign = lastMoveColor === 'w' ? 1 : -1;
              moverDelta = diff * moverSign;
              whiteDelta = diff;
              prevProb = prob;
            } else if (prob != null) {
              prevProb = prob;
            }
            const deltaStr = formatDeltaBraced(moverDelta);
            if (mateScore != null) {
              evalStr = `{#${mateScore}}`;
            } else {
              evalStr = deltaStr || '{0}';
            }
            probSeries.push(prob);
            engineMoveRecords.push({
              index: i,
              ply: i,
              moveNumber,
              color: lastMoveColor,
              san: move,
              moverDelta,
              whiteDelta,
              whiteProbBefore: probBeforeMove,
              whiteProbAfter: prob,
              mateBefore: lastMateScore,
              mateAfter: mateScore,
              evaluation: evalStr,
              move: simplifyMoveObject(moveObj)
            });
            lastMateScore = mateScore;
            annotatedPgn += (i % 2 === 0 ? prefix : '') + move + ' ' + evalStr + ' ';
          }
          lastEngineMoveRecords = engineMoveRecords.map(mv => ({
            ...mv,
            move: mv.move ? { ...mv.move } : null
          }));
          const outcome = updatePlayerOutcomeFromGame(game);
          automatedMoveInsights = computeAutomatedMoveInsights(engineMoveRecords, reviewPlayerColor, outcome);
          automatedReviewText = buildAutomatedReviewText(automatedMoveInsights);
          lastAnnotatedPgn = annotatedPgn.trim();
          const combined = buildCombinedStockfishOutput(getPlayerName(), lastAnnotatedPgn, automatedReviewText);
          $('#progress-text').text('Analysis Complete!');
          $('#stockfish-output').val(combined);
          updateFormState('stockfishOutput', combined);
          updateFormState('annotatedPgn', lastAnnotatedPgn);
          $('#goto-step3-btn').prop('disabled', false);
        } catch (err) {
          console.error('Stockfish analysis failed', err);
          handleEngineLoadFailure('Stockfish analysis failed. Please retry.');
        } finally {
          setCopyButtonAnalyzing(false);
        }
      }

        function getScore(fen, opts) {
          return new Promise(resolve => {
            currentScoreResolver = resolve; lastInfoMsg = '';
            const o = opts || ENGINE_GO_OPTIONS || {};
            const preserveMultiPv = !!o.preserveMultiPv;
            const desiredMultiPv = Number.isFinite(o.multipv) ? Number(o.multipv) : null;
            if (!preserveMultiPv) {
              setEngineMultiPv(desiredMultiPv || 1);
            } else if (desiredMultiPv) {
              setEngineMultiPv(desiredMultiPv);
            }
            engineWorker.postMessage('position fen ' + fen);
            const parts = ['go'];
            if (o.searchmoves && Array.isArray(o.searchmoves) && o.searchmoves.length) {
              parts.push('searchmoves ' + o.searchmoves.join(' '));
            }
            if (o.depth != null) parts.push('depth ' + o.depth);
            if (o.movetime != null) parts.push('movetime ' + o.movetime);
            if (parts.length === 1) parts.push('depth 15');
            engineWorker.postMessage(parts.join(' '));
          });
        }

        async function getScoreWithTimeout(fen, opts, contextLabel) {
          let timeoutHandle = null;
          try {
            const scorePromise = getScore(fen, opts);
            const timeoutPromise = new Promise((_, reject) => {
              timeoutHandle = setTimeout(() => {
                const label = contextLabel ? ` for ${contextLabel}` : '';
                reject(new Error(`Engine response timed out${label}.`));
              }, ENGINE_REQUEST_TIMEOUT_MS);
            });
            return await Promise.race([scorePromise, timeoutPromise]);
          } catch (err) {
            console.warn('Engine request failed:', err && err.message ? err.message : err);
            return null;
          } finally {
            if (timeoutHandle) clearTimeout(timeoutHandle);
          }
        }

      function handleEngineInfoMessage(msg) {
        if (msg.startsWith('info depth')) {
          lastInfoMsg = msg;
        }
        processBestMoveInfo(msg);
        processPuzzleInfo(msg);
      }

        function normalizeFenForComparison(fen) {
          if (!fen) return '';
          const parts = String(fen).trim().split(/\s+/);
          if (parts.length < 4) return String(fen).trim();
          return parts.slice(0, 4).join(' ');
        }

      function processBestMoveInfo(msg) {
        if (!showBestMove || !bestMoveActiveToken) return;
          if (!bestMoveFen || !bestMoveFenNormalized) return;
          if (!game) return;
          const currentFen = game.fen();
          if (!currentFen) return;
          if (normalizeFenForComparison(currentFen) !== bestMoveFenNormalized) return;
          if (!msg.includes(' pv ')) return;
          const pvMatch = msg.match(/\spv\s+([^\s]+)/);
          if (!pvMatch) return;
          const move = pvMatch[1];
          if (!/^[a-h][1-8][a-h][1-8][nbrq]?$/i.test(move)) return;
          scheduleBestMoveResponseTimer(bestMoveActiveToken);
          scheduleBestMoveStallTimer(bestMoveActiveToken);
          const mateMatch = msg.match(/\bscore mate (-?\d+)/);
          const cpMatch = msg.match(/\bscore cp (-?\d+)/);
          let evalType = null;
          let evalValue = null;
          if (mateMatch) {
            evalType = 'mate';
            evalValue = parseInt(mateMatch[1], 10);
          } else if (cpMatch) {
            evalType = 'cp';
            evalValue = parseInt(cpMatch[1], 10);
          } else {
            return;
          }
          const depthMatch = msg.match(/\bdepth\s+(\d+)/);
          const depth = depthMatch ? parseInt(depthMatch[1], 10) : null;
          const multipvMatch = msg.match(/\bmultipv\s+(\d+)/);
          let multipv = multipvMatch ? parseInt(multipvMatch[1], 10) : 1;
          if (!Number.isFinite(multipv) || multipv < 1) multipv = 1;
          if (multipv <= 2) {
            bestMovePvMap[multipv] = {
              move,
              evalType,
              evalValue,
              depth
            };
          }
          const primary = bestMovePvMap[1] ? { ...bestMovePvMap[1] } : null;
          if (!primary) return;
          const secondary = bestMovePvMap[2] && bestMovePvMap[2].move ? { ...bestMovePvMap[2] } : null;
          queueBestMoveUpdate({
            primary,
            secondary,
            token: bestMoveActiveToken
          });
        }

        function queueBestMoveUpdate(info) {
          pendingBestMoveInfo = info;
          if (bestMoveUpdateTimeout) return;
          const now = Date.now();
          const elapsed = now - lastBestMoveUpdate;
          const delay = elapsed >= BEST_MOVE_UPDATE_INTERVAL ? 0 : BEST_MOVE_UPDATE_INTERVAL - elapsed;
          bestMoveUpdateTimeout = setTimeout(flushPendingBestMoveInfo, delay);
        }

        function flushPendingBestMoveInfo() {
          bestMoveUpdateTimeout = null;
          if (!pendingBestMoveInfo) return;
          const info = pendingBestMoveInfo;
          pendingBestMoveInfo = null;
          if (!showBestMove || !bestMoveActiveToken || info.token !== bestMoveActiveToken) return;
          updateBestMoveVisual(info);
          lastBestMoveUpdate = Date.now();
        }

        function cancelPendingBestMoveUpdates() {
          if (bestMoveUpdateTimeout) {
            clearTimeout(bestMoveUpdateTimeout);
            bestMoveUpdateTimeout = null;
          }
          pendingBestMoveInfo = null;
        }

        function cancelBestMoveResponseTimer() {
          if (bestMoveResponseTimeoutHandle) {
            clearTimeout(bestMoveResponseTimeoutHandle);
            bestMoveResponseTimeoutHandle = null;
          }
        }

        function cancelBestMoveStallTimer() {
          if (bestMoveStallTimeoutHandle) {
            clearTimeout(bestMoveStallTimeoutHandle);
            bestMoveStallTimeoutHandle = null;
          }
        }

        function cancelBestMoveWatchdog() {
          cancelBestMoveResponseTimer();
          cancelBestMoveStallTimer();
        }

        function scheduleBestMoveResponseTimer(token) {
          cancelBestMoveResponseTimer();
          if (!showBestMove || !token) return;
          bestMoveResponseTimeoutHandle = setTimeout(() => {
            handleBestMoveResponseTimeout(token);
          }, BEST_MOVE_RESPONSE_TIMEOUT);
        }

        function scheduleBestMoveStallTimer(token) {
          cancelBestMoveStallTimer();
          if (!showBestMove || !token) return;
          bestMoveStallTimeoutHandle = setTimeout(() => {
            handleBestMoveStallTimeout(token);
          }, BEST_MOVE_STALL_TIMEOUT);
        }

        function handleBestMoveResponseTimeout(token) {
          bestMoveResponseTimeoutHandle = null;
          if (!showBestMove || !bestMoveActiveToken || token !== bestMoveActiveToken) return;
          if (!engineReady || !engineWorker) return;
          if (!bestMoveFen || !bestMoveFenNormalized) return;
          if (!game) return;
          const currentFen = game.fen();
          if (!currentFen) return;
          const currentNormalized = normalizeFenForComparison(currentFen);
          if (currentNormalized !== bestMoveFenNormalized) return;
          engineWorker.postMessage('stop');
          engineWorker.postMessage('position fen ' + currentFen);
          setEngineMultiPv(2, { force: true });
          engineWorker.postMessage('go infinite');
          scheduleBestMoveResponseTimer(token);
        }

        function handleBestMoveStallTimeout(token) {
          bestMoveStallTimeoutHandle = null;
          if (!showBestMove || !bestMoveActiveToken || token !== bestMoveActiveToken) return;
          if (!bestMoveFen || !bestMoveFenNormalized) return;
          if (!game) return;
          const currentFen = game.fen();
          if (!currentFen) return;
          const currentNormalized = normalizeFenForComparison(currentFen);
          if (currentNormalized !== bestMoveFenNormalized) return;
          restartEngineAndRetryBestMove(token, currentFen, currentNormalized);
        }

        async function restartEngineAndRetryBestMove(token, fenSnapshot, normalizedSnapshot) {
          if (!fenSnapshot || !normalizedSnapshot) return;
          cancelBestMoveResponseTimer();
          cancelBestMoveStallTimer();
          initEngine();
          try {
            await waitForEngineReady();
          } catch (err) {
            return;
          }
          if (!showBestMove || !bestMoveActiveToken || token !== bestMoveActiveToken) return;
          if (!engineReady || !engineWorker) return;
          if (!game) return;
          const currentFen = game.fen();
          if (!currentFen) return;
          const currentNormalized = normalizeFenForComparison(currentFen);
          if (currentNormalized !== normalizedSnapshot) return;
          bestMoveFen = currentFen;
          bestMoveFenNormalized = currentNormalized;
          showBestMoveAnalyzingDisplay();
          cancelPendingBestMoveUpdates();
          engineWorker.postMessage('position fen ' + currentFen);
          setEngineMultiPv(2, { force: true });
          engineWorker.postMessage('go infinite');
          scheduleBestMoveResponseTimer(token);
          scheduleBestMoveStallTimer(token);
        }

        function setBestButtonState(text, isActive) {
          if (!toggleBestBtn.length) return;
          const label = text || defaultBestButtonLabel;
          toggleBestBtn.text(label);
          toggleBestBtn.attr('title', label);
          toggleBestBtn.attr('aria-pressed', isActive ? 'true' : 'false');
          toggleBestBtn.toggleClass('best-active', !!isActive);
        }

        function showBestMoveAnalyzingDisplay() {
          setBestButtonState('Analyzing…', true);
        }

        function hideBestMoveEvalDisplay() {
          setBestButtonState(defaultBestButtonLabel, false);
        }

        function cancelBestMoveVisualRetryTimer() {
          if (bestMoveVisualRetryHandle) {
            clearTimeout(bestMoveVisualRetryHandle);
            bestMoveVisualRetryHandle = null;
          }
        }

        function resetBestMoveVisualState() {
          cancelBestMoveVisualRetryTimer();
          pendingBestMoveVisualData = null;
          bestMovePvMap = {};
        }

        function scheduleBestMoveVisualRetry() {
          if (bestMoveVisualRetryHandle) return;
          bestMoveVisualRetryHandle = setTimeout(() => {
            bestMoveVisualRetryHandle = null;
            attemptApplyBestMoveVisual();
          }, BEST_MOVE_VISUAL_RETRY_DELAY);
        }

        function attemptApplyBestMoveVisual() {
          if (!pendingBestMoveVisualData) return;
          const data = pendingBestMoveVisualData;
          if (!showBestMove || !bestMoveActiveToken || data.token !== bestMoveActiveToken) {
            pendingBestMoveVisualData = null;
            return;
          }
          const primary = data.primary || null;
          let pieceReady = true;
          if (primary && primary.from) {
            const fromSquareEl = $('#board .square-' + primary.from);
            pieceReady = fromSquareEl.length ? fromSquareEl.find('[data-piece]').length > 0 : false;
          }
          if (!pieceReady && data.attempts < BEST_MOVE_VISUAL_RETRY_LIMIT) {
            data.attempts += 1;
            scheduleBestMoveVisualRetry();
            return;
          }
          pendingBestMoveVisualData = null;
          cancelBestMoveVisualRetryTimer();
          renderBestMoveOverlays(primary, data.secondary || null);
          lastBestMove = primary && primary.move ? primary.move : null;
          lastSecondBestMove = data.secondary && data.secondary.move ? data.secondary.move : null;
        }

        function updateBestMoveVisual(info) {
          if (!info || !info.primary || !info.primary.move) return;
          const primaryParsed = parseUciMove(info.primary.move);
          if (!primaryParsed) return;
          const primarySan = uciToSan(primaryParsed.move, bestMoveFen);
          if (!primarySan) return;
          const primaryForDisplay = { ...info.primary, san: primarySan };

          let secondaryParsed = null;
          let secondaryForDisplay = null;
          if (info.secondary && info.secondary.move) {
            const parsed = parseUciMove(info.secondary.move);
            if (parsed) {
              const san = uciToSan(parsed.move, bestMoveFen);
              if (san) {
                secondaryParsed = parsed;
                secondaryForDisplay = { ...info.secondary, san };
              }
            }
          }

          updateBestEvalDisplay(primaryForDisplay, secondaryForDisplay);
          cancelBestMoveVisualRetryTimer();
          pendingBestMoveVisualData = {
            primary: primaryParsed,
            secondary: secondaryParsed,
            token: info.token,
            attempts: 0
          };
          attemptApplyBestMoveVisual();
        }

        function updateBestEvalDisplay(primary, secondary) {
          if (!toggleBestBtn.length) return;
          const combined = formatBestEvalDisplay(primary, secondary);
          const label = combined || 'Analyzing…';
          setBestButtonState(label.trim(), true);
        }

        function formatBestEvalDisplay(primary, secondary) {
          if (!primary) return '';
          const best = formatEvalForMove('Best', primary);
          const second = secondary ? formatEvalForMove('2nd', secondary) : '';
          return [best, second].filter(Boolean).join(' | ');
        }

        function formatEvalForMove(prefix, moveInfo) {
          if (!moveInfo) return '';
          const san = moveInfo.san || '';
          const prob = getWhiteWinProbabilityForMove(moveInfo);
          if (prob != null) {
            const pct = Math.round(prob * 100);
            return `${prefix}: ${pct}% ${san}`.trim();
          }
          const evalText = formatBestEval(moveInfo);
          if (evalText) {
            const moveText = san ? ' ' + san : '';
            return `${prefix}: ${evalText}${moveText}`.trim();
          }
          return san ? `${prefix}: ${san}` : '';
        }

        function getWhiteWinProbabilityForMove(moveInfo) {
          if (!moveInfo) return null;
          const sideToMove = getSideToMoveForBestEval();
          if (moveInfo.evalType === 'mate') {
            let mate = Number(moveInfo.evalValue);
            if (!Number.isFinite(mate)) return null;
            if (sideToMove === 'b') mate = -mate;
            if (mate === 0) return sideToMove === 'w' ? 1 : 0;
            return mate > 0 ? 1 : 0;
          }
          if (moveInfo.evalType === 'cp') {
            let cp = Number(moveInfo.evalValue);
            if (!Number.isFinite(cp)) return null;
            if (sideToMove === 'b') cp = -cp;
            return clampProb(cpToProb(cp));
          }
          return null;
        }

        function getSideToMoveForBestEval() {
          const fenSource = bestMoveFen || (game && typeof game.fen === 'function' ? game.fen() : null);
          if (!fenSource) return 'w';
          const parts = String(fenSource).trim().split(/\s+/);
          if (parts.length >= 2) {
            const side = parts[1];
            if (side === 'w' || side === 'b') return side;
          }
          return 'w';
        }

        function formatBestEval(info) {
          if (!info) return '';
          const isBlackToMove = getSideToMoveForBestEval() === 'b';
          if (info.evalType === 'mate') {
            let mate = parseInt(info.evalValue, 10);
            if (!Number.isFinite(mate) || mate === 0) return '#0';
            if (isBlackToMove) mate = -mate;
            const prefix = mate > 0 ? '#' : '#-';
            return prefix + Math.abs(mate);
          }
          let cp = parseInt(info.evalValue, 10);
          if (!Number.isFinite(cp)) cp = 0;
          if (isBlackToMove) cp = -cp;
          const pawns = cp / 100;
          return (pawns >= 0 ? '+' : '') + pawns.toFixed(2);
        }

        function parseUciMove(uciMove) {
          if (!uciMove) return null;
          const moveStr = String(uciMove).trim();
          if (!/^[a-h][1-8][a-h][1-8][nbrq]?$/i.test(moveStr)) return null;
          const from = moveStr.substring(0, 2);
          const to = moveStr.substring(2, 4);
          if (!from || !to) return null;
          return { move: moveStr, from, to };
        }

        function uciToSan(uciMove, fenOverride) {
          if (!uciMove) return null;
          try {
            const baseFen = fenOverride || (game ? game.fen() : null);
            if (!baseFen) return null;
            const temp = new Chess(baseFen);
            const moveObj = { from: uciMove.substring(0, 2), to: uciMove.substring(2, 4) };
            if (uciMove.length > 4) moveObj.promotion = uciMove[4];
            const result = temp.move(moveObj);
            return result ? result.san : null;
          } catch (err) {
            return null;
          }
        }

        function clearBestMoveHighlight() {
          bestMoveAnalysisToken++;
          bestMoveActiveToken = 0;
          cancelBestMoveWatchdog();
          cancelPendingBestMoveUpdates();
          resetBestMoveVisualState();
          lastBestMoveUpdate = 0;
          bestMoveFen = null;
          bestMoveFenNormalized = null;
          if (engineWorker) engineWorker.postMessage('stop');
          setEngineMultiPv(1);
          clearTrackedMoveSquares();
          clearArrowCanvas();
          lastBestMove = null;
          lastSecondBestMove = null;
          bestMovePvMap = {};
          hideBestMoveEvalDisplay();
        }

        function ensureArrowCanvas() {
          const boardEl = document.getElementById('board');
          if (!boardEl) return;
          if (!arrowCanvas) {
            arrowCanvas = document.createElement('canvas');
            arrowCanvas.id = 'best-move-arrow';
            arrowCanvas.style.position = 'absolute';
            arrowCanvas.style.top = '0';
            arrowCanvas.style.left = '0';
            arrowCanvas.style.pointerEvents = 'none';
            boardEl.style.position = 'relative';
            boardEl.appendChild(arrowCanvas);
            arrowCtx = arrowCanvas.getContext('2d');
          }
          arrowCanvas.width = boardEl.clientWidth;
          arrowCanvas.height = boardEl.clientHeight;
        }

        function clearArrowCanvas() {
          if (arrowCtx && arrowCanvas) {
            arrowCtx.clearRect(0, 0, arrowCanvas.width, arrowCanvas.height);
          }
        }

        function drawMoveArrow(from, to, options = {}) {
          ensureArrowCanvas();
          if (!arrowCtx || !arrowCanvas) return;
          const boardEl = document.getElementById('board');
          if (!boardEl) return;
          const boardRect = boardEl.getBoundingClientRect();
          const fromEl = document.querySelector('#board .square-' + from);
          const toEl = document.querySelector('#board .square-' + to);
          if (!fromEl || !toEl) return;
          const fromRect = fromEl.getBoundingClientRect();
          const toRect = toEl.getBoundingClientRect();
          const fx = fromRect.left + fromRect.width / 2 - boardRect.left;
          const fy = fromRect.top + fromRect.height / 2 - boardRect.top;
          const tx = toRect.left + toRect.width / 2 - boardRect.left;
          const ty = toRect.top + toRect.height / 2 - boardRect.top;
          const color = options.color || 'rgb(255, 255, 0)';
          const lineWidthScale = options.lineWidthScale != null ? options.lineWidthScale : (2 / 3);
          const headLengthScale = options.headLengthScale != null ? options.headLengthScale : (2 / 3);
          const baseLineWidth = arrowCanvas.width / 35;
          const lineWidth = Math.max(2, baseLineWidth * lineWidthScale);
          const baseHeadlen = arrowCanvas.width / 10;
          const headlen = Math.max(8, baseHeadlen * headLengthScale);
          arrowCtx.strokeStyle = color;
          arrowCtx.fillStyle = color;
          arrowCtx.lineWidth = lineWidth;
          arrowCtx.lineCap = 'butt';
          arrowCtx.lineJoin = 'miter';
          const angle = Math.atan2(ty - fy, tx - fx);
          arrowCtx.beginPath();
          arrowCtx.moveTo(fx, fy);
          arrowCtx.lineTo(
            tx - headlen * Math.cos(angle),
            ty - headlen * Math.sin(angle)
          );
          arrowCtx.stroke();
          arrowCtx.beginPath();
          arrowCtx.moveTo(tx, ty);
          arrowCtx.lineTo(
            tx - headlen * Math.cos(angle - Math.PI / 6),
            ty - headlen * Math.sin(angle - Math.PI / 6)
          );
          arrowCtx.lineTo(
            tx - headlen * Math.cos(angle + Math.PI / 6),
            ty - headlen * Math.sin(angle + Math.PI / 6)
          );
          arrowCtx.closePath();
          arrowCtx.fill();
        }

        function highlightMoveSquares(from, to, color, scale = 2 / 3) {
          ensureArrowCanvas();
          if (!arrowCanvas) return null;
          const baseBorder = arrowCanvas.width / 35;
          const borderWidth = Math.max(2, baseBorder * scale);
          [from, to].forEach(sq => {
            $('#board .square-' + sq).css('box-shadow', `inset 0 0 0 ${borderWidth}px ${color}`);
          });
          return [from, to];
        }

        function clearTrackedMoveSquares() {
          if (primaryBestMoveSquares) {
            primaryBestMoveSquares.forEach(sq => {
              $('#board .square-' + sq).css('box-shadow', '');
            });
            primaryBestMoveSquares = null;
          }
          if (secondaryBestMoveSquares) {
            secondaryBestMoveSquares.forEach(sq => {
              $('#board .square-' + sq).css('box-shadow', '');
            });
            secondaryBestMoveSquares = null;
          }
        }

        function renderBestMoveOverlays(primary, secondary) {
          if (!primary && !secondary) {
            clearTrackedMoveSquares();
            clearArrowCanvas();
            return;
          }
          clearTrackedMoveSquares();
          clearArrowCanvas();
          if (secondary && secondary.from && secondary.to) {
            secondaryBestMoveSquares = highlightMoveSquares(secondary.from, secondary.to, 'rgba(255, 255, 0, 0.45)', 0.5);
            drawMoveArrow(secondary.from, secondary.to, {
              color: 'rgba(255, 255, 0, 0.55)',
              lineWidthScale: 0.5,
              headLengthScale: 0.5
            });
          }
          if (primary && primary.from && primary.to) {
            primaryBestMoveSquares = highlightMoveSquares(primary.from, primary.to, 'rgb(255, 255, 0)', 2 / 3);
            drawMoveArrow(primary.from, primary.to, {
              color: 'rgb(255, 255, 0)',
              lineWidthScale: 2 / 3,
              headLengthScale: 2 / 3
            });
          }
        }

        function reapplyStoredBestMoveVisuals() {
          if (!showBestMove) return;
          const primary = lastBestMove ? parseUciMove(lastBestMove) : null;
          const secondary = lastSecondBestMove ? parseUciMove(lastSecondBestMove) : null;
          if (!primary && !secondary) return;
          renderBestMoveOverlays(primary, secondary);
        }

        function showBestMoveForCurrentPosition() {
          cancelBestMoveWatchdog();
          if (!showBestMove || !engineReady) return;
          if (!game) return;
          resetBestMoveVisualState();
          const legalMoves = game.moves();
          if (!Array.isArray(legalMoves) || legalMoves.length === 0) {
            resetBestMoveVisualState();
            hideBestMoveEvalDisplay();
            return;
          }
          const fen = game.fen();
          if (!fen) return;
          bestMoveActiveToken = 0;
          cancelPendingBestMoveUpdates();
          lastBestMoveUpdate = 0;
          bestMoveFen = null;
          bestMoveFenNormalized = null;
          if (engineWorker) engineWorker.postMessage('stop');
          const token = ++bestMoveAnalysisToken;
          const targetNormalizedFen = normalizeFenForComparison(fen);
          setTimeout(() => {
            if (!showBestMove) return;
            if (!game) return;
            const currentFen = game.fen();
            if (!currentFen) return;
            const currentNormalized = normalizeFenForComparison(currentFen);
            if (currentNormalized !== targetNormalizedFen) return;
            bestMoveActiveToken = token;
            bestMoveFen = currentFen;
            bestMoveFenNormalized = currentNormalized;
            showBestMoveAnalyzingDisplay();
            if (engineWorker) {
              engineWorker.postMessage('position fen ' + currentFen);
              setEngineMultiPv(2, { force: true });
              engineWorker.postMessage('go infinite');
            }
            scheduleBestMoveResponseTimer(token);
            scheduleBestMoveStallTimer(token);
          }, 0);
        }

        function handleExplorationPositionChanged() {
          updateEvalGraphInteractivity();
          if (!isExploring()) {
            syncNavigationControls();
            return;
          }
          $('.move-item').removeClass('highlight');
          renderEvalGraph(-1);
          clearBestMoveHighlight();
          if (showBestMove) {
            showBestMoveAnalyzingDisplay();
            showBestMoveForCurrentPosition();
          }
          syncNavigationControls();
        }

      $('#copy-stockfish-btn').on('click', function () {
        if (!copyStockfishBtn.length || copyStockfishBtn.prop('disabled')) return;
        navigator.clipboard.writeText($('#stockfish-output').val()).then(function(){
          copyStockfishBtn.text('Copied!');
          setTimeout(function(){ copyStockfishBtn.text(defaultCopyLabel); }, 1600);
        });
      });

      $('#goto-step3-btn').on('click', function(){ switchStep(3); });

      // ====== Step 3: accept PGN or comments-only and build review ======
      $('#generate-review-btn').on('click', function () {
        currentReviewMetadata = null;
        lastFinalAnalysisText = '';
        updateArchiveControls();
        let finalAnalysisRaw = $('#final-analysis-input').val().trim();
        if (!finalAnalysisRaw) {
          if (automatedReviewText) {
            finalAnalysisRaw = automatedReviewText.trim();
            $('#final-analysis-input').val(finalAnalysisRaw);
          } else {
            showError('Please paste the final analysis.');
            return;
          }
        }
        let pgn = normalizePgn(finalAnalysisRaw); let loaded = game.load_pgn(pgn);
        const parsed = parseAnalysis(finalAnalysisRaw);
        let invalidMove = null;
        if (!loaded && parsed.moves.length) {
          const sanList = parsed.moves.map(m => m.san);
          let rebuiltPGN = buildPGNFromSAN(sanList) + ' *';
          game.reset(); loaded = game.load_pgn(rebuiltPGN);
          if (!loaded) {
            invalidMove = findInvalidMove(sanList);
          } else {
            pgn = rebuiltPGN;
          }
        }
        if (!loaded) {
          if (invalidMove) showError('Illegal move "' + invalidMove.san + '" at position ' + invalidMove.index + '.');
          else showError('Could not find or reconstruct a valid PGN from the text you pasted.');
          return;
        }

        updatePlayerOutcomeFromGame(game);
        lastFinalAnalysisText = finalAnalysisRaw;

        const rawNameForReview = getRawPlayerNameInput();
        if (rawNameForReview) {
          updateReviewPlayerColorFromGame(game, rawNameForReview, { clearOnMiss: false });
        }

        switchStep(4);

        const headersSnapshot = game && typeof game.header === 'function' ? { ...game.header() } : {};
        const pgnSnapshot = game && typeof game.pgn === 'function' ? game.pgn({ max_width: 0, newline_char: '\n' }) : '';
        const playerNameValue = getPlayerName();

        const gameMoves = game.history({ verbose: true }); let cursor = 0;
        const autoMoves = (Array.isArray(automatedMoveInsights.moves) && automatedMoveInsights.moves.length === gameMoves.length)
          ? automatedMoveInsights.moves
          : [];
        const hasAutomatedMoves = autoMoves.length > 0;
        let runningProb = autoMoves.length && autoMoves[0] && autoMoves[0].whiteProbBefore != null
          ? autoMoves[0].whiteProbBefore
          : 0.5;
        movesWithAnalysis = gameMoves.map((m, index) => {
          let analysis = null;
          if (cursor < parsed.moves.length && parsed.moves[cursor].san !== m.san) {
            const found = parsed.moves.findIndex((pm, idx) => idx >= cursor && pm.san === m.san);
            if (found !== -1) cursor = found;
          }
          if (cursor < parsed.moves.length && parsed.moves[cursor].san === m.san) analysis = parsed.moves[cursor++];

          const autoMove = hasAutomatedMoves ? (autoMoves[index] || null) : null;
          const baseProb = (autoMove && autoMove.whiteProbBefore != null)
            ? autoMove.whiteProbBefore
            : (runningProb == null ? 0.5 : runningProb);
          let prob = null;
          let moverDelta = null;
          let whiteDelta = null;

          if (analysis) {
            if (analysis.delta != null) {
              const swing = analysis.delta * (m.color === 'w' ? 1 : -1);
              whiteDelta = swing;
              const newProb = clampProb(baseProb + swing / 100);
              runningProb = newProb;
              prob = newProb;
              moverDelta = analysis.delta;
            } else {
              let targetProb = analysis.prob;
              if (targetProb == null && analysis.mate != null) {
                if (analysis.mate > 0) targetProb = 1;
                else if (analysis.mate < 0) targetProb = 0;
              }
              if (targetProb != null) {
                targetProb = clampProb(targetProb);
                whiteDelta = (targetProb - baseProb) * 100;
                moverDelta = whiteDelta * (m.color === 'w' ? 1 : -1);
                runningProb = targetProb;
                prob = targetProb;
              }
            }
          }

          if (!analysis && autoMove) {
            if (autoMove.whiteProbAfter != null) {
              prob = autoMove.whiteProbAfter;
              runningProb = autoMove.whiteProbAfter;
            }
            if (autoMove.moverDelta != null && moverDelta == null) moverDelta = autoMove.moverDelta;
            if (whiteDelta == null) {
              if (autoMove.whiteDelta != null) {
                whiteDelta = autoMove.whiteDelta;
              } else if (autoMove.whiteProbBefore != null && autoMove.whiteProbAfter != null) {
                whiteDelta = (autoMove.whiteProbAfter - autoMove.whiteProbBefore) * 100;
              }
            }
          }

          if (prob == null) {
            if (autoMove && autoMove.whiteProbAfter != null) {
              prob = autoMove.whiteProbAfter;
            } else {
              prob = runningProb == null ? baseProb : runningProb;
            }
          }
          if (prob != null) runningProb = prob;

          if (moverDelta == null && autoMove && autoMove.moverDelta != null) {
            moverDelta = autoMove.moverDelta;
          }
          if (whiteDelta == null && autoMove) {
            if (autoMove.whiteDelta != null) whiteDelta = autoMove.whiteDelta;
            else if (autoMove.whiteProbBefore != null && autoMove.whiteProbAfter != null) {
              whiteDelta = (autoMove.whiteProbAfter - autoMove.whiteProbBefore) * 100;
            }
          }

          let displayEvaluation = null;
          if (analysis) {
            const evalKind = analysis.kind;
            const originalEval = analysis.evaluation;
            if (evalKind === 'mate') {
              if (originalEval) displayEvaluation = originalEval;
              else if (analysis.mate != null) displayEvaluation = `{#${analysis.mate}}`;
            } else if (analysis.delta != null || evalKind === 'percent' || evalKind === 'cp') {
              const probForDisplay = prob != null ? prob : (analysis.prob != null ? clampProb(analysis.prob) : null);
              if (probForDisplay != null) {
                displayEvaluation = formatProbBraced(probForDisplay);
              }
            }

            if (!displayEvaluation && originalEval) {
              displayEvaluation = originalEval;
            } else if (!displayEvaluation && whiteDelta != null) {
              displayEvaluation = formatDeltaBraced(whiteDelta);
            } else if (!displayEvaluation && analysis.delta != null) {
              displayEvaluation = formatDeltaBraced(analysis.delta);
            }

            analysis.displayEvaluation = displayEvaluation;
          }

          if (!displayEvaluation && autoMove) {
            if (autoMove.evaluation) {
              displayEvaluation = autoMove.evaluation;
            } else if (Number.isFinite(autoMove.mateAfter)) {
              displayEvaluation = `{#${autoMove.mateAfter}}`;
            } else if (autoMove.whiteDelta != null) {
              displayEvaluation = formatDeltaBraced(autoMove.whiteDelta);
            }
          }

          let finalAnalysis = analysis ? { ...analysis } : null;
          if (autoMove) {
            if (!finalAnalysis) finalAnalysis = {};
            if (finalAnalysis.delta == null && autoMove.moverDelta != null) finalAnalysis.delta = autoMove.moverDelta;
            if (finalAnalysis.prob == null && autoMove.whiteProbAfter != null) finalAnalysis.prob = autoMove.whiteProbAfter;
            if (finalAnalysis.mate == null && Number.isFinite(autoMove.mateAfter)) finalAnalysis.mate = autoMove.mateAfter;
            const autoClass = autoMove.classification;
            if (autoClass) {
              if (finalAnalysis.classification && normalizeClassificationKey(finalAnalysis.classification) !== normalizeClassificationKey(autoClass)) {
                finalAnalysis.originalClassification = finalAnalysis.originalClassification || finalAnalysis.classification;
                finalAnalysis.classification = autoClass;
              } else if (!finalAnalysis.classification) {
                finalAnalysis.classification = autoClass;
              }
              finalAnalysis.automatedClassification = autoClass;
            }
            if (!finalAnalysis.displayEvaluation && displayEvaluation) {
              finalAnalysis.displayEvaluation = displayEvaluation;
            }
          } else if (finalAnalysis && displayEvaluation && !finalAnalysis.displayEvaluation) {
            finalAnalysis.displayEvaluation = displayEvaluation;
          }

          if (finalAnalysis && !finalAnalysis.text && !finalAnalysis.classification && finalAnalysis.delta == null && finalAnalysis.mate == null && !finalAnalysis.evaluation && !finalAnalysis.displayEvaluation && finalAnalysis.prob == null) {
            finalAnalysis = null;
          }

          const automated = autoMove ? { ...autoMove } : null;

          const displayEvalValue = displayEvaluation != null ? displayEvaluation : null;
          return { ...m, analysis: finalAnalysis, criticalMoment: parsed.criticalMoments[m.san], prob, delta: moverDelta, displayEvaluation: displayEvalValue, automated };
        });
        probSeries = movesWithAnalysis.map(m => m.prob);

        // Summary text
        const autoSummary = hasAutomatedMoves ? buildAutomatedSummaryLine(automatedMoveInsights.summary) : '';
        const summary = parsed.summary || autoSummary || '';
        if (summary) {
          $('#game-summary').removeClass('hidden').html(formatSummaryLine(summary));
        } else {
          $('#game-summary').addClass('hidden').html('');
        }

        featuredMoveData = parsed.featuredMove || null;
        featuredMoveIndex = -1;
        if (featuredMoveData) {
          const idx = findFeaturedMoveIndex(movesWithAnalysis, featuredMoveData);
          if (idx >= 0) {
            const meta = { ...featuredMoveData, index: idx };
            const moveRecord = movesWithAnalysis[idx];
            if (moveRecord) {
              const deltaCandidates = [
                meta.delta,
                moveRecord.delta,
                moveRecord.analysis && moveRecord.analysis.delta,
                moveRecord.automated && moveRecord.automated.moverDelta
              ];
              const resolvedDelta = deltaCandidates.find(value => {
                if (value == null || value === '') return false;
                const numeric = Number(value);
                return Number.isFinite(numeric);
              });
              if (resolvedDelta != null) {
                meta.delta = Number(resolvedDelta);
              }
              if (!meta.evaluation) {
                const evaluationCandidates = [
                  moveRecord.analysis && moveRecord.analysis.displayEvaluation,
                  moveRecord.displayEvaluation,
                  moveRecord.analysis && moveRecord.analysis.evaluation
                ];
                const evaluationValue = evaluationCandidates.find(value => value);
                if (evaluationValue) {
                  meta.evaluation = evaluationValue;
                } else if (meta.delta != null && Number.isFinite(meta.delta)) {
                  meta.evaluation = formatDeltaBraced(meta.delta);
                }
              }
              if (!meta.classification && moveRecord.analysis && moveRecord.analysis.classification) {
                meta.classification = moveRecord.analysis.classification;
              }
            }
            featuredMoveData = meta;
            featuredMoveIndex = idx;
            movesWithAnalysis[idx].isFeatured = true;
            movesWithAnalysis[idx].featuredMeta = meta;
          }
        }
        if (!featuredMoveData && hasAutomatedMoves && automatedMoveInsights.moveOfGame) {
          const autoFeatured = convertAutomatedMoveToFeatured(automatedMoveInsights.moveOfGame);
          if (autoFeatured) {
            const idx = typeof autoFeatured.index === 'number' ? autoFeatured.index : -1;
            if (idx >= 0 && idx < movesWithAnalysis.length) {
              const meta = { ...autoFeatured, index: idx };
              const moveRecord = movesWithAnalysis[idx];
              if (moveRecord) {
                const deltaCandidates = [
                  meta.delta,
                  moveRecord.delta,
                  moveRecord.analysis && moveRecord.analysis.delta,
                  moveRecord.automated && moveRecord.automated.moverDelta
                ];
                const resolvedDelta = deltaCandidates.find(value => {
                  if (value == null || value === '') return false;
                  const numeric = Number(value);
                  return Number.isFinite(numeric);
                });
                if (resolvedDelta != null) {
                  meta.delta = Number(resolvedDelta);
                }
                if (!meta.evaluation) {
                  const evaluationCandidates = [
                    moveRecord.analysis && moveRecord.analysis.displayEvaluation,
                    moveRecord.displayEvaluation,
                    moveRecord.analysis && moveRecord.analysis.evaluation
                  ];
                  const evaluationValue = evaluationCandidates.find(value => value);
                  if (evaluationValue) {
                    meta.evaluation = evaluationValue;
                  } else if (meta.delta != null && Number.isFinite(meta.delta)) {
                    meta.evaluation = formatDeltaBraced(meta.delta);
                  }
                }
                if (!meta.classification) {
                  const classCandidates = [
                    moveRecord.analysis && moveRecord.analysis.classification,
                    moveRecord.automated && moveRecord.automated.classification
                  ];
                  const classValue = classCandidates.find(value => value);
                  if (classValue) meta.classification = classValue;
                }
              }
              featuredMoveData = meta;
              featuredMoveIndex = idx;
              movesWithAnalysis[idx].isFeatured = true;
              movesWithAnalysis[idx].featuredMeta = meta;
            }
          }
        }
        renderFeaturedMoveSummary();

        if (!board) {
          board = Chessboard('board', {
            position: 'start',
            draggable: false,
            pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
          });
          $('#board').on('click', '.square-55d63', function(){ handleSquareClick($(this).data('square')); });
          $(window).on('resize', function(){
            board.resize();
            adjustAnalysisHeight();
            resizeEvalGraph();
            if (showBestMove && (lastBestMove || lastSecondBestMove)) {
              reapplyStoredBestMoveVisuals();
            }
          });
          initEvalGraph();
        }

        board.position('start');
        game.reset();
        currentMoveIndex = -1;
        clearExploration(true);
        renderMoveList();
        adjustAnalysisHeight();
        board.resize();
        resizeEvalGraph();
        renderEvalGraph(-1);
        updateMaterialDisplay();
        rebuildPuzzleQueue();

        const opponentLabel = deriveOpponentFromHeaders(headersSnapshot, reviewPlayerColor, playerNameValue);
        currentReviewMetadata = {
          headers: headersSnapshot,
          summary,
          playerColor: reviewPlayerColor,
          playerName: playerNameValue,
          opponent: opponentLabel,
          annotatedPgn: lastAnnotatedPgn,
          stockfishOutput: $('#stockfish-output').val() || '',
          pgn: pgnSnapshot,
          resultCode: headersSnapshot.Result || '',
          resultLabel: describeResult(headersSnapshot.Result || ''),
          movesCount: movesWithAnalysis.length,
          featuredMove: featuredMoveData ? { ...featuredMoveData } : null
        };
        updateArchiveControls();
        if (pendingArchiveLoadNotice) {
          showArchiveFeedback(`Loaded saved review "${pendingArchiveLoadNotice}".`, 'success');
          pendingArchiveLoadNotice = null;
        }
      });

      // Build PGN from SAN list
      function buildPGNFromSAN(sanList) { const parts = []; for (let i = 0; i < sanList.length; i++) { const n = Math.floor(i / 2) + 1; if (i % 2 === 0) parts.push(n + '. ' + sanList[i]); else parts.push(sanList[i]); } return parts.join(' '); }

      // Find first illegal move using PGN loading to avoid strict per-move checks
      function findInvalidMove(sanList) {
        const temp = new Chess();
        for (let i = 0; i < sanList.length; i++) {
          const prefix = buildPGNFromSAN(sanList.slice(0, i + 1)) + ' *';
          temp.reset();
          if (!temp.load_pgn(prefix)) return { san: sanList[i], index: i + 1 };
        }
        return null;
      }

      // Parse analysis lines with optional {eval} and final Summary:
      function parseAnalysis(text) {
        const lines = text.split('\n'); const parsedMoves = []; const criticalMoments = {}; const summaries = {}; let currentSummary = null; let lastSan = null; let summaryLine = ''; let inSummary = false; let featuredMove = null;
        const moveRegex = /^(?:\d+\.{1,3}\s*)?(\S+)(?:\s*[-–—]\s*)?(?:\s*(\{[^}]+\}))?\s*([A-Za-z0-9!?\'"()\-\s]+?)\s*:\s*(.*)/;
        const criticalMomentRegex = /^Critical Moment:\s*(.*)/i;
        const summaryHeaderRegex = /^\s*\*\*(Strengths|Recurring Mistakes|Top 3 Takeaways)\*\*/i;
        // Allow leading whitespace before "Summary:" to handle AI outputs
        // that may indent or space the final summary line.
        const summaryLineRegex = /^\s*Summary[^:]*:\s*(.*)/i;
        const moveOfGameRegex = /^\s*Move of the game:\s*((?:\d+\.{1,3}\s*|\.{3}\s*)?)(\S+)(?:\s*(?:[-–—]\s*)?(\{[^}]+\}))?\s*([A-Za-z0-9!?\'"()\-\s]+?):\s*(.*)$/i;

        function assignFeatured(match) {
          if (!match) return false;
          if (featuredMove) return true;
          const prefixRaw = match[1] || '';
          const rawSan = match[2] || '';
          const combinedSan = prefixRaw + rawSan;
          let san = normalizeSanToken(combinedSan);
          if (!san) san = normalizeSanToken(rawSan);
          if (!san) san = rawSan.trim();
          if (!san) return true;
          const needsSpace = prefixRaw && rawSan && !/\s$/.test(prefixRaw) ? ' ' : '';
          let displaySan = rawSan.trim();
          if (prefixRaw) {
            displaySan = (prefixRaw + needsSpace + rawSan).trim();
          }
          if (!displaySan) displaySan = san;
          const evaluation = (match[3] || '').trim() || null;
          const classification = (match[4] || '').trim();
          const justification = (match[5] || '').trim();
          const evalInfo = parseEvaluationToken(evaluation);
          featuredMove = { san, displaySan, evaluation, classification, text: justification, ...evalInfo };
          return true;
        }

        lines.forEach(line => {
          const trimmed = line.trim();
          if (inSummary) {
            if (!trimmed) return;
            if (assignFeatured(line.match(moveOfGameRegex))) { inSummary = false; return; }
            summaryLine += ' ' + trimmed;
            return;
          }
          const sl = line.match(summaryLineRegex);
          if (sl) { summaryLine = sl[1].trim(); inSummary = true; return; }
          if (assignFeatured(line.match(moveOfGameRegex))) return;
          const m = line.match(moveRegex);
          if (m) {
            const rawSan = m[1];
            const san = normalizeSanToken(rawSan) || rawSan.trim();
            const evaluation = (m[2] || '').trim() || null;
            const classification = m[3].trim();
            const txt = m[4].trim();
            const evalInfo = parseEvaluationToken(evaluation);
            parsedMoves.push({ san, evaluation, classification, ...evalInfo, text: txt, displaySan: rawSan.trim() });
            lastSan = san; currentSummary = null; return;
          }
          const cm = line.match(criticalMomentRegex); if (cm && lastSan) { criticalMoments[lastSan] = cm[1]; return; }
          const sh = line.match(summaryHeaderRegex); if (sh) { const key = sh[1].replace(/\s/g,''); summaries[key] = []; currentSummary = key; return; }
          if (trimmed && trimmed !== '---' && currentSummary) summaries[currentSummary].push(trimmed);
        });
        return { moves: parsedMoves, criticalMoments, summaries, summary: summaryLine, featuredMove };
      }

      // Convert evaluation string like "{+0.23}", "{-1.10}", "{#3}" (WHITE-relative already)
      function parseEvalToCp(evalStr) { if (!evalStr) return null; const s = String(evalStr).replace(/[{}\s]/g,''); if (!s) return null; if (s[0] === '#') return s.includes('-') ? -999 : 999; const num = parseFloat(s); if (isNaN(num)) return null; return Math.round(num * 100); }

      function parseEvaluationToken(evalStr) {
        const info = { prob: null, delta: null, mate: null, kind: null };
        if (!evalStr) return info;
        const s = String(evalStr).replace(/[{}\s]/g, '');
        if (!s) return info;
        if (s[0] === '#') {
          const mateNum = parseInt(s.slice(1), 10);
          if (!Number.isNaN(mateNum)) {
            info.mate = mateNum;
            if (mateNum > 0) info.prob = 1;
            else if (mateNum < 0) info.prob = 0;
            else info.prob = null;
            info.kind = 'mate';
          }
          return info;
        }
        if (s.endsWith('%')) {
          const num = parseFloat(s.slice(0, -1));
          if (!Number.isNaN(num)) {
            info.prob = num / 100;
            info.kind = 'percent';
          }
          return info;
        }
        const num = parseFloat(s);
        if (!Number.isNaN(num)) {
          info.delta = num;
          info.kind = 'delta';
          return info;
        }
        const cp = parseEvalToCp(evalStr);
        if (cp != null) {
          info.prob = cpToProb(cp);
          info.kind = 'cp';
        }
        return info;
      }

      // ====== Rendering ======
      function buildEvaluationSegments(mv) {
        const segments = [];
        if (!mv) return segments;
        let mateDisplay = '';
        if (mv.analysis && mv.analysis.kind === 'mate') {
          const mateStr = mv.analysis.displayEvaluation || mv.displayEvaluation || mv.analysis.evaluation;
          if (mateStr) {
            mateDisplay = '<span class="font-mono text-xs text-yellow-300">' + mateStr + '</span>';
            segments.push(mateDisplay);
          }
        }
        const whiteProbSource = mv.prob != null ? mv.prob : (mv.analysis ? mv.analysis.prob : null);
        if (!mateDisplay) {
          const whiteProbHtml = formatWhiteWinProbDisplay(whiteProbSource);
          if (whiteProbHtml) segments.push(whiteProbHtml);
        }
        const moverDeltaSource = mv.delta != null
          ? mv.delta
          : (mv.analysis && mv.analysis.delta != null ? mv.analysis.delta : null);
        const moverDeltaHtml = formatMoverDeltaIndicator(moverDeltaSource);
        if (moverDeltaHtml) segments.push(moverDeltaHtml);
        if (!segments.length) {
          let fallbackEval = mv.displayEvaluation;
          if (!fallbackEval && mv.analysis && mv.analysis.displayEvaluation) fallbackEval = mv.analysis.displayEvaluation;
          if (!fallbackEval && mv.analysis && mv.analysis.evaluation) fallbackEval = mv.analysis.evaluation;
          if (!fallbackEval && mv.delta != null) fallbackEval = formatDeltaBraced(mv.delta);
          if (fallbackEval) {
            segments.push('<span class="font-mono text-xs text-gray-400">' + fallbackEval + '</span>');
          }
        }
        return segments;
      }

      function normalizeEvaluationString(value) {
        if (!value) return '';
        return String(value).replace(/[{}\s]/g, '').toLowerCase();
      }

      function findFeaturedMoveIndex(list, featured) {
        if (!featured || !Array.isArray(list) || !list.length) return -1;
        let targetSan = normalizeSanToken(featured.san);
        if (!targetSan && featured.displaySan) targetSan = normalizeSanToken(featured.displaySan);
        if (!targetSan) return -1;
        const targetClass = normalizeClassificationKey(featured.classification);
        const targetEval = normalizeEvaluationString(featured.evaluation);
        const matchesBase = mv => {
          if (!mv) return false;
          if (mv.analysis && normalizeSanToken(mv.analysis.san) === targetSan) return true;
          return normalizeSanToken(mv.san) === targetSan;
        };
        const matchesClass = mv => matchesBase(mv) && mv.analysis && (!targetClass || normalizeClassificationKey(mv.analysis.classification) === targetClass);
        const matchesEval = mv => {
          if (!targetEval || !matchesClass(mv)) return false;
          const candidates = [
            mv.analysis ? mv.analysis.evaluation : null,
            mv.analysis ? mv.analysis.displayEvaluation : null,
            mv.displayEvaluation
          ];
          return candidates.some(candidate => normalizeEvaluationString(candidate) === targetEval);
        };
        let idx = -1;
        if (targetEval) idx = list.findIndex(matchesEval);
        if (idx === -1 && targetClass) idx = list.findIndex(matchesClass);
        if (idx === -1) idx = list.findIndex(matchesBase);
        return idx;
      }

      function renderFeaturedMoveSummary() {
        const container = $('#featured-move');
        if (!container.length) return;
        container.addClass('hidden').empty();
        if (!featuredMoveData) return;
        const idxFromData = typeof featuredMoveData.index === 'number' ? featuredMoveData.index : -1;
        const idx = (idxFromData >= 0 && idxFromData < movesWithAnalysis.length)
          ? idxFromData
          : ((featuredMoveIndex >= 0 && featuredMoveIndex < movesWithAnalysis.length) ? featuredMoveIndex : -1);
        const move = idx >= 0 ? movesWithAnalysis[idx] : null;
        const evaluationSegments = move ? buildEvaluationSegments(move) : [];
        let displaySan = featuredMoveData.displaySan || featuredMoveData.san;
        if (move) {
          const moveNumber = Math.floor(idx / 2) + 1;
          const prefix = move.color === 'w' ? moveNumber + '. ' : moveNumber + '... ';
          displaySan = prefix + move.san;
        }
        let evaluationHtml = '';
        if (evaluationSegments.length) {
          evaluationHtml = '<div class="flex items-center gap-2 text-xs sm:text-sm flex-wrap">' + evaluationSegments.join('') + '</div>';
        } else if (featuredMoveData.evaluation) {
          evaluationHtml = '<span class="font-mono text-xs text-yellow-300">' + featuredMoveData.evaluation + '</span>';
        }
        const classificationClass = getStyleForClassification(featuredMoveData.classification) || '';
        const classificationHtml = featuredMoveData.classification
          ? '<span class="ml-auto px-2 py-0.5 text-xs font-semibold uppercase tracking-wide rounded border border-yellow-500/40 bg-yellow-500/10 ' + classificationClass + '">' + featuredMoveData.classification + '</span>'
          : '';
        const justificationHtml = featuredMoveData.text
          ? '<p class="mt-2 text-sm text-gray-200">' + formatText(featuredMoveData.text) + '</p>'
          : '';
        const isClickable = !!move;
        const tag = isClickable ? 'button' : 'div';
        const attrs = isClickable ? ' type="button" data-move-index="' + idx + '"' : '';
        const baseClasses = 'w-full text-left p-3 sm:p-4 rounded-lg border border-yellow-500/40 bg-yellow-500/10' + (isClickable ? ' hover:bg-yellow-500/20 transition cursor-pointer focus:outline-none focus:ring-2 focus:ring-yellow-400/60' : ' opacity-90');
        const headerParts = [
          '<span class="text-xs uppercase tracking-wide text-yellow-300 font-semibold">Move of the game</span>',
          '<span class="font-bold text-lg text-white">' + displaySan + '</span>'
        ];
        if (evaluationHtml) headerParts.push(evaluationHtml);
        if (classificationHtml) headerParts.push(classificationHtml);
        const headerHtml = '<div class="flex items-center gap-3 flex-wrap sm:flex-nowrap">' + headerParts.join('') + '</div>';
        container.removeClass('hidden').html('<' + tag + attrs + ' class="' + baseClasses + '">' + headerHtml + justificationHtml + '</' + tag + '>');
        if (isClickable) {
          container.find('button[data-move-index]').on('click', function(){
            const targetIdx = Number($(this).data('move-index'));
            if (Number.isNaN(targetIdx)) return;
            clearExploration();
            goToMove(targetIdx, { scrollMode: 'none' });
          });
        }
      }

      function renderMoveList() {
        const c = $('#move-analysis-container').empty();
        movesWithAnalysis.forEach((mv, i) => {
          const n = mv.color === 'w' ? (Math.floor(i / 2) + 1) + '.' : '';
          const evalSegments = buildEvaluationSegments(mv);
          const evalHtml = evalSegments.length ? '<div class="flex items-center gap-2 ml-2">' + evalSegments.join('') + '</div>' : '';
          const moveClasses = ['move-item', 'p-2', 'cursor-pointer'];
          if (mv.isFeatured) moveClasses.push('featured');
          const classificationHtml = mv.analysis
            ? '<span class="font-semibold text-sm ml-2 ' + getStyleForClassification(mv.analysis.classification) + '">' + mv.analysis.classification + '</span>'
            : '';
          const badgeHtml = mv.isFeatured
            ? '<span class="ml-auto text-xs uppercase tracking-wide text-yellow-300 font-semibold">Move of the Game</span>'
            : '';
          const commentHtml = (mv.analysis && mv.analysis.text)
            ? '<p class="pl-12 text-gray-300 text-sm">' + formatText(mv.analysis.text) + '</p>'
            : '';
          const html =
            '<div class="' + moveClasses.join(' ') + '" data-move-index="' + i + '">' +
              '<div class="flex items-baseline gap-3">' +
                '<span class="text-gray-500 font-mono w-8 text-right">' + n + '</span>' +
                '<span class="font-bold text-lg text-white">' + mv.san + '</span>' +
                evalHtml +
                classificationHtml +
                badgeHtml +
              '</div>' +
              commentHtml +
              (mv.criticalMoment ? '<p class="pl-12 mt-1 text-xs text-yellow-300 bg-yellow-900/40 p-2 rounded">' + formatText('Critical Moment: ' + mv.criticalMoment) + '</p>' : '') +
            '</div>';
          c.append(html);
        });
        $('.move-item').on('click', function(){
          const idx = Number($(this).data('move-index'));
          if (Number.isNaN(idx)) return;
          clearExploration();
          goToMove(idx, { scrollMode: 'none' });
        });
      }

      function normalizeUciMove(value) {
        if (!value) return '';
        return String(value).trim().toLowerCase();
      }

      function buildUciFromMoveLike(move) {
        if (!move || !move.from || !move.to) return '';
        const from = String(move.from).toLowerCase();
        const to = String(move.to).toLowerCase();
        const promo = move.promotion ? String(move.promotion).toLowerCase() : '';
        return normalizeUciMove(from + to + promo);
      }

      function adjustAnalysisHeight() {
        const scroll = document.getElementById('move-analysis-scroll');
        if (!scroll) return;
        const boardEl = document.getElementById('board');
        const controls = document.getElementById('controls');
        const graphEl = document.getElementById('eval-graph');
        const isPortrait = window.matchMedia ? window.matchMedia('(orientation: portrait)').matches : false;
        const isNarrow = window.innerWidth < 1024;
        if (isPortrait || isNarrow) {
          scroll.style.height = '';
          scroll.style.maxHeight = '';
          return;
        }
        let boardHeight = 0;
        if (boardEl) {
          const boardRect = boardEl.getBoundingClientRect();
          boardHeight = boardRect.height || boardRect.width || boardEl.clientHeight || boardEl.clientWidth || 0;
        }
        let graphHeight = 0;
        if (graphEl) {
          const graphRect = graphEl.getBoundingClientRect();
          graphHeight = graphRect.height || graphEl.offsetHeight || 0;
        }
        let controlsHeight = 0;
        if (controls) {
          const controlsRect = controls.getBoundingClientRect();
          controlsHeight = controlsRect.height || controls.offsetHeight || 0;
        }
        let total = boardHeight + graphHeight + controlsHeight;
        if (!Number.isFinite(total) || total <= 0) {
          total = boardEl && boardEl.clientWidth ? boardEl.clientWidth + (graphEl ? graphEl.offsetHeight || 0 : 0) : 0;
        }
        const paddedTotal = total + 24;
        const scaledTotal = paddedTotal * 0.8;
        const finalHeight = Math.max(200, Math.round(scaledTotal));
        scroll.style.height = finalHeight + 'px';
        scroll.style.maxHeight = finalHeight + 'px';
      }

      function updateEvalGraphInteractivity() {
        if (!evalCanvas) return;
        if (isExploring()) {
          evalCanvas.classList.add('exploration-disabled');
        } else {
          evalCanvas.classList.remove('exploration-disabled');
        }
      }

      function initEvalGraph() {
        evalCanvas = document.getElementById('eval-graph');
        if (!evalCanvas) return;
        evalCtx = evalCanvas.getContext('2d');
        evalCanvas.addEventListener('click', function(e) {
          if (isExploring()) {
            clearExploration();
          }
          const totalMoves = Array.isArray(movesWithAnalysis) ? movesWithAnalysis.length : 0;
          if (!totalMoves) return;
          const rect = evalCanvas.getBoundingClientRect();
          const usableWidth = rect.width || evalCanvas.width || 1;
          const relativeX = Math.min(Math.max(e.clientX - rect.left, 0), usableWidth);
          const maxIdx = Math.max(Math.min(probSeries.length - 1, totalMoves - 1), 0);
          if (!Number.isFinite(maxIdx) || maxIdx < 0) {
            goToMove(0, { scrollMode: 'center', behavior: 'smooth' });
            return;
          }
          const ratio = usableWidth ? (relativeX / usableWidth) : 0;
          const idx = Math.round(ratio * maxIdx);
          const boundedIdx = Math.max(0, Math.min(idx, totalMoves - 1));
          goToMove(boundedIdx, { scrollMode: 'center', behavior: 'smooth' });
        });
        updateEvalGraphInteractivity();
        resizeEvalGraph();
      }

      function resizeEvalGraph() {
        if (!evalCanvas) return;
        const boardEl = document.getElementById('board');
        if (boardEl) evalCanvas.width = boardEl.clientWidth;
        evalCanvas.height = 60;
        renderEvalGraph(currentMoveIndex);
      }

      function renderEvalGraph(idx) {
        if (!evalCanvas || !evalCtx) return;
        const w = evalCanvas.width;
        const h = evalCanvas.height;
        evalCtx.clearRect(0, 0, w, h);
        const baselineY = h / 2;
        evalCtx.fillStyle = '#f9fafb';
        evalCtx.fillRect(0, 0, w, h);

        const hasProbSeries = probSeries.length > 0;
        let xPoints = [];
        let yPoints = [];

        if (hasProbSeries) {
          const maxIdx = Math.max(probSeries.length - 1, 1);
          const values = probSeries.map(p => {
            if (p == null) return null;
            const clamped = clampProb(p);
            if (clamped == null) return null;
            return (clamped - 0.5) * 100;
          });
          const validValues = values.filter(v => v != null);
          const scale = validValues.length ? Math.max(50, ...validValues.map(v => Math.abs(v))) : 50;

          xPoints = new Array(values.length);
          yPoints = new Array(values.length);
          let lastVal = 0;
          values.forEach((rawVal, i) => {
            let val = rawVal;
            if (val == null) val = lastVal;
            else lastVal = val;
            const x = (i / maxIdx) * w;
            const y = baselineY - (val / scale) * (h / 2);
            xPoints[i] = x;
            yPoints[i] = y;
          });

          if (values.length > 0) {
            evalCtx.fillStyle = '#0b0e15';
            evalCtx.beginPath();
            evalCtx.moveTo(0, 0);
            evalCtx.lineTo(w, 0);
            for (let i = values.length - 1; i >= 0; i--) {
              evalCtx.lineTo(xPoints[i], yPoints[i]);
            }
            evalCtx.closePath();
            evalCtx.fill();
          }

          if (values.length > 0 && Array.isArray(movesWithAnalysis) && movesWithAnalysis.length === xPoints.length) {
            for (let i = 0; i < movesWithAnalysis.length; i++) {
              const move = movesWithAnalysis[i];
              const classificationKey = move && move.analysis
                ? normalizeClassificationKey(move.analysis.classification)
                : '';
              if (!highlightedGraphClassifications.has(classificationKey)) continue;
              const color = classificationMarkerColors[classificationKey] || '#fbbf24';
              const x = xPoints[i];
              evalCtx.save();
              evalCtx.strokeStyle = color;
              evalCtx.lineWidth = 1.5;
              evalCtx.globalAlpha = 0.9;
              evalCtx.beginPath();
              evalCtx.moveTo(x, 0);
              evalCtx.lineTo(x, h);
              evalCtx.stroke();
              evalCtx.restore();
            }
          }
        } else {
          evalCtx.fillStyle = '#0b0e15';
          evalCtx.fillRect(0, 0, w, baselineY);
          evalCtx.fillStyle = '#f9fafb';
          evalCtx.fillRect(0, baselineY, w, baselineY);
        }

        evalCtx.strokeStyle = '#facc15';
        evalCtx.lineWidth = 1.2;
        evalCtx.beginPath();
        evalCtx.moveTo(0, baselineY);
        evalCtx.lineTo(w, baselineY);
        evalCtx.stroke();

        evalCtx.save();
        evalCtx.strokeStyle = 'rgba(250, 204, 21, 0.85)';
        evalCtx.lineWidth = 1.4;
        evalCtx.strokeRect(0.7, 0.7, w - 1.4, h - 1.4);
        evalCtx.restore();

        if (hasProbSeries) {
          const maxIdx = Math.max(probSeries.length - 1, 1);
          const drawIndexHighlight = (index, opts = {}) => {
            if (!Number.isFinite(index) || index < 0 || index >= probSeries.length) return;
            const x = Number.isFinite(xPoints[index]) ? xPoints[index] : (index / maxIdx) * w;
            const highlightWidth = Math.max(6, w * 0.008);
            const rectX = Math.max(0, x - (highlightWidth / 2));
            evalCtx.save();
            evalCtx.fillStyle = opts.fill || 'rgba(250, 204, 21, 0.18)';
            evalCtx.fillRect(rectX, 0, highlightWidth, h);
            evalCtx.restore();

            evalCtx.save();
            evalCtx.lineWidth = opts.lineWidth || 2.2;
            evalCtx.strokeStyle = opts.stroke || '#fbbf24';
            if (opts.shadowColor) {
              evalCtx.shadowColor = opts.shadowColor;
              evalCtx.shadowBlur = opts.shadowBlur || 10;
            } else {
              evalCtx.shadowColor = 'rgba(0, 0, 0, 0)';
              evalCtx.shadowBlur = 0;
            }
            evalCtx.beginPath();
            evalCtx.moveTo(x, 0);
            evalCtx.lineTo(x, h);
            evalCtx.stroke();
            evalCtx.restore();

            if (Number.isFinite(yPoints[index])) {
              const y = yPoints[index];
              evalCtx.save();
              evalCtx.fillStyle = opts.circleFill || '#facc15';
              evalCtx.strokeStyle = opts.circleStroke || '#f59e0b';
              evalCtx.lineWidth = opts.circleLineWidth || 2;
              evalCtx.beginPath();
              evalCtx.arc(x, y, opts.circleRadius || 6, 0, Math.PI * 2);
              evalCtx.fill();
              evalCtx.stroke();
              evalCtx.restore();
            }
          };

          const markers = [];
          if (idx >= 0) {
            markers.push({
              index: idx,
              opts: {
                fill: 'rgba(250, 204, 21, 0.18)',
                stroke: '#fbbf24',
                lineWidth: 2.2,
                shadowColor: 'rgba(250, 204, 21, 0.65)',
                shadowBlur: 10,
                circleFill: '#facc15',
                circleStroke: '#f59e0b',
                circleRadius: 6
              }
            });
          }
          if (puzzleActive && Number.isFinite(puzzleGraphIndex) && puzzleGraphIndex >= 0) {
            markers.push({
              index: puzzleGraphIndex,
              opts: {
                fill: 'rgba(59, 130, 246, 0.15)',
                stroke: '#60a5fa',
                lineWidth: 2,
                shadowColor: 'rgba(96, 165, 250, 0.45)',
                shadowBlur: 8,
                circleFill: '#bfdbfe',
                circleStroke: '#60a5fa',
                circleRadius: 5
              }
            });
          }

          const seen = new Set();
          markers.forEach(marker => {
            if (!marker || marker.index == null) return;
            if (seen.has(marker.index)) return;
            seen.add(marker.index);
            drawIndexHighlight(marker.index, marker.opts || {});
          });
        }
      }

      function scrollMoveList(idx, previousIndex, options) {
        const container = document.getElementById('move-analysis-scroll');
        if (!container) return;
        const opts = options || {};
        const mode = opts.scrollMode || 'none';
        const behavior = typeof opts.behavior === 'string' ? opts.behavior : 'smooth';
        const item = Number.isFinite(idx)
          ? document.querySelector('.move-item[data-move-index="' + idx + '"]')
          : null;
        if (mode === 'center') {
          if (!item) return;
          const hasScrollableContainer = container.scrollHeight > (container.clientHeight + 1);
          if (hasScrollableContainer) {
            const containerRect = container.getBoundingClientRect();
            const itemRect = item.getBoundingClientRect();
            const offsetWithinContainer = (itemRect.top - containerRect.top) + container.scrollTop;
            const target = Math.max(offsetWithinContainer - (container.clientHeight / 2) + (itemRect.height / 2), 0);
            container.scrollTo({ top: target, behavior });
          } else {
            const itemRect = item.getBoundingClientRect();
            const currentScroll = window.scrollY || window.pageYOffset || 0;
            const target = Math.max(currentScroll + itemRect.top - (window.innerHeight / 2) + (itemRect.height / 2), 0);
            window.scrollTo({ top: target, behavior });
          }
        } else if (mode === 'step') {
          if (!Number.isFinite(idx) || !Number.isFinite(previousIndex)) return;
          if (previousIndex < 0) return;
          if (!item) return;
          const direction = Math.sign(idx - previousIndex);
          if (!direction) return;
          const distance = item.offsetHeight || item.getBoundingClientRect().height || 0;
          if (!distance) return;
          const hasScrollableContainer = container.scrollHeight > (container.clientHeight + 1);
          const scrollOptions = { top: direction * distance, behavior };
          if (hasScrollableContainer) {
            container.scrollBy(scrollOptions);
          } else {
            window.scrollBy(scrollOptions);
          }
        }
      }

      function syncNavigationControls() {
        const prevBtn = $('#prev-btn');
        const nextBtn = $('#next-btn');
        if (!prevBtn.length || !nextBtn.length) return;
        if (puzzleActive) {
          prevBtn.prop('disabled', true);
          nextBtn.prop('disabled', true);
          return;
        }
        if (isExploring()) {
          const cursor = explorationState ? explorationState.cursor : 0;
          const total = explorationState ? explorationState.moves.length : 0;
          prevBtn.prop('disabled', cursor <= 0);
          nextBtn.prop('disabled', cursor >= total);
        } else {
          prevBtn.prop('disabled', currentMoveIndex < 0);
          nextBtn.prop('disabled', currentMoveIndex >= movesWithAnalysis.length - 1);
        }
      }

        function goToMove(idx, options) {
          if (idx < -1 || idx >= movesWithAnalysis.length) return;
          const previousIndex = currentMoveIndex;
          currentMoveIndex = idx;
          game.reset();
          let lastAppliedMove = null;
          for (let i = 0; i <= idx; i++) {
            const moveRecord = movesWithAnalysis[i];
            if (!moveRecord || !moveRecord.san) continue;
            const applied = game.move(moveRecord.san);
            if (applied) lastAppliedMove = applied;
          }
          if (board) board.position(game.fen(), false);
          updateMaterialDisplay();
          if (idx >= 0 && lastAppliedMove) playMoveSound(lastAppliedMove);
          $('.move-item').removeClass('highlight');
          if (idx >= 0) $('.move-item[data-move-index="' + idx + '"]').addClass('highlight');
          adjustAnalysisHeight();
          renderEvalGraph(idx);
          scrollMoveList(idx, previousIndex, options);
          clearBestMoveHighlight();
          if (showBestMove) {
            showBestMoveAnalyzingDisplay();
            showBestMoveForCurrentPosition();
          }
          syncNavigationControls();
        }

        $('#next-btn').on('click', function(){
          if (isExploring()) {
            if (!stepExploration(1)) return;
          } else {
            goToMove(currentMoveIndex + 1, { scrollMode: 'step' });
          }
        });
        $('#prev-btn').on('click', function(){
          if (isExploring()) {
            if (!stepExploration(-1)) return;
          } else {
            goToMove(currentMoveIndex - 1, { scrollMode: 'step' });
          }
        });
        $('#flip-btn').on('click', function(){
          if (board) {
            board.flip();
            if (showBestMove && (lastBestMove || lastSecondBestMove)) {
              reapplyStoredBestMoveVisuals();
            }
            updateMaterialDisplay();
          }
        });
        $('#toggle-eval-btn').on('click', function(){
          showBestMove = !showBestMove;
          if (showBestMove) {
            showBestMoveAnalyzingDisplay();
            showBestMoveForCurrentPosition();
          } else {
            clearBestMoveHighlight();
          }
        });

        if (startPuzzleBtn.length) {
          startPuzzleBtn.on('click', function(){ startPuzzleMode(); });
        }
        if (exitPuzzleBtn.length) {
          exitPuzzleBtn.on('click', function(){ exitPuzzleMode(); });
        }
        if (retryPuzzleBtn.length) {
          retryPuzzleBtn.on('click', function(){ retryPuzzle(); });
        }
        if (nextPuzzleBtn.length) {
          nextPuzzleBtn.on('click', function(){ advancePuzzle(); });
        }
        if (puzzleResultModal.length) {
          puzzleResultModal.on('click', function(evt){ if (evt.target === this) hidePuzzleResult(); });
        }
        if (closePuzzleModalBtn.length) {
          closePuzzleModalBtn.on('click', function(){ hidePuzzleResult(); });
        }

        updatePuzzleControls();
        updatePuzzleInfo();

        $(window).on('resize', function(){
          adjustAnalysisHeight();
          resizeEvalGraph();
          if (showBestMove && (lastBestMove || lastSecondBestMove)) {
            reapplyStoredBestMoveVisuals();
          }
        });
        $(document).on('keydown', function(e){
          if (!$('#review-section').is(':visible')) return;
          if (e.key === 'ArrowRight') {
            if (isExploring()) {
              stepExploration(1);
            } else {
              goToMove(currentMoveIndex + 1, { scrollMode: 'step' });
            }
          } else if (e.key === 'ArrowLeft') {
            if (isExploring()) {
              stepExploration(-1);
            } else {
              goToMove(currentMoveIndex - 1, { scrollMode: 'step' });
            }
          }
        });
      });
    </script>
</body>
</html>
